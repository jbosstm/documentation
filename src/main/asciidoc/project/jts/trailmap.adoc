
= Trail map

== Introduction

{parentProduct} assures complete, accurate business transactions for any Java based applications, including those written for the Jakarta EE and EJB frameworks.

{parentProduct} is a 100% Java implementation of a distributed transaction management system based on the Jakarta EE Java Transaction Service (JTS) standard.
Our implementation of the JTS utilizes the Object Management Group's (OMG) Object Transaction Service (OTS) model for transaction interoperability as recommended in the Jakarta EE and EJB standards.
Although any JTS-compliant product will allow Java objects to participate in transactions, one of the key features of {parentProduct} is it's 100% Java implementation.
This allows {parentProduct} to support fully distributed transactions that can be coordinated by distributed parties.

{parentProduct} runs can be run both as an embedded distributed service of an application server (e.g. {appServer}), affording the user all the added benefits of the application server environment such as real-time load balancing, unlimited linear scalability and unmatched fault tolerance that allows you to deliver an always-on solution to your customers.
It is also available as a free-standing Java Transaction Service.

In addition to providing full compliance with the latest version of the JTS specification, {parentProduct} leads the market in providing many advanced features such as fully distributed transactions and ORB portability with POA support.

{parentProduct} is tested on HP-UX 11i, Red Hat Linux, Windows Server 2003, and Sun Solaris 10, using Sun's JDK 5.
It should howerver work on any system with JDK 5 or 6.

The Java Transaction API support for {parentProduct} comes in two flavours:

* a purely local implementation, that does not require an ORB, but obviously requires all coordinated resources to reside within the same JVM.
* a fully distributed implementation.

Key features

* full compliance with the Jakarta Transactions specification:
** Purely local (ORB-less) JTA offers the fastest JTA performance
** JDBC support
** XA compliance
** JDBC drivers for database access with full transaction support
** Automatic crash recovery for XAResources
* compliance with the JTS specification and OTS 1.2 specification from the OMG
** Distributed JTA implementation
** support for distributed transactions (utilizing two-phase commit)
** POA ORB support
** interposition
** transaction heuristics
** distributed transaction manager (co-located with the transaction initiator) or transaction manager server
** checked/unchecked transaction behaviour
** supports both flat and nested transaction models, with nested-aware resources and resource adapters
** independent concurrency control system with support for type-specific concurrency control
** support for CosTransaction::Current
** direct and indirect transaction management
** synchronization interface
** explicit and implicit transaction context propagation
** automatic crash recovery
** multi-thread aware
* transactional objects (TO) for Java
* ORB independence via the ORB portability layer

This trail map will help you get started with running {parentProduct} product.
It is structured as follows:

* 1. Installation Content: This trail describes the content installed by the {parentProduct} distribution
* 2. The Sample Application: This trail describes via a set of examples how {parentProduct} is used to build transactional applications
* 3. Deploying and testing the Sample Application: This trail describes how to deploy and to test the sample application
* 4. Making the Sample Application Persistent: This trail describes tools allowing to build a persistent application
* 5. Recovery from Failure: This trail describes via a simple scenario how {parentProduct} manages recovery from failure.
* 6. Where Next?: This trail indicates where to find additional information

In addition to the trails listed above, a set of trails giving more explanation on concept around transaction processing and standards, and also a quick access to section explaining how to configure {parentProduct} are listed in the section "Additional Trails".

_Note:_ When running the local JTS transactions part of the trailmap, you will need to start the recovery manager: java com.arjuna.ats.arjuna.recovery.RecoveryManager -test

=== Overview of the X/Open DTP model

The X/Open Distributed Transaction Processing (DTP) model is a distributed transaction processing model proposed by the Open Group, a vendor consortium.
This model is a standard among most of the commercial vendors in transaction processing and database domains.

This model consists of the follwng components (illustrated in <<figure1>>)

* an Application Program (AP), which defines transaction boundaries and specifies actions that constitute a transaction
* Resource Managers (RMs) such as databases or file access systems, which provide access to resources
* a Transaction Manager (TM), which assigns identifiers to transactions, monitors their progress, and takes responsibility for transaction completion and for coordinating failure recovery
* Communication Resource Managers (CRMs), which control communication between distributed applications within or across TM domains

.The X/Open DTP model
[[figure1]]
image::../images/jts-xopen.png[align="center"]

=== Interface between functional components

There are six interfaces between software components in the X/Open DTP model.

* AP-RM.
The AP-RM interfaces give the AP access to resources.
X/Open interfaces, such as SQL and ISAM provide AP portability.
The X/Open DTP model imposes few constraints on native RM APIs.
The constraints involve only those native RM interfaces that define transactions.
* AP-TM.
The AP-TM interface (the TX interface) provides the AP with an Application Programming Interface (API) by which the AP coordinates global transaction management with the TM.
For example, when the AP calls `tx_begin()` the TM informs the participating RMs of the start of a global transaction.
After each request is completed, the TM provides a return value to the AP reporting back the success or otherwise of the TX call.
* TM-RM.
The TM-RM interface (the XA interface) lets the TM structure the work of RMs into global transactions and coordinate completion or recovery.
The XA interface is the bidirectional interface between the TM and RM.
+
The functions that each RM provides for the TM are called the `xa_*()` functions.
For example the TM calls `xa_start()` in each participating RM to start an RM-internal transaction as part of a new global transaction.
Later, the TM may call in sequence `xa_end()`, `xa_prepare()`, and `xa_commit()` to coordinate a (successful in this case) two-phase commit protocol.
The functions that the TM provides for each RM are called the ax_*( ) functions.
For example an RM calls `ax_reg()` to register dynamically with the TM.
* TM-CRM.
The TM-CRM interface (the XA+ interface) supports global transaction information flow across TM Domains.
In particular TMs can instruct CRMs by use of `xa_*()` function calls to suspend or complete transaction branches, and to propagate global transaction commitment protocols to other transaction branches.
CRMs pass information to TMs in subordinate branches by use of `ax_*()` function calls.
CRMs also use `ax_*()` function calls to request the TM to create subordinate transaction branches, to save and retrieve recovery information, and to inform the TM of the start and end of blocking conditions.
* AP-CRM.
X/Open provides portable APIs for DTP communication between APs within a global transaction.
The API chosen can significantly influence (and may indeed be fundamental to) the whole architecture of the application.
For this reason, these APIs are frequently referred to in this specification and elsewhere as communication paradigms.
In practice, each paradigm has unique strengths, so X/Open offers the following popular paradigms:
** the TxRPC interface (see the referenced TxRPC specification)
** the XATMI interface (see the referenced XATMI specification)
** the CPI-C interface (see the referenced CPI-C specification).
+
X/Open interfaces, such as the CRM APIs listed above, provide application portability.
The X/Open DTP model imposes few constraints on native CRM APIs.
* CRM-OSI TP. This interface (the XAP-TP interface) provides a programming interface between a CRM and Open Systems Interconnection Distributed Transaction Processing (OSI TP) services.
XAP-TP interfaces with the OSI TP Service and the Presentation Layer of the seven-layer OSI model.
X/Open has defined this interface to support portable implementations of application-specific OSI services.
The use of OSI TP is mandatory for communication between heterogeneous TM domains.
For details of this interface, see the referenced XAP-TP specification and the OSI TP standards.
This interface (the XAP-TP interface) provides a programming interface between a CRM and Open Systems Interconnection Distributed Transaction Processing (OSI TP) services.
XAP-TP interfaces with the OSI TP Service and the Presentation Layer of the seven-layer OSI model.
X/Open has defined this interface to support portable implementations of application-specific OSI services.
The use of OSI TP is mandatory for communication between heterogeneous TM domains.
For details of this interface, see the referenced XAP-TP specification and the OSI TP standards.

Although the aim of the Open Group was providing portable interfaces, only the XA interface appears to be accepted and implemented by a wide range of vendors.

XA is a bidirectional interface between resource managers and transaction managers.
This interface specifies two sets of functions.
The first set, called as `xa_*()` functions are implemented by resource managers for use by the transaction manager.

.XA Interface of X/Open DTP Model for the transaction manager
[cols=",",]
|===
|_Function_ |_Purpose_
|xa_start |Directs a resource manager to associate the subsequent requests by application programs to a transaction identified by the supplied identifier.
|xa_end |Ends the association of a resource manager with the transaction.
|xa_prepare |Prepares the resource manager for the commit operation. Issued by the transaction manager in the first phase of the two-phase commit operation.
|xa_commit |Commits the transactional operations. Issued by the transaction manager in the second phase of the two-phase commit operation.
|xa_recover |Retrieves a list of prepared and heuristically committed or heuristically rolled back transactions
|xa_forget |Forgets the heuristic transaction associated with the given transaction identifier
|===

The second set of functions, called as `ax_*()` functions, are implemented by the transaction manager for use by resource managers.

Table 2 - XA Interface of X/Open DTP Model for resource managers

[cols=",",]
|===
|_Function_ |_Purpose_
|ax_reg() |Dynamically enlists with the transaction manager.
|ax_unreg() |Dynamically delists from the transaction manager.
|===

=== Overview of the Distributed Transaction Processing

Transaction management is one of the most crucial requirements for enterprise application development.
Most of the large enterprise applications in the domains of finance, banking and electronic commerce rely on transaction processing for delivering their business functionality.

Enterprise applications often require concurrent access to distributed data shared amongst multiple components, to perform operations on data.
Such applications should maintain integrity of data (as defined by the business rules of the application) under the following circumstances:

* distributed access to a single resource of data, and
* access to distributed resources from a single application component.

In such cases, it may be required that a group of operations on (distributed) resources be treated as one unit of work.
In a unit of work, all the participating operations should either succeed or fail and recover together.
This problem is more complicated when

* a unit of work is implemented across a group of distributed components operating on data from multiple resources, and/or
* the participating operations are executed sequentially or in parallel threads requiring coordination and/or synchronization.

In either case, it is required that success or failure of a unit of work be maintained by the application.
In case of a failure, all the resources should bring back the state of the data to the previous state ( _i.e.,_ the state prior to the commencement of the unit of work).

From the programmer's perspective a transaction is a scoping mechanism for a collection of actions which must complete as a unit.
It provides a simplified model for exception handling since only two outcomes are possible:

* success - meaning that all actions involved within a transaction are completed
* failure - no actions complete

image::../images/jts-trans_succes_failure.PNG.png[align="center"]

=== Example

To illustrate the reliability expected by the application, let's consider the fund transfer example which is familiar to all of us.

The Money transfer involves two operations: Deposit and Withdrawal

The complexity of implementation doesn't matter; money moves from one place to another.
For instance, involved accounts may be either located in the same relational table within a database or located on different databases.

A Simple transfer consists on moving money from savings to checking while a Complex transfer can be performed at the end- of- day according to a reconciliation between international banks

image::../images/jts-example_transfer.PNG.png[align="center"]

The concept of a transaction, and a transaction manager (or a transaction processing service) simplifies the construction of such enterprise level distributed applications while maintaining the integrity of data in a unit of work.

A transaction is a unit of work that has the following properties:

* _Atomicity_ – either the whole transaction completes or nothing completes - partial completion is not permitted.
* _Consistency_ – a transaction transforms the system from one consistent state to another.
In other words, On completion of a successful transaction, the data should be in a consistent state.
For example, in the case of relational databases, a consistent transaction should preserve all the integrity constraints defined on the data.
* _Isolation_ –  Each transaction should appear to execute independently of other transactions that may be executing concurrently in the same environment.
The effect of executing a set of transactions serially should be the same as that of running them concurrently.
This requires two things:
** During the course of a transaction, intermediate (possibly inconsistent) state of the data should not be exposed to all other transactions.
** Two concurrent transactions should not be able to operate on the same data.
Database management systems usually implement this feature using locking.
* _Durabiliy_ – The effects of a completed transaction should always be persistent.

These properties, called as _ACID_ properties, guarantee that a transaction is never incomplete, the data is never inconsistent, concurrent transactions are independent, and the effects of a transaction are persistent.

==== Transactional Concepts

==== Transaction Components

A collection of actions is said to be transactional if they possess the ACID properties.
These properties are assumed to be ensured, in the presence of failures; if actions involved within the transaction are performed by a Transactional System.
A transaction system includes a set of components where each of them has a particular role.
The main components are described below.

image::../images/jts-transaction_components.PNG.png[align="center"]

==== Application Programs

Application Programs are clients for the transactional resources.
These are the programs with which the application developer implements business transactions.
With the help of the transaction manager, these components create global transactions and operate on the transactional resources with in the scope of these transactions.
These components are not responsible for implementing mechanisms for preserving ACID properties of transactions.
However, as part of the application logic, these components generally make a decision whether to commit or rollback transactions.

Application responsibilities could be summarised as follows:

* Create and demarcate transactions
* Operate on data via resource managers

A resource manager is, in general, a component that manages persistent and stable data storage system, and participates in the two phase commit and recovery protocols with the transaction manager.

A resource manager is typically a driver that provides two sets of interfaces: one set for the application components to get connections and operating, and the other set for participating in two phase commit and recovery protocols coordinated by a transaction manager.
This component may also, directly or indirectly, register resources with the transaction manager so that the transaction manager can keep track of all the resources participating in a transaction.
This process is called as resource enlistment.

Resource Manager responsibilities could be summarised as follows:

* Enlist resources with the transaction manager
* Participate in two-phase commit and recovery protocol

The transaction manager is the core component of a transaction processing environment.
Its main responsibilities are to create transactions when requested by application components, allow resource enlistment and delistment, and to manage the two-phase commit or recovery protocol with the resource managers.

A typical transactional application begins a transaction by issuing a request to a transaction manager to initiate a transaction.
In response, the transaction manager starts a transaction and associates it with the calling thread.
The transaction manager also establishes a transaction context.
All application components and/or threads participating in the transaction share the transaction context.
The thread that initially issued the request for beginning the transaction, or, if the transaction manager allows, any other thread may eventually terminate the transaction by issuing a commit or rollback request.

Before a transaction is terminated, any number of components and/or threads may perform transactional operations on any number of transactional resources known to the transaction manager.
If allowed by the transaction manager, a transaction may be suspended or resumed before finally completing the transaction.

Once the application issues the commit request, the transaction manager prepares all the resources for a commit operation, and based on whether all resources are ready for a commit or not, issues a commit or rollback request to all the resources.

Resource Manager responsibilities could be summarised as follows:

* Establish and maintain transaction context
* Maintain association between a transaction and the participating resources.
* Initiate and conduct two-phase commit and recovery protocol with the resource managers.
* Make synchronization calls to the application components before beginning and after end of the two-phase commit and recovery process

===== Local vs. Distributed Transaction

A transaction that involves only one transactional resource, such a database, is considered as _local transaction_ , while a transaction that involves more than one transactional resource that need to be coordinated to reach a consistent state is considered as a _distributed transaction._

A transaction can be specified by what is known as transaction demarcation.
Transaction demarcation enables work done by distributed components to be bound by a global transaction.
It is a way of marking groups of operations to constitute a transaction.

The most common approach to demarcation is to mark the thread executing the operations for transaction processing.
This is called as programmatic demarcation.
The transaction so established can be suspended by unmarking the thread, and be resumed later by explicitly propagating the transaction context from the point of suspension to the point of resumption.

The transaction demarcation ends after a commit or a rollback request to the transaction manager.
The commit request directs all the participating resources managers to record the effects of the operations of the transaction permanently.
The rollback request makes the resource managers undo the effects of all operations on the transaction.

===== Transaction Context and Propagation

Since multiple application components and resources participate in a transaction, it is necessary for the transaction manager to establish and maintain the state of the transaction as it occurs.
This is usually done in the form of transaction context.

Transaction context is an association between the transactional operations on the resources, and the components invoking the operations.
During the course of a transaction, all the threads participating in the transaction share the transaction context.
Thus the transaction context logically envelops all the operations performed on transactional resources during a transaction.
The transaction context is usually maintained transparently by the underlying transaction manager.

===== Resource Enlistment

Resource enlistment is the process by which resource managers inform the transaction manager of their participation in a transaction.
This process enables the transaction manager to keep track of all the resources participating in a transaction.
The transaction manager uses this information to coordinate transactional work performed by the resource managers and to drive two-phase and recovery protocol.
At the end of a transaction (after a commit or rollback) the transaction manager delists the resources.

===== Two-Phase Commit

This protocol between the transaction manager and all the resources enlisted for a transaction ensures that either all the resource managers commit the transaction or they all abort.
In this protocol, when the application requests for committing the transaction, the transaction manager issues a prepare request to all the resource managers involved.
Each of these resources may in turn send a reply indicating whether it is ready for commit or not.
Only The transaction manager issues a commit request to all the resource managers, only when all the resource managers are ready for a commit.
Otherwise, the transaction manager issues a rollback request and the transaction will be rolled back.

===== Recovery and Logging

Basically, the Recovery is the mechanism which preserves the transaction atomicity in presence of failures.
The basic technique for implementing transactions in presence of failures is based on the use of logs.
That is, a transaction system has to record enough information to ensure that it can be able to return to a previous state in case of failure or to ensure that changes committed by a transaction are properly stored.

In addition to be able to store appropriate information, all participants within a distributed transaction must log similar information, which allows them to take a same decision either to set data in their final state or in their initial state.

Two techniques are, in general, used to ensure transaction's atomicity.
A first technique focuses on manipulated data, such as the Do/Undo/Redo protocol (considered as a recovery mechanism in a centralised system), which allows a participant to set its data in their final values or to retrieve them in their initial values.
A second technique relies on a distributed protocol named the two phases commit, ensuring that all participants involved within a distributed transaction set their data either in their final values or in their initial values.
In other words, all participants must commit or all must roll back.

image::../images/jts-recovery_logs.PNG.png[align="center"]

In addition to failures, we refer as centralized such system crashes, communication failures due, for instance, to network outages or message loss have to be considered during the recovery process of a distributed transaction.

In order to provide an efficient and optimized mechanism to deal with failure, modern transactional systems typically adopt a “presume abort” strategy, which simplifies the transaction management.

The presumed abort strategy can be stated as «when in doubt, abort».
With this strategy, when the recovery mechanism has no information about the transaction, it presumes that the transaction has been aborted.

A particularity of the presumed-abort assumption allows a coordinator to not log anything before the commit decision and the participants do not to log anything before they prepare.
Then, any failure which occurs before the 2pc starts leads to abort the transaction.
Furthermore, from a coordinator's point of view, any communication failure detected by a timeout or exception raised on sending prepare is considered as a negative vote which leads to abort the transaction.
So, within a distributed transaction, a coordinator or a participant may fail in two ways: either it crashes or it times out for a message it was expecting.
When a coordinator or a participant crashes and then restarts, it uses information on stable storage to determine the way to perform the recovery.
As we will see it the presumed-abort strategy enables an optimized behavior for the recovery.

===== Heuristic Decision

In extremely rare cases, a resource manager may choose not to wait for the outcome from the transaction manager.
This might occur if the communications path was lost and was not likely to be restored for a very long time.
Typically this happens as a result of human intervention and not as an arbitrary action of a resource manager.
In order to release locks and make this transaction data available to new transactions, the resource manager makes a heuristic decision, i.e. it guesses the proper transaction outcome.
When it does so, it must remember its guess until contact with the transaction manager is ultimately re-established.

==== Standards

Saying that a distributed transaction can involve several distributed participants, means that these participants must be integrated within a global transaction manager which has the responsibility to ensure that all participants take a common decision to commit or rollback the distributed transaction.
The key of such integration is the existence of a common transactional interface which is understood by all participants, transaction manager and resource managers such as databases.

The importance of common interfaces between participants, as well as the complexity of their implementation, becomes obvious in an open systems environment.
For this aim, various distributed transaction processing standards have been developed by international standards organizations.
Among these organizations, We list three of them which are mainly considered in the {parentProduct} product:

* The X/Open model and its successful XA interface
* The OMG with its CORBA infrastructure and the Object Transaction Service and finally
* The Jakarta Transactions specification process

Basically, these standards have proposed logical models, which divide transaction processing into several functions:

* those assigned to the application which ties resources together in application-specific operations
* those assigned to the Resource manager which access physically to data stores
* functions performed by the Transaction Manager which manages transactions, and finally
* Communication Resource Managers which allow exchanging information with other transactional domains.

image::../images/jts-standards.PNG.png[align="center"]

==== Overview of the OMG Object Transaction Service

Object Transaction Service (OTS) is a distributed transaction processing service specified by the Object Management Group (OMG).
This specification extends the CORBA model and defines a set of interfaces to perform transaction processing across multiple CORBA objects.

OTS is based on the Open Group's DTP model and is designed so that it can be implemented using a common kernel for both the OTS and Open Group APIs.
In addition to the functions defined by DTP, OTS contains enhancements specifically designed to support the object environment.
Nested transactions and explicit propagation are two examples.

The CORBA model also makes some of the functions in DTP unnecessary so these have been consciously omitted.
Static registration and the communications resource manager are unnecessary in the CORBA environment.

A key feature of OTS is its ability to share a common transaction with XA compliant resource managers.
This permits the incremental addition of objects into an environment of existing procedural applications.

.OTS Architecture
[[ots_architecture]]
image::../images/jts-OTS.PNG.png[align="center"]

The OTS architecture, shown in the <<ots_architecture>>, consists of the following components:

* _Transaction Client_: A program or object that invokes operations on transactional objects.
* _Transactional Object_: A CORBA object that encapsulates or refers to persistent data, and whose behavior depends on whether or not its operations are invoked during a transaction.
* _Recoverable Object_: A transactional object that directly maintains persistent data, and participates in transaction protocols.
* _Transactional Server_: A collection of one or more transactional objects.
* _Recoverable Server_: A collection of objects, of which at least one of which is recoverable.
* _Resource Object_: A resource object is an object in the transaction service that is registered for participation in the two-phase commit and recovery protocol.

In addition to the usual transactional semantics, the CORBA OTS provides for the following features:

* _Nested Transactions_: This allows an application to create a transaction that is embedded in an existing transaction.
In this model, multiple subtransactions can be embedded recursively in a transaction.
Subtransactions can be committed or rolled back without committing or rolling back the parent transaction.
However, the results of a commit operation are contingent upon the commitment of all the transaction's ancestors.
The main advantage of this model is that transactional operations can be controlled at a finer granularity.
The application will have an opportunity to correct or compensate for failures at the subtransaction level, without actually attempting to commit the complete parent transaction.
* _Application Synchronization_: Using the OTS synchronization protocol, certain objects can be registered with the transaction service for notification before the start of and the completion of the two-phase commit process.
This enables such application objects to synchronize transient state and data stored in persistent storage.

==== Application programming models

A client application program may use direct or indirect context management to manage a transaction.
With indirect context management, an application uses the pseudo object called Current, provided by the Transaction Service , to associate the transaction context with the application thread of control.
In direct context management, an application manipulates the Control object and the other objects associated with the transaction.

An object may require transactions to be either explicitly or implicitly propagated to its operations.

* Explicit propagation means that an application propagates a transaction context by passing objects defined by the Transaction Service as explicit parameters.
This should typically be the PropagationContext structure.
* Implicit propagation means that requests are implicitly associated with the client's transaction; they share the client's transaction context.
It is transmitted implicitly to the objects, without direct client intervention.
Implicit propagation depends on indirect context management, since it propagates the transaction context associated with the Current pseudo object.
An object that supports implicit propagation would not typically expect to receive any Transaction Service object as an explicit parameter.

A client may use one or both forms of context management, and may communicate with objects that use either method of transaction propagation.
(Details of how to enable implicit propagation were described in Section Chapter 0 and Section 0).
This results in four ways in which client applications may communicate with transactional objects:

* Direct Context Management/Explicit Propagation: the client application directly accesses the Control object, and the other objects which describe the state of the transaction.
To propagate the transaction to an object, the client must include the appropriate Transaction Service object as an explicit parameter of an operation; typically this should be the PropagationContext structure.
* Indirect Context Management/Implicit Propagation: the client application uses operations on the Current pseudo object to create and control its transactions.
When it issues requests on transactional objects, the transaction context associated with the current thread is implicitly propagated to the object.
* Indirect Context Management/Explicit Propagation: for an implicit model application to use explicit propagation, it can get access to the Control using the get_control operation on the Current pseudo object.
It can then use a Transaction Service object as an explicit parameter to a transactional object; for efficiency reasons this should be the PropagationContext structure, obtained by calling get_txcontext on the appropriate Coordinator reference.
This is explicit propagation.
* Direct Context Management/Implicit Propagation: a client that accesses the Transaction Service objects directly can use the resume pseudo object operation to set the implicit transaction context associated with its thread.
This allows the client to invoke operations of an object that requires implicit propagation of the transaction context.

==== Examples

* Indirect and Implicit
+
In the code fragments below, a transaction originator uses indirect context management and implicit transaction propagation; txn_crt is an example of an object supporting the Current interface.
The client uses the begin operation to start the transaction whichbecomes implicitly associated with the originator's thread of control.
+
[source,Java]
----
...
txn_crt.begin();
// should test the exceptions that might be raised
...
// the client issues requests, some of which involve
// transactional objects;
BankAccount.makeDeposit(deposit);
...
txn_crt.commit(false)
----
+
The program commits the transaction associated with the client thread.
The report_heuristics argument is set to false so no report will be made by the Transaction Service about possible heuristic decisions.
* Direct and Explicit
+
In the following example, a transaction originator uses direct context management and explicit transaction propagation.
The client uses a factory object supporting the CosTransactions::TransactionFactory interface to create a new transaction and uses the returned Control object to retrieve the Ter mi nat or and Coordinator objects.
+
[source,Java]
----
...
CosTransactions::Control ctrl;
CosTransactions::Terminator ter;
CosTransactions::Coordinator coo;
coo = TFactory.create(0);
ter = ctrl.get_terminator();
...
transactional_object.do_operation(arg, c);
...
t.commit(false);
----
+
The client issues requests, some of which involve transactional objects, in this case explicit propagation of the context is used.
The Control object reference is passed as an explicit parameter of the request; it is declared in the OMG IDL of the interface.
The transaction originator uses the Terminator object to commit the transaction; the report_heuristics argument is set to false: so no report will be made by the Transaction Service about possible heuristic decisions.

The main difference between direct and indirect context management is the effect on the invoking thread's transaction context.
If using indirect (i.e., invoking operations through the Current pseudo object), then the thread's transaction context will be modified automatically by the OTS, e.g., if begin is called then the thread's notion of the current transaction will be modified to the newly created transaction; when that is terminated, the transaction previously associated with the thread (if any) will be restored as the thread's context (assuming subtransactions are supported by the OTS implementation).
However, if using direct management, no changes to the threads transaction context are performed by the OTS: the application programmer assumes responsibility for this.

=== OTS Interfaces

.OTS interfaces and their interactions
[[ots_interfaces]]
image::../images/jts-OTS_Interfaces.PNG.png[align="center"]

The figure "<<ots_interfaces>>" describes the principal interfaces in the CORBA OTS specification, with their interaction, while the <<ots_interfaces_table>> below provides more details for each interface.

.OTS Interfaces and their role.
[[ots_interfaces_table]]
[cols=",",]
|===
|_Interface_ |_Role and operations_
|Current a|
* Transaction demarcation (begin, commit, rollback, rollback_only, set_time_out)
* Status of the transaction (get_status)
* Name of the transaction (get_transaction_name)
* Transaction context (get_control)
|TransactionFactory a|
Explicit transaction creation:

* create a transaction with its associated cooridinator (create)
* create an interposed coordinator as a subrodinator in the transaction tree (recreate)
|Control a|
Explicit transaction context management:

* access to the transaction coordinator (get_coordinator)
* access to the transactions terminator (get_terminator)
|Terminator |Commit (commit) or rollback (rollback) a transaction in a direct transaction management mode
|Coordinator a|
* Status of the transaction (get_status, get_parent_status, get_top_level_status)
* Transaction information (is_same_transaction, is_related_transaction, is_ancestor_transaction, is_descendant_transaction, is_top_level_transaction, hash_transaciton, hash_top_level_transaction, get_transaction_name, get_txcontext)
* Resource enlistment (register_resource, register_subtrans_aware)
* Registration of synchronization objects (register_synchronization)
* Set the transaction for rollback (rollback_only)
* Create subtransactions (create_subtransaction)
|RecoveryCoordinator |Allows to coordinate recovery in case of failure ( _replay_completion_ )
|Resource |Participation in two-phase commit and recovery protocol ( _prepare, rollback, commit, commit_one_phase, forget_ )
|Synchronization |Application synchronization before beginning and after completion of two-phase commit ( _before_completion, after_completion_ )
|SubtransactionAwareResource |Commit or rollback a subtransaction ( _commit_subtransaction, rollback_subtransaction)_
|TransactionalObject |A marker interface to be implemented by all transactional objects (no operation defined)
|===

=== Managing Transactions in Jakarta EE

==== JTA/JTS Architecture

The Java transaction initiative consists of two specifications: Java Transaction Service (JTS) and Jakarta Transactions API (also known as JTA).

JTS specifies the implementation of a Java transaction manager.
This transaction manager supports the JTA, using which application servers can be built to support transactional Java applications.
Internally, the JTS implements the Java mapping of the OMG OTS specifications.

The JTA specifies an architecture for building transactional application servers and defines a set of interfaces for various components of this architecture.
The components are: the application, resource managers, and the application server, as shown in the slide.

The JTS thus provides a new architecture for transactional application servers and applications, while complying to the OMG OTS 1.1 interfaces internally.
This allows the JTA compliant applications to interoperate with other OTS 1.1 complaint applications through the standard IIOP.

As shown in <<jta_jts_transaction_model>>, in the Java transaction model, the Java application components can conduct transactional operations on JTA compliant resources via the JTS.
The JTS acts as a layer over the OTS.
The applications can therefore initiate global transactions to include other OTS transaction managers, or participate in global transactions initiated by other OTS compliant transaction managers.

.The JTA/JTS transaction model
[[jta_jts_transaction_model]]
image::../images/jts-j2ee_1.PNG.png[align="center"]

The Java Transaction Service is architected around an application server and a transaction manager.
The architecture is shown in <<jta_jts_architecture>>.

.The JTA/JTS Architecture
[[jta_jts_architecture]]
image::../images/jts-j2ee_2.PNG.png[align="center"]

The JTS architecture consists of the following components:

* _Transaction Manager_: The transaction manager is the core component of this architecture and is provided by an implementation of the JTS.
It provides interfaces to create transactions (including transaction demarcation and propagation of transaction context), allows enlistment and delistment of resources, provides interfaces for registering components for application synchronization, implements the synchronization protocol, and initiates and directs the two phase commit and recovery protocol with the resource managers.
* _Application Server_: One of the key features of the JTS architecture is that it allows an application server to be built on top of the transaction service and the resources.
Application developers can develop and deploy application components onto the application server for initiating and managing transactions.
The application server can therefore abstract all transactional semantics from the application programs.
* _Application Components_: These are the clients for the transactional resources and implement business transactions.
These are deployed on the application server.
Depending on the architecture of the application server, these components can directly or indirectly create transactions and operate on the transactional resources.
For example, an Jakarta Enterprise Beans (EJB) server allows declarative transaction demarcation, in which case, the EJB components need not directly implement the transactions.
However, a Java implementation of a CORBA OTS, requires the CORBA object to demarcate transactions explicitly.
* _Resource Manager_: A resource manager is an X/Open XA compliant component that manages a persistent and stable storage system, and participates in the two phase commit and recovery protocol with the transaction manager.
The application manager also provides interfaces for the application server and the application components to operate on the data managed by it.
* _Communication Resource Manager_: This allows the transaction manager to participate in transactions initiated by other transaction managers.
However, the JTS specification does not specify any protocol for this communication and assumes that an implementation of the communication resource manager supports the CORBA OTS and GIOP specifications.

==== Jakarta Transactions API (formally JTA)

The Jakarta Transactions specification may be classified into three categories of interface as shown in <<jta_interfaces>>.
The Java Transaction API consists of three elements: a high-level application transaction demarcation interface, a high-level transaction manager interface intended for application server, and a standard Java mapping of the X/Open XA protocol intended for transactional resource manager.

.JTA Interfaces
[[jta_interfaces]]
image::../images/jts-j2ee_3_API.PNG.png[align="center"]

===== Transaction Manager Interfaces

* `jakarta.transaction.Status`: Defines the following flags for the status of a transaction:

.Transaction Status Flags
[[transaction_status_flags]]
[cols=",",]
|===
|_Flag_ |_Purpose_
|STATUS_ACTIVE |Transaction is active (started but not prepared)
|STATUS_COMMITTED |Transaction is committed
|STATUS_COMMITTING |Transaction is in the process of committing.
|STATUS_MARKED_ROLLBACK |Transaction is marked for rollback.
|STATUS_NO_TRANSACTION |There is no transaction associated with the current Transaction, UserTransaction or TransactionManager objects.
|STATUS_PREPARED |Voting phase of the two phase commit is over and the transaction is prepared.
|STATUS_PREPARING |Transaction is in the process of preparing.
|STATUS_ROLLEDBACK |Outcome of the transaction has been determined as rollback. It is likely that heuristics exists.
|STATUS_ROLLING_BACK |Transaction is in the process of rolling back.
|STATUS_UNKNOWN |A transaction exists but its current status can not be determined. This is a transient condition
|===

The `jakarta.transaction.Transaction`, `jakarta.transaction.TransactionManager`, and `jakarta.transaction.UserTransaction` interfaces provide a `getStatus` method that returns one of the above status flags.

* `jakarta.transaction.Transaction`: An object of this type is created for each global transaction.
This interface provides methods for transaction completion(commit and rollback), resource enlistment (enlistResource) and delistment (delistResource), registration of synchronization objects (registerSynchronization), and query of status of the transaction (getStatus).
* `jakarta.transaction.TransactionManager`: This interface is implemented by the JTS and allows an application server to communicate with the transaction manager to demarcate transactions (begin, commit, rollback), suspending and resuming transactions (suspend and resume), set the transaction for rollback (setRollbackOnly), get the associated Transaction object (getTransaction), set the transaction timeout interval (setTransactionTimeout) and query the status of the transaction (getStatus).
* `jakarta.transaction.UserTransaction`: This interface provides methods to begin and end transactions (begin, commit, and rollback), set the transaction for rollback (setRollbackOnly), set the transaction timeout interval (setTransactionTimeout), and get the status of the transaction (getStatus).
Nested transactions are not supported, and begin throws the NotSupportedException when the calling thread is already associated with a transaction.
UserTransaction automatically associates newly created transactions with the invoking thread.
* `javax.transaction.xa.Xid`: This interface is a Java mapping of the X/Open transaction identifier xid structure.
The transaction manager uses an object of this type to associate a resource manager with a transaction.

===== Resource Manager Interfaces

* `javax.transaction.xa.XAResource`: This is a Java mapping of the X/Open XA interface, and is implemented by resource managers operating with the JTS.
This interface provides methods to start (start) and end (end) work on behalf of a specified transaction, to prepare a transaction with the current resource (prepare), to end transactions with the current resource (commit, forget, recover, and rollback), to compare the current resource manager with another resource manager (isSameRM), and to get and set the transaction timeout (getTransactionTimeout, setTransactionTimeout).

===== Application Interfaces

The only interface that an application object could implement is the Synchronization interface.
The application components may have to implement whatever other interfaces are mandated by a given application server.

* `jakarta.transaction.Synchronization`: An object intended to participate in a synchronization protocol with the transaction manager should implement this interface.
This mechanism is based on the Observer pattern.
This interface has two methods - beforeCompletion and afterCompletion to be called before starting and after completing, respectively, the two phase commit operation.

==== Jakarta Transactions API - Usage

This section describes the usage of the JTA for implementing various transaction semantics.
The purpose of this section is to provide conceptual guidelines only.

===== Transaction Demarcation

The Jakarta Transactions specifies two approaches with which new global transactions can be initiated and demarcated.

The application component can then use this object to begin, commit and rollback transactions.
In this approach, association between the calling thread and the transaction, and transaction context propagation are handled transparently by the transaction manager.

.Usage
[source,java]
----
// Get a UserTransaction object
// Begin a transaction
userTransaction.begin();
// Transactional operations ...
// End the transaction
userTransaction.commit();
----

.Usage
[source,java]
----
// Begin a transaction
Transaction t = TransactionManager.begin();
// Transactional operations ...
// End the transaction
TransactionManager.commit();
----

* Application Program Demarcation: The `jakarta.transaction.UserTransaction` interface provides methods for application components to begin and end transactions programmatically.
The underlying application server should provide a mechanism to obtain a reference to this object.
The Jakarta Transactions specification requires that the application servers use the JNDI for storing references to UserTransaction objects and for lookup.
* Application Server Controlled Demarcation: In this approach, the `jakarta.transaction.TransactionManager` interface controls transaction demarcation on behalf of the application being managed.
The transaction manager also maintains the transaction context and its association with the calling threads implicitly.

===== Resource Enlistment and Delistment

Transactional resources such as database connections are typically managed by the application server in conjunction with some resource adapter and optionally with connection pooling optimisation.
In order for an external transaction manager to co-ordinate transactional work performed by the resource managers, the application server must enlist and de-list the resources used in the transaction.
These resources (participants) are enlisted with the transaction so that they can be informed when the transaction terminates, e.g. are driven through the two-phase commit protocol.

Jakarta Transactions is much more closely integrated with the XA concept of resources than the arbitrary objects.
For each resource in-use by the application, the application server invokes the enlistResource method with an XAResource object which identifies the resource in use.

The enlistment request results in the transaction manager informing the resource manager to start associating the transaction with the work performed through the corresponding resource.
The transaction manager is responsible for passing the appropriate flag in its XAResource.start method call to the resource manager.

The delistResource method is used to disassociate the specified resource from the transaction context in the target object.
The application server invokes the method with the two parameters: the XAResource object that represents the resource, and a flag to indicate whether the operation is due to the transaction being suspended (TMSUSPEND), a portion of the work has failed (TMFAIL), or a normal resource release by the application (TMSUCCESS).

The de-list request results in the transaction manager informing the resource manager to end the association of the transaction with the target XAResource.
The flag value allows the application server to indicate whether it intends to come back to the same resource whereby the resource states must be kept intact.
The transaction manager passes the appropriate flag value in its XAResource.end method call to the underlying resource manager.

The application server can enlist and delist resource managers with the transaction manager using the `jakarta.transaction.Transaction` interface

.Usage
Resource enlistment is in general done by the application server when an application requests it for a connection to a transactional resource.
[source,Java]
----
// ... an implementation of the application server
// Get a reference to the underlying TransactionManager object.
...
// Get the current Transaction object from the TransactionManager.
transaction = transactionManager.getTransaction();
// Get an XAResource object from a transactional resource.
...
// Create a Transaction object.
...
// Enlist the resource
transaction.enlistResource(xaResource);...
// Return the connection to the application.
...
----

Resource delistment is done similarly after the application closes connections to transactional resources.

===== Application Synchronization with a Transaction

Using the JTS synchronization protocol, certain objects can be registered with the transaction manager for notification before the start of and the completion of the two-phase commit process.
This enables such application objects to synchronize transient state and data stored in persistent storage.

The `jakarta.transaction.Transaction` interface provides the _registerSynchronization_ method to register `jakarta.transaction.Synchronization` objects with the transaction manager.
The transaction manager then uses the synchronization protocol and calls the beforeCompletion and afterCompletion methods before and after the two phase commit process.

* The _beforeCompletion_ method is called prior to the start of the two-phase transaction complete process.
This call is executed in the same transaction context of the caller who initiates the TransactionManager.commit or the call is executed with no transaction context if Transaction.commit is used.
* The _afterCompletion_ method is called after the transaction has completed.
The status of the transaction is supplied in the parameter.
This method is executed without a transaction context.

===== Further Reading

* JDBC and Transactions
* Jakarta Enterprise Beans and Transactions

=== Managing Transactions in EJB

==== An Application Server Model - The Jakarta Enterprise Beans

===== EJB Overview

Jakarta Enterprise Beans (EJB) is a technology specification that specifies a framework for building component-based distributed applications.
As an application server framework, the EJB servers address transaction processing, resource pooling, security, threading, persistence, remote access, life cycle etc.

The EJB framework specifies construction, deployment and invocation of components called as enterprise beans.
The EJB specification classifies enterprise beans into two categories: entity beans and session beans.
While entity beans abstract persistent domain data, session beans provide for session-specific application logic.
Both types of beans are maintained by EJB compliant servers in what are called as containers.
A container provides the run time environment for an enterprise bean.
The <<ejb_and_transactions>> shows a simplified architecture of transaction management in EJB compliant application servers.

.EJB and Transactions
[[ejb_and_transactions]]
image::../images/jts-j2ee_5_ejb_model.PNG.png[align="center"]

An enterprise bean is specified by two interfaces: the home interface and the remote interface.
The home interface specifies how a bean can be created or found.
With the help of this interface, a client or another bean can obtain a reference to a bean residing in a container on an EJB server.
The remote interface specifies application-specific methods that are relevant to entity or session beans.

Clients obtain references to home interfaces of enterprise beans via the Java Naming and Directory Interface (JNDI) mechanism.
An EJB server should provide a JNDI implementation for any naming and directory server.
Using this reference to the home interface, a client can obtain a reference to the remote interface.
The client can then access methods specified in the remote interface.
The EJB specification specifies the Java Remote Method Invocation (RMI) as the application level protocol for remote method invocation.
However, an implementation can use IIOP as the wire-level protocol.

In <<ejb_and_transactions>>, the client first obtains a reference to the home interface, and then a reference to an instance of Bean A via the home interface.
The same procedure is applicable for instance of Bean A to obtain a reference and invoke methods on an instance of Bean B.

===== EJB Transaction Model

The EJB framework does not specify any specific transaction service (such as the JTS) or protocol for transaction management.
However, the specification requires that the `jakarta.transaction.UserTransaction` interface of the JTS be exposed to enterprise beans.
This interface is required for programmatic transaction demarcation as discussed in the next section.

The EJB framework allows both programmatic and declarative demarcation of transactions.
Declarative demarcation is needed for all enterprise beans deployed on the EJB.
In addition, EJB clients can also initiative and end transactions programmatically.

The container performs automatic demarcation depending on the transaction attributes specified at the time of deploying an enterprise bean in a container.
The following attributes determine how transactions are created.

* _NotSupported_: The container invokes the bean without a global transaction context.
* _Required_: The container invokes the bean within a global transaction context.
If the invoking thread already has a transaction context associated, the container invokes the bean in the same context.
Otherwise, the container creates a new transaction and invokes the bean within the transaction context.
* _Supports_: The bean is transaction-ready.
If the client invokes the bean within a transaction, the bean is also invoked within the same transaction.
Otherwise, the bean is invoked without a transaction context.
* _RequiresNew_: The container invokes the bean within a new transaction irrespective of whether the client is associated with a transaction or not.
* _Mandatory_: The container must invoke the bean within a transaction.
The caller should always start a transaction before invoking any method on the bean.

===== Transaction Demarcation

The EJB framework supports three types of transaction demarcation.

* _Declarative Demarcation_: This is also called as container managed demarcation.
The container demarcates transactions on behalf of the bean.
The Required or RequiresNew attribute is specified in a deployment descriptor at the time of deploying the bean on an EJB server.
The bean can use the `jakarta.ejb.EJBContext.setRollbackOnly()` method to mark the transaction for rollback.
* Bean Managed Demarcation: This is similar to the client-managed demarcation.
* Client Managed Demarcation: Java clients can use the `jakarta.transaction.UserTransaction` interface to demarcate transactions programmatically.

===== Resource Enlistment

Resource enlistment is automatic with EJB.
The EJB containers automatically enlists connections to EJB-aware resource managers whenever a bean obtains a connection.

===== Application Synchronization

The EJB specification provides the jakarta.ejb.SessionSynchronization interface for application synchronization.
When implemented by a bean, the container calls the afterBegin, beforeCompletion and afterCompletion methods for application synchronization during the two-phase commit process.

=== JDBC and Transactions

Java Data Base Connectivity, provide Java programs with a way to connect to and use relational databases.
The JDBC API lets you invoke SQL commands from Java programming language methods.
In simplest terms, JDBC allows to do three things

* Establish a connection with a database
* Send SQL statements
* Process the results

The following code fragment gives a simple example of these three steps:

[source,Java]
----
Connection con = DriverManager.getConnection(
        "jdbc:myDriver:wombat", "myLogin", "myPassword");
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery("SELECT a, b, c FROM Table1");
while (rs.next()) {
    int x = rs.getInt("a");
    String s = rs.getString("b");
    float f = rs.getFloat("c");
}
----

Before the version 2.0 of JDBC, only local transactions controlled by the transaction manager of the DBMS is possible.
To code a JDBC transaction, you invoke the commit and rollback methods of the java.sql.Connection interface.
The beginning of a transaction is implicit.
A transaction begins with the first SQL statement that follows the most recent commit, rollback, or connect statement.
(This rule is generally true, but may vary with DBMS vendor.).
The following example illustrates how transactions are managed by the JDBC API.

[source,Java]
----
public void withdraw (double amount) {
    try {
        // A connection opened with JDBC is an AUTO COMMIT mode meaning
        // that the commitment is automatically performed when the connection
        // is closed
        //setAutoCommit to false disable this feature
        connection.setAutoCommit(false);
        //perform an SQL update to Withdraw money from account
        connection.commit();
    } catch (Exception ex) {
        try {
            connection.rollback();
            throw new Exception("Transaction failed: " +  ex.getMessage());
        } catch (Exception sqx) {
            throw new Exception(...)
        }
    }
}
----

From the version 2.0, a JDBC driver can be involved within a distributed transaction since it supports the XAResource interface that allows to participate to the 2PC protocol.
An application that need to include more than one database can create a JTA transaction.
To demarcate a JTA transaction, the application program invokes the begin, commit, and rollback methods of the `jakarta.transaction.UserTransaction` interface.
The following code, that can be applied to a bean-managed transaction, demonstrates the UserTransaction methods.
The begin and commit invocations delimit the updates to the database.
If the updates fail, the code invokes the rollback method and throws an Exception.

[source,Java]
----
public void transfer(double amount) {
    UserTransaction ut = context.getUserTransaction();

    try {
        ut.begin();
        // Perform SQL command to debit account 1
        // Perform SQL command to debit account 2
        ut.commit();
    } catch (Exception ex) {
        try {
            ut.rollback();
        } catch (Exception ex1) {
            throw new Exception ("Rollback failed: " + ex1.getMessage());
        }
        throw new Exception ("Transaction failed: " + ex.getMessage());
    }
}
----

=== Configuring the {parentProduct}

This trail provides information on the way to configure environmental variables needed to define the behaviour of transactional applications managed with {parentProduct}.
Basically, the behaviour of the {parentProduct} product is configurable through property attributes.
Although these property attributes may be specified as command line arguments, it is more convenient to organise and initialise them through properties files.

==== Properties File

The properties file named `jbossts-properties.xml` and located under the <ats_installation_directory>/etc directory is organised as a collection of property names.

[source,Java]
----
<property>
    name="a_name"
    value="a_value"
</property>
----

Some properties must be specified by the developer while others do not need to be defined and can be used with their default values.
Basically, the properties file that does not provide default values to all its properties is the `jbossts-properties.xml`.

The following table describes some properties in the `jbossts-properties.xml`, where:

* _Name_: indicates the name of the property
* _Description_: explain the aim of the property
* _Possible Value_: indicates possible value the property can have
* _Default Value_: shows the default value, if any, assigned to the property

[cols=",,,",]
|===
|_Name_ |_Description_ |_Possible Value_ |_Default Value_
|`com.arjuna.ats.arjuna.objectstore.localOSRoot` |By default, all object states will be stored within the "defaultStore" subdirectory of the object store root. However, this subdirectory can be changed by setting the localOSRoot property variable accordingly |Directory name |defaultStore
|`com.arjuna.ats.arjuna.objectstore.objectStoreDir` |Specify the location of the ObjectStore |Directory name |PutObjectStoreDirHere
|`com.arjuna.ats.arjuna.common.varDir` |{parentProduct} needs to be able to write temporary files to a well known location during execution. By default this location is var. However, by setting the varDir property variable this can be overridden. |Directory name |var/tmp
|===

==== ObjectStore management

The {parentProduct} layer requires an object store for transaction management logs.
Within the transaction service installation, object store is updated regularly whenever transactions are created, or when Transactional Objects for Java is used.
In a failure-free environment, the only object states which should reside within the object store are those representing objects created with the Transactional Objects for Java API.
However, if failures occur, transaction logs may remain in the object store until crash recovery facilities have resolved the transactions they represent.
As such, it is very important that the contents of the object store are not deleted without due care and attention, as this will make it impossible to resolve in doubt transactions.
In addition, if multiple users share the same object store it is important that they realise this and do not simply delete the contents of the object store assuming it is an exclusive resource.

The location of the ObjectStore is specified in via the properrty `com.arjuna.ats.arjuna.objectstore.objectStoreDir` that can be passed with the java flag "-D".
For convenience this property is defined in the properties file `jbossts-properties.xml`, and its value is set during the {parentProduct} installation.
At any time, the location of the ObjectStore may be changed.

==== Configuring Output

Sometimes it is desirable, mainly in case of debugging, to have some form of output during execution to trace internal actions performed. {parentProduct} uses the logging tracing mechanism provided by the Arjuna Common Logging Framework (CLF) version 2.4, which provides a high level interface that hides differences that exist between logging APIs such Jakarta log4j, JDK 1.4 logging API or dotnet logging API.

With the CLF applications make logging calls on commonLogger objects.
These commonLogger objects pass log messages to Handler for publication.
Both commonLoggers and Handlers may use logging Levels to decide if they are interested in a particular log message.
Each log message has an associated log Level, that gives the importance and urgency of a log message.
The set of possible Log Levels are DEBUG, INFO, WARN, ERROR and FATAL.
Defined Levels are ordered according to their integer values as follows: DEBUG < INFO < WARN < ERROR < FATAL.

The CLF provides an extension to filter logging messages according to finer granularity an application may define.
That is, when a log message is provided to the commonLogger with the DEBUG level, additional conditions can be specified to determine if the log message is enabled or not.

[NOTE]
====
These conditions are applied if and only the DEBUG level is enabled and the log request performed by the application specifies debugging granularity.
====

When enabled, Debugging is filtered conditionally on three variables:

* Debugging level: this is where the log request with the DEBUG Level is generated from, e.g., constructors or basic methods.
* Visibility level: the visibility of the constructor, method, etc. that generates the debugging.
* Facility code: for instance the package or sub-module within which debugging is generated, e.g., the object store.

According to these variables the Common Logging Framework defines three interfaces.
A particular product may implement its own classes according to its own finer granularity. {parentProduct} uses the default Debugging level and the default Visibility level provided by CLF, but it defines its own Facility Code. {parentProduct} uses the default level assigned to its commonLoggers objects (DEBUG).
However, it uses the finer debugging features to disable or enable debug messages.
Finer values used by the {parentProduct} are defined below:

* Debugging level – {parentProduct} uses the default values defined in the class `com.arjuna.common.util.logging.CommonDebugLevel`

[cols=",,",]
|===
|_Debug Level_ |_Value_ |_Description_
|NO_DEBUGGING |0x0000 |A commonLogger object assigned with this values discard all debug requests
|CONSTRUCTORS |0x0001 |Diagnostics from constructors
|DESTRUCTORS |0x0002 |Diagnostics from finalizers.
|CONSTRUCT_AND_DESTRUCT |CONSTRUCTORS | DESTRUCTORS |Diagnostics from constructors and finalizers
|FUNCTIONS |0x010 |Diagnostics from functions
|OPERATORS |0x020 |Diagnostics from operators, such as equals
|FUNCS_AND_OPS |FUNCTIONS | OPERATORS |Diagnostics from functions and operations.
|ALL_NON_TRIVIAL |CONSTRUCT_AND_DESTRUCT | FUNCTIONS | OPERATORS |Diagnostics from all non-trivial operations
|TRIVIAL_FUNCS |0x0100 |Diagnostics from trivial functions.
|TRIVIAL_OPERATORS: |0x0200 |Diagnostics from trivial operations, and operators.
|ALL_TRIVIAL |TRIVIAL_FUNCS | TRIVIAL_OPERATORS |Diagnostics from all trivial operations
|FULL_DEBUGGING |0xffff |Full diagnostics.
|===

* Visibility level – {parentProduct} uses the default values defined in the class com.arjuna.common.util.logging.CommonVisibilityLevel

[cols=",,",]
|===
|_Debug Level_ |_Value_ |_Description_
|VIS_NONE |0x0000 |No Diagnostic
|VIS_PRIVATE |0x0001 |only from private methods.
|VIS_PROTECTED |0x0002 |only from protected methods.
|VIS_PUBLIC |0x0004 |only from public methods.
|VIS_PACKAGE |0x0008 |only from package methods.
|VIS_ALL |0xffff |Full Diagnostic
|===

* Facility Code – {parentProduct} uses the following values

[cols=",,",]
|===
|_Facility Code Level_ |_Value_ |_Description_
|FAC_ATOMIC_ACTION |0x00000001 |atomic action core module
|FAC_BUFFER_MAN |0x00000004 |state management (buffer) classes
|FAC_ABSTRACT_REC |0x00000008 |abstract records
|FAC_OBJECT_STORE |0x00000010 |object store implementations
|FAC_STATE_MAN |0x00000020 |state management and StateManager)
|FAC_SHMEM |0x00000040 |shared memory implementation classes
|FAC_GENERAL |0x00000080 |general classes
|FAC_CRASH_RECOVERY |0x00000800 |detailed trace of crash recovery module and classes
|FAC_THREADING |0x00002000 |threading classes
|FAC_JDBC |0x00008000 |JDBC 1.0 and 2.0 support
|FAC_RECOVERY_NORMAL |0x00040000 |normal output for crash recovery manager
|===

To ensure appropriate output, it is necessary to set some of the finer debug properties explicitly as follows:

[source,XML]
----
<properties>
    <!-- CLF 2.4 properties -->
    <property
            name="com.arjuna.common.util.logging.DebugLevel"
            value="0x00000000"/>
    <property
            name="com.arjuna.common.util.logging.FacilityLevel"
            value="0xffffffff"/>
    <property
            name="com.arjuna.common.util.logging.VisibilityLevel"
            value="0xffffffff"/>
    <property
            name="com.arjuna.common.util.logger"
            value="log4j"/>
</properties>
----

By default, debugging messages are not enabled since the DebugLevel is set to NO_DEBUGGING (0x00000000).
You can enable debugging by providing one of the appropriate value listed above - for instance with you wish to see all internal actions performed by the RecoveryManager to recover transactions from a failure set the DebugLevel to FULL_DEBUGGING (0xffffffff) and the FacilityCode Level FAC_CRASH_RECOVERY.

_Note_ : To enable finger debug messages, the logging level should be set to the DEBUG level as described below.

From the program point of view a same API is used whatever the underlying logging mechanism, but from a configuration point of view is that the user is totally responsible for the configuration of the underlying logging system.
Hence, the properties of the underlying log system are configured in a manner specific to that log system, e.g., a log4j.properties file in the case that log4j logging is used.
To set the logging level to the DEBUG value, the log4j.properties file can be edited to set that value.

The property com.arjuna.common.util.logger allows to select the underlying logging system.
Possible value are listed in the following table.

[cols=",",]
|===
|_Property Value_ |_Description_
|log4j |Log4j logging (log4j classes must be available in the classpath); configuration through the log4j.properties file, which is picked up from the `CLASSPATH` or given through a System property: log4j.configuration
|jdk14 |JDK 1.4 logging API (only supported on JVMs of version 1.4 or higher). Configuration is done through a file logging.properties in the jre/lib directory.
|simple |Selects the simple JDK 1.1 compatible console-based logger provided by Jakarta Commons Logging
|csf |Selects CSF-based logging (CSF embeddor must be available)
|jakarta |Uses the default log system selection algorithm of the Jakarta Commons Logging framework
|dotnet a|
Selects a .net logging implementation

Since a dotnet logger is not currently implemented, this is currently identical to simple. Simple is a purely JDK1.1 console-based log implementation.

|avalon |Uses the Avalon Logkit implementation
|noop |Disables all logging
|===

=== ORB Portability

==== Introduction

Many ORBs currently in use support different versions of CORBA and/or the Java language mapping.

{parentProduct} only supports the new Portable Object Adapter (POA) architecture described in the CORBA 2.3 specification as a replacement for the Basic Object Adapter (BOA).
Unlike the BOA, which was weakly specified and led to a number of different (and often conflicting) implementations, the POA was deliberately designed to reduce the differences between ORB implementations, and thus minimise the amount of re-coding that would need to be done when porting applications from one ORB to another.
However, there is still scope for slight differences between ORB implementations, notably in the area of threading.
Note, instead of talking about the POA, this manual will consider the Object Adapter (OA).

Because {parentProduct} must be able to run on a number of different ORBs, we have developed an ORB portability interface which allows entire applications to be moved between ORBs with little or no modifications.
This portability interface is available to the application programmer in the form of several Java classes.

==== The ORB Portability API

==== Using the ORB

The ORB class provided in the package com.arjuna.orbportability.ORB shown below provides a uniform way of using the ORB.
There are methods for obtaining a reference to the ORB, and for placing the application into a mode where it listens for incoming connections.
There are also methods for registering application specific classes to be invoked before or after ORB initialisation.

[source,Java]
----
public class ORB {
    public static ORB getInstance(String uniqueId);
    // given the various parameters,this method initialises the ORB and
    // retains a reference to it within the ORB class.
    public synchronized void initORB () throws SystemException;
    public synchronized void initORB (Applet a, Properties p)
        throws SystemException;
    public synchronized void initORB (String[] s, Properties p)
        throws SystemException;

    //The orb method returns a reference to the ORB.
    //After shutdown is called this reference may be null.
    public synchronized org.omg.CORBA.ORB orb ();
    public synchronized boolean setOrb (org.omg.CORBA.ORB theORB);
    // If supported, this method cleanly shuts down the ORB.
    // Any pre- and post- ORB shutdown classes which
    //have been registered will also be called.
    public synchronized void shutdown ();

    public synchronized boolean addAttribute (Attribute p);
    public synchronized void addPreShutdown (PreShutdown c);
    public synchronized void addPostShutdown (PostShutdown c);

    public synchronized void destroy () throws SystemException;
    //these methods place the ORB into a listening mode,
    //where it waits for incoming invocations.
    public void run ();
    public void run (String name);
};
----

Note, some of the methods are not supported on all ORBs, and in this situation, a suitable exception will be thrown.
The ORB class is a factory class which has no public constructor.
To create an instance of an ORB you must call the `getInstance` method passing a unique name as a parameter.
If this unique name has not been passed in a previous call to `getInstance` you will be returned a new ORB instance.
Two invocations of `getInstance` made with the same unique name, within the same JVM, will return the same ORB instance.

==== Using the Object Adapater (OA)

The OA classes shown below provide a uniform way of using Object Adapters (OA).
There are methods for obtaining a reference to the OA.
There are also methods for registering application specific classes to be invoked before or after OA initialisation.
Note, some of the methods are not supported on all ORBs, and in this situation, a suitable exception will be thrown.
The OA class is an abstract class and provides the basic interface to an Object Adapter.
It has two sub-classes RootOA and ChildOA, these classes expose the interfaces specific to the root Object Adapter and a child Object Adapter respectively.
From the RootOA you can obtain a reference to the RootOA for a given ORB by using the static method getRootOA.
To create a ChildOA instance use the createPOA method on the RootOA.

As described below, the OA class and its sub-classes provide most operations provided by the POA as specified in the POA specification.

[source,Java]
----
public abstract class OA
{
    public synchronized static RootOA getRootOA(ORB associatedORB);
    public synchronized void initPOA () throws SystemException;
    public synchronized void initPOA (String[] args) throws SystemException;
    public synchronized void initOA () throws SystemException;
    public synchronized void initOA (String[] args) throws SystemException;
    public synchronized ChildOA createPOA (String adapterName,
        PolicyList policies) throws AdapterAlreadyExists, InvalidPolicy;
    public synchronized org.omg.PortableServer.POA rootPoa ();
    public synchronized boolean setPoa (org.omg.PortableServer.POA thePOA);
    public synchronized org.omg.PortableServer.POA poa (String adapterName);
    public synchronized boolean setPoa (String adapterName,
        org.omg.PortableServer.POA thePOA);
    ...
};

public class RootOA extends OA {
    public synchronized void destroy() throws SystemException;
    public org.omg.CORBA.Object corbaReference (Servant obj);
    public boolean objectIsReady (Servant obj, byte[] id);
    public boolean objectIsReady (Servant obj);
    public boolean shutdownObject (org.omg.CORBA.Object obj);
    public boolean shutdownObject (Servant obj);
};

public class ChildOA extends OA {
    public synchronized boolean setRootPoa (POA thePOA);
    public synchronized void destroy() throws SystemException;
    public org.omg.CORBA.Object corbaReference (Servant obj);
    public boolean objectIsReady (Servant obj, byte[] id)
        throws SystemException;
    public boolean objectIsReady (Servant obj) throws SystemException;
    public boolean shutdownObject (org.omg.CORBA.Object obj);
    public boolean shutdownObject (Servant obj);
};
----

==== Example

The following example illustrates how to use the ORB Portability API to create

[source,Java]
----
import com.arjuna.orbportability.ORB;
import com.arjuna.orbportability.OA;

public static void main(String[] args) {
    try {
        // Create an ORB instance
        ORB orb = ORB.getInstance("orb_test");
        OA oa = OA.getRootOA( orb );  // Get the root POA
        orb.initORB(args, null); // Initialize the ORB
        oa.initOA(args);  // Initialize the OA
        // Do Work
        oa.destroy(); // destroy the OA
        orb.shutdown();  // Shutdown the ORB
    } catch(Exception e) {

    }
};
----

==== Specifying the ORB to use

If using such a JDK (from its version 1.2.2) in conjunction with another ORB it is necessary to tell the JVM which ORB to use.
This happens by specifying the org.omg.CORBA.ORBClass and org.omg.CORBA.ORBSingletonClass properties.
If used, ORB Portability classes will ensure that these properties are automatically set when required, i.e., during ORB initialisation.

The ORB portability library attempts to detect which ORB is in use, it does this by looking for the ORB implementation class for each ORB it supports.
This means that if there are classes for more than one ORB in the classpath the wrong ORB can be detected.
Therefore it is best to only have one ORB in your classpath.
If it is necessary to have multiple ORBs in the classpath then the property com.arjuna.orbportability.orbImplementation must be set to the value specified in the table below.

[cols=",",]
|===
|_ORB_ |_Property Value_
|JacORB v2.0 |com.arjuna.orbportability.internal.orbspecific.jacorb.orb.implementations.jacorb_2_0
|===

For additional details on the features provided by the ORB Portability API refer to the documentation provided by the {parentProduct} distribution.

==== {parentProduct} Failure Recovery

The failure recovery subsystem of {parentProduct} will ensure that results of a transaction are applied consistently to all resources affected by the transaction, even if any of the application processes or the machine hosting them crash or lose network connectivity.
In the case of machine (system) crash or network failure, the recovery will not take place until the system or network are restored, but the original application does not need to be restarted recovery responsibility is delegated to the Recovery Manager process (see below).
Recovery after failure requires that information about the transaction and the resources involved survives the failure and is accessible afterward: this information is held in the ActionStore, which is part of the ObjectStore.
If the ObjectStore is destroyed or modified, recovery may not be possible.

Until the recovery procedures are complete, resources affected by a transaction that was in progress at the time of the failure may be inaccessible.
For database resources, this may be reported as tables or rows held by "in-doubt transactions".

==== The Recovery Manager

The Recovery Manager is a daemon process responsible for performing crash recovery.
Only one Recovery Manager runs per node.
The Object Store provides persistent data storage for transactions to log data.
During normal transaction processing each transaction will log persistent data needed for the commit phase to the Object Store.
On successfully committing a transaction this data is removed, however if the transaction fails then this data remains within the Object Store.

The Recovery Manager functions by:

* Periodically scanning the Object Store for transactions that may have failed.
Failed transactions are indicated by the presence of log data after a period of time that the transaction would have normally been expected to finish.
* Checking with the application process which originated the transaction whether the transaction is still in progress or not.
* Recovering the transaction by re-activating the transaction and then replaying phase two of the commit protocol.

To start the Recovery Manager issue the following command:

[source,shell]
----
java com.arjuna.ats.arjuna.recovery.RecoveryManager
----

If the -test flag is used with the Recovery Manager then it will display a "Ready" message when initialised, i.e.:

[source,shell]
----
java com.arjuna.ats.arjuna.recovery.RecoveryManager -test
----

On initialization the Recovery Manager first loads in configuration information via a properties file.
This configuration includes a number of recovery activators and recovery modules, which are then dynamically loaded.

Each recovery activator, which implements the com.arjuna.ats.arjuna.recovery.RecoveryActivator interface, is used to instantiate a recovery class related to the underlying communication protocol.
Indeed, since the version 3.0 of {parentProduct}, the Recovery Manager is not specifically tied to an Object Request Broker or ORB, which is to specify a recovery instance able to manage the OTS recovery protocol the new interface RecoveryActivator is provided to identify specific transaction protocol.
For instance, when used with OTS, the RecoveryActivitor has the responsibility to create a RecoveryCoordinator object able to respond to the replay_completion operation.

All RecoveryActivator instances inherit the same interface.
They are loaded via the following recovery extension property:

[source,xml]
----
<property
    name="com.arjuna.ats.arjuna.recovery.recoveryActivator_<number>"
    value="RecoveryClass"/>
----

For instance the RecoveryActivator provided in the distribution of JTS/OTS, which shall not be commented, is as follows:

[source,xml]
----
<property
    name="com.arjuna.ats.arjuna.recovery.recoveryActivator_1"
    value="com.arjuna.ats.internal.jts.
        orbspecific.recovery.RecoveryEnablement"/>
----

Each recovery module, which implements the `com.arjuna.ats.arjuna.recovery.RecoveryModule` interface, is used to recover a different type of transaction/resource, however each recovery module inherits the same basic behaviour.

Recovery consists of two separate passes/phases separated by two timeout periods.
The first pass examines the object store for potentially failed transactions; the second pass performs crash recovery on failed transactions.
The timeout between the first and second pass is known as the backoff period.
The timeout between the end of the second pass and the start of the first pass is the recovery period.
The recovery period is larger than the backoff period.

The Recovery Manager invokes the first pass upon each recovery module, applies the backoff period timeout, invokes the second pass upon each recovery module and finally applies the recovery period timeout before restarting the first pass again.

The recovery modules are loaded via the following recovery extension property:

[source,xml]
----
com.arjuna.ats.arjuna.recovery.recoveryExtension<number>=<RecoveryClass>
----

The default RecoveryExtension settings are:

[source,xml]
----
<property name="com.arjuna.ats.arjuna.recovery.recoveryExtension1"
    value="com.arjuna.ats.internal.
        arjuna.recovery.AtomicActionRecoveryModule"/>
<property name="com.arjuna.ats.arjuna.recovery.recoveryExtension2"
    value="com.arjuna.ats.internal.
        txoj.recovery.TORecoveryModule"/>
<property name="com.arjuna.ats.arjuna.recovery.recoveryExtension3"
    value="com.arjuna.ats.internal.
        jts.recovery.transactions.TopLevelTransactionRecoveryModule"/>
<property name="com.arjuna.ats.arjuna.recovery.recoveryExtension4"
    value="com.arjuna.ats.internal.
        jts.recovery.transactions.ServerTransactionRecoveryModule"/>
----

==== Configuring the Recovery Manager

==== Periodic Recovery

The backoff period and recovery period are set using the following properties:

[source,xml]
----
<!-- (default 10 secs) -->
com.arjuna.ats.arjuna.recovery.recoveryBackoffPeriod
<!-- (default 120 secs) -->
com.arjuna.ats.arjuna.recovery.periodicRecovery
----

==== Expired entry removal

The operation of the recovery subsystem will cause some entries to be made in the ObjectStore that will not be removed in normal progress.
The RecoveryManager has a facility for scanning for these and removing items that are very old.
Scans and removals are performed by implementations of the com.arjuna.ats.arjuna.recovery.ExpiryScanner.
Implementations of this interface are loaded by giving the class name as the value of a property whose name begins with ExperyScanner.

The RecoveryManager calls the scan() method on each loaded ExpiryScanner implementation at an interval determined by the property com.arjuna.ats.arjuna.recovery.expiryScanInterval.
This value is given in hours default is 12.
An EXPIRY_SCAN_INTERVAL value of zero will suppress any expiry scanning.
If the value as supplied is positive, the first scan is performed when RecoveryManager starts; if the value is negative, the first scan is delayed until after the first interval (using the absolute value)

The default ExpiryScanner is:

[source,Java]
----
<property
    name="com.arjuna.ats.arjuna.recovery.
        expiryScannerTransactionStatusManager"
    value="com.arjuna.ats.internal.arjuna.recovery.
        ExpiredTransactionStatusManagerScanner"/>
----

The following table summarize properties used by the Recovery Manager.
These properties are defined by default the properties file named RecoveryManager-properties.xml.

[cols=",,,",]
|===
|_Name_ |_Description_ |_Possible Value_ |_Default Value_
|com.arjuna.ats.arjuna.recovery.periodicRecoveryPeriod |Interval in seconds between initiating the periodic recovery modules |Value in seconds |120
|com.arjuna.ats.arjuna.recovery.recoveryBackoffPeriod |Interval in seconds between first and second pass of periodic recovery |Value in seconds |10
|com.arjuna.ats.arjuna.recovery.recoveryExtensionX |Indicates a periodic recovery module to use. X is the occurence number of the recovery module among a set of recovery modules. These modules are invoked in sort-order of names |The class name of the periodic recovery module |{parentProduct} provides a set classes given in the RecoveryManager-properties.xml file
|com.arjuna.ats.arjuna.recovery.recoveryActivator_X |Indicates a recovery activator to use. X is the occurence number of the recovery activator among a set of recovery activators. |The class name of the periodic recovery activator |{parentProduct} provide one class that manages the recovery protocol specified by the OTS specification
|com.arjuna.ats.arjuna.recovery.expiryScannerXXX |Expiry scanners to use (order of invocation is random). Names must begin with "com.arjuna.ats.arjuna.recovery.expiryScanner" |Class name |{parentProduct} provides one class given in the RecoveryManager-properties.xml file
|com.arjuna.ats.arjuna.recovery.expiryScanInterval |Interval, in hours, between running the expiry scanners. This can be quite long. The absolute value determines the interval - if the value is negative, the scan will NOT be run until after one interval has elapsed. If positive the first scan will be immediately after startup. Zero will prevent any scanning. |Value in hours |12
|com.arjuna.ats.arjuna.recovery.transactionStatusManagerExpiryTime |Age, in hours, for removal of transaction status manager item. This should be longer than any ts-using process will remain running. Zero = Never removed. |Value in Hours |12
|com.arjuna.ats.arjuna.recovery.transactionStatusManagerPort |Use this to fix the port on which the TransactionStatusManager listens |Port number (short) |use a free port
|===

=== Installation Content

==== Verifying Installation

When installed, the binary release of {parentProduct}, JTS version, should have the following structure.

* /bin: this directory contains commands to run the OTS transaction manager server (if required) and the Recovery Manager, and scripts to configure environment variables needed to execute {parentProduct}.
* /docs: this directory contains documentation on the way to installing, administering and programming ArjunaCore, {parentProduct} JTA and {parentProduct} JTS.
* /etc: this directory contains appropriate properties files that can be used to configure the behaviour of the {parentProduct}.
* /htdocs: this directory describes all APIs defined by {parentProduct}
* /idl: this directory contains the CORBA idl files that may be registered with your interface repository prior to running any applications.
* /jacorb: This directory contains the jacorb distribution.
* /lib: this directory contains the jar files that contains packages defined by the {parentProduct}.
These jar files shall be added in the `CLASSPATH`
* /services: this directory contains the appropriates scripts, jar and configuration files allowing to start and stop standalone Transaction Service and Recovery Manager
* /trail_map: contains examples applications

==== Testing your installation

To ensure that your {parentProduct} installation is fully operational, we will run the simple demo.

Please follow these steps before running the transactional applications

* Ensure you have the Ant build system installed.
Ant is a Java build tool, similar to make.
It is available for free from http://ant.apache.org/ The sample application requires version 1.5.1 or later.
* The `PATH` and `CLASSPATH` environment variables need to be set appropriately to use {parentProduct}.
To make this easier, we provide a shell script `setup_env.sh` (and for Windows a batch file `setup_env.bat`) in the directory `<jbossts_install_root>/bin/`
* From a command prompt, cd to the directory containing the `build.xml` file (`<jbossts_install_root>/trail_map`) and type 'ant'.
This will compile a set of sources files located under `<jbossts_install_root>/trail_map/src` then create an application .jar file named `jbossts-demo.jar` under the directory `<jbossts_install_root>/trail_map/lib`
* Add the generated jar file to the `CLASSPATH` environment variable.
* Ensure that the jacorb is added in your `CLASSPATH`.
Use only the patched version that ships with {parentProduct}.
+
_Ensure that {parentProduct} jar files appear before jacorb jar files._

* Start the server `src/com/arjuna/demo/simple/HelloServer.java` (HelloServer.java).
+
[NOTE]
====
The source code for the trailmap is fully documented and can often contain very useful tips and information that may not be reflected elsewhere in the trailmap
====
+
[source,shell]
----
java com.arjuna.demo.simple.HelloServer
----

* Open another command prompt, go to the same `/trail_map` directory and start the client `src/com/arjuna/demo/simple/HelloClient.java` (HelloClient.java). Be sure that the environment variable `CLASSPATH` is set with the same value as explained above.

[source,shell]
----
java com.arjuna.demo.simple.HelloClient
----

In the client window you should see the following lines:

[source,shell]
----
Creating a transaction !
Call the Hello Server !
Commit transaction
Done
----

In the server, which must be stopped by hand, you should see:

[source,shell]
----
Hello - called within a scope of a transaction
----

==== Setting properties

{parentProduct} has been designed to be highly configurable at runtime through the use of various property attributes.
Although these attributes can be provided at runtime on the command line, it is possible (and may be more convenient) to specify them through the properties file `jbossts-properties.xml` located under the `/etc` directory of the {parentProduct} distribution.

More details on the way to configure the behavior of {parentProduct} can be found in the section on configuration.

=== Specifying the ORB to use

JDK releases from 1.2.2 onwards include a minimum ORB implementation from Sun.
If using such a JDK in conjunction with another ORB it is necessary to tell the JVM which ORB to use.
This happens by specifying the _org.omg.CORBA.ORBClass_ and _org.omg.CORBA.ORBSingletonClass_ properties.
In earlier versions of the {parentProduct} it was necessary to specify these properties explicitly, either on the command line of in the properties file.
However, it is no longer a requirement to do this, as the ORB Portability classes will ensure that these properties are automatically set when required.
Of course it is still possible to specify these values explicitly (and necessary if not using the ORB initialization methods)

=== Overview of the Distributed Transaction Processing

Transaction management is one of the most crucial requirements for enterprise application development.
Most of the large enterprise applications in the domains of finance, banking and electronic commerce rely on transaction processing for delivering their business functionality.

Enterprise applications often require concurrent access to distributed data shared amongst multiple components, to perform operations on data.
Such applications should maintain integrity of data (as defined by the business rules of the application) under the following circumstances:

* distributed access to a single resource of data, and
* access to distributed resources from a single application component.

In such cases, it may be required that a group of operations on (distributed) resources be treated as one unit of work.
In a unit of work, all the participating operations should either succeed or fail and recover together.
This problem is more complicated when

* a unit of work is implemented across a group of distributed components operating on data from multiple resources, and/or
* the participating operations are executed sequentially or in parallel threads requiring coordination and/or synchronization.

In either case, it is required that success or failure of a unit of work be maintained by the application.
In case of a failure, all the resources should bring back the state of the data to the previous state ( _i.e.,_ the state prior to the commencement of the unit of work).

From the programmer's perspective a transaction is a scoping mechanism for a collection of actions which must complete as a unit.
It provides a simplified model for exception handling since only two outcomes are possible:

* success - meaning that all actions involved within a transaction are completed
* failure - no actions complete

=== Example

To illustrate the reliability expected by the application, let’s consider the fund transfer example which is familiar to all of us.

The Money transfer involves two operations: Deposit and Withdrawal

The complexity of implementation doesn't matter; money moves from one place to another.
For instance, involved accounts may be either located in the same relational table within a database or located on different databases.

A Simple transfer consists on moving money from savings to checking while a Complex transfer can be performed at the end-of-day according to a reconciliation between international banks

image::../images/jts-example_transfer.PNG.png[align="center"]

==== What is a Transaction?

The concept of a transaction, and a transaction manager (or a transaction processing service) simplifies construction of such enterprise level distributed applications while maintaining integrity of data in a unit of work.

A transaction is a unit of work that has the following properties:

* _Atomicity_: either the whole transaction completes or nothing completes - partial completion is not permitted.
* _Consistency_: a transaction transforms the system from one consistent state to another.
In other words, On completion of a successful transaction, the data should be in a consistent state.
For example, in the case of relational databases, a consistent transaction should preserve all the integrity constraints defined on the data.
* _Isolation_: Each transaction should appear to execute independently of other transactions that may be executing concurrently in the same environment.
The effect of executing a set of transactions serially should be the same as that of running them concurrently.
This requires two things:
** During the course of a transaction, intermediate (possibly inconsistent) state of the data should not be exposed to all other transactions.
** Two concurrent transactions should not be able to operate on the same data.
Database management systems usually implement this feature using locking.
* _Durability_: The effects of a completed transaction should always be persistent.

These properties, called as _ACID_ properties, guarantee that a transaction is never incomplete, the data is never inconsistent, concurrent transactions are independent, and the effects of a transaction are persistent.

==== Transactional Concepts

===== Transaction Components

A collection of actions is said to be transactional if they possess the ACID properties.
These properties are assumed to be ensured, in the presence of failures; if actions involved within the transaction are performed by a Transactional System.
A transaction system includes a set of components where each of them has a particular role.
Main components are described below.

image::../images/jts-transaction_components.PNG.png[align="center"]

===== Application Programs

Application Programs are clients for the transactional resources.
These are the programs with which the application developer implements business transactions.
With the help of the transaction manager, these components create global transactions and operate on the transactional resources with in the scope of these transactions.
These components are not responsible for implementing mechanisms for preserving ACID properties of transactions.
However, as part of the application logic, these components generally make a decision whether to commit or rollback transactions.

Application responsibilities could be summarised as follows:

* Create and demarcate transactions
* Operate on data via resource managers

===== Resource Managers

A resource manager is, in general, a component that manages persistent and stable data storage system, and participates in the two phase commit and recovery protocols with the transaction manager.

A resource manager is typically a driver that provides two sets of interfaces: one set for the application components to get connections and operating, and the other set for participating in two phase commit and recovery protocols coordinated by a transaction manager.
This component may also, directly or indirectly, register resources with the transaction manager so that the transaction manager can keep track of all the resources participating in a transaction.
This process is called as resource enlistment.

Resource Manager responsibilities could be summarised as follows

* Enlist resources with the transaction manager
* Participate in two-phase commit and recovery protocol

===== Transaction Manager

The transaction manager is the core component of a transaction processing environment.
Its main responsibilities are to create transactions when requested by application components, allow resource enlistment and delistment, and to manage the two-phase commit or recovery protocol with the resource managers.

A typical transactional application begins a transaction by issuing a request to a transaction manager to initiate a transaction.
In response, the transaction manager starts a transaction and associates it with the calling thread.
The transaction manager also establishes a transaction context.
All application components and/or threads participating in the transaction share the transaction context.
The thread that initially issued the request for beginning the transaction, or, if the transaction manager allows, any other thread may eventually terminate the transaction by issuing a commit or rollback request.

Before a transaction is terminated, any number of components and/or threads may perform transactional operations on any number of transactional resources known to the transaction manager.
If allowed by the transaction manager, a transaction may be suspended or resumed before finally completing the transaction.

Once the application issues the commit request, the transaction manager prepares all the resources for a commit operation, and based on whether all resources are ready for a commit or not, issues a commit or rollback request to all the resources.

Resource Manager responsibilities could be summarised as follows:

* Establish and maintain transaction context
* Maintain association between a transaction and the participating resources.
* Initiate and conduct two-phase commit and recovery protocol with the resource managers.
* Make synchronization calls to the application components before beginning and after end of the two-phase commit and recovery process

===== Local vs. Distributed Transaction

A transaction that involves only one transactional resource, such a database, is considered as _local transaction_ , while a transaction that involves more than one transactional resource that need to be coordinated to reach a consistent state is considered as a _distributed transaction._

A transaction can be specified by what is known as transaction demarcation.
Transaction demarcation enables work done by distributed components to be bound by a global transaction.
It is a way of marking groups of operations to constitute a transaction.

The most common approach to demarcation is to mark the thread executing the operations for transaction processing.
This is called as programmatic demarcation.
The transaction so established can be suspended by unmarking the thread, and be resumed later by explicitly propagating the transaction context from the point of suspension to the point of resumption.

The transaction demarcation ends after a commit or a rollback request to the transaction manager.
The commit request directs all the participating resources managers to record the effects of the operations of the transaction permanently.
The rollback request makes the resource managers undo the effects of all operations on the transaction.

===== Transaction Context and Propagation

Since multiple application components and resources participate in a transaction, it is necessary for the transaction manager to establish and maintain the state of the transaction as it occurs.
This is usually done in the form of transaction context.

Transaction context is an association between the transactional operations on the resources, and the components invoking the operations.
During the course of a transaction, all the threads participating in the transaction share the transaction context.
Thus the transaction context logically envelops all the operations performed on transactional resources during a transaction.
The transaction context is usually maintained transparently by the underlying transaction manager.

===== Resource Enlistment

Resource enlistment is the process by which resource managers inform the transaction manager of their participation in a transaction.
This process enables the transaction manager to keep track of all the resources participating in a transaction.
The transaction manager uses this information to coordinate transactional work performed by the resource managers and to drive two-phase and recovery protocol.
At the end of a transaction (after a commit or rollback) the transaction manager delists the resources.

===== Two-Phase Commit

This protocol between the transaction manager and all the resources enlisted for a transaction ensures that either all the resource managers commit the transaction or they all abort.
In this protocol, when the application requests for committing the transaction, the transaction manager issues a prepare request to all the resource managers involved.
Each of these resources may in turn send a reply indicating whether it is ready for commit or not.
Only The transaction manager issue a commit request to all the resource managers, only when all the resource managers are ready for a commit.
Otherwise, the transaction manager issues a rollback request and the transaction will be rolled back.

===== Recovery and Logging

Basically, the Recovery is the mechanism which preserves the transaction atomicity in presence of failures.
The basic technique for implementing transactions in presence of failures is based on the use of logs.
That is, a transaction system has to record enough information to ensure that it can be able to return to a previous state in case of failure or to ensure that changes committed by a transaction are properly stored.

In addition to be able to store appropriate information, all participants within a distributed transaction must log similar information which allow them to take a same decision either to set data in their final state or in their initial state.

Two techniques are in general used to ensure transaction's atomicity.
A first technique focuses on manipulated data, such the Do/Undo/Redo protocol (considered as a recovery mechanism in a centralized system), which allow a participant to set its data in their final values or to retrieve them in their initial values.
A second technique relies on a distributed protocol named the two phases commit, ensuring that all participants involved within a distributed transaction set their data either in their final values or in their initial values.
In other words all participants must commit or all must rollback.

image::../images/jts-recovery_logs.PNG.png[align="center"]

In addition to failures we refer as centralized such system crashes, communication failures due for instance to network outages or message loss have to be considered during the recovery process of a distributed transaction.

In order to provide an efficient and optimized mechanism to deal with failure, modern transactional systems typically adopt a “presume abort” strategy, which simplifies the transaction management.

The presumed abort strategy can be stated as «when in doubt, abort».
With this strategy, when the recovery mechanism has no information about the transaction, it presumes that the transaction has been aborted.

A particularity of the presumed-abort assumption allows a coordinator to not log anything before the commit decision and the participants do not to log anything before they prepare.
Then, any failure which occurs before the 2PC starts leads to abort the transaction.
Furthermore, from a coordinator's point of view, any communication failure detected by a timeout or exception raised on sending prepare is considered as a negative vote which leads to abort the transaction.
So, within a distributed transaction, a coordinator or a participant may fail in two ways: either it crashes or it times out for a message it was expecting.
When a coordinator or a participant crashes and then restarts, it uses information on stable storage to determine the way to perform the recovery.
As we will see it the presumed-abort strategy enable an optimized behavior for the recovery.

===== Heuristic Decision

In extremely rare cases, a resource manager may choose not to wait for the outcome from the transaction manager.
This might occur if the communications path was lost and was not likely to be restored for a very long time.
Typically, this happens as a result of human intervention and not as an arbitrary action of a resource manager.
In order to release locks and make this transaction data available to new transactions, the resource manager makes a heuristic decision, i.e. it guesses the proper transaction outcome.
When it does so, it must remember its guess until contact with the transaction manager is ultimately re-established.

===== Standards

Saying that a distributed transaction can involve several distributed participants, means that these participant must be integrated within a global transaction manager which has the responsibility to ensure that all participants take a common decision to commit or rollback the distributed transaction.
The key of such integration is the existence of a common transactional interface which is understood by all participants, transaction manager and resource managers such databases.

The importance of common interfaces between participants, as well as the complexity of their implementation, becomes obvious in an open systems environment.
For this aim, various distributed transaction processing standards have been developed by international standards organizations.
Among these organizations, We list three of them which are mainly considered in the {parentProduct} product:

* The X/Open model and its successful XA interface
* The OMG with its CORBA infrastructure and the Object Transaction Service and finally
* The Java Community Process led by Sun with its JTA/JTS specification

Basically these standards have proposed logical models, which divide transaction processing into several functions:

* those assigned to the application which ties resources together in application-specific operations
* those assigned to the Resource manager which access physically to data stores
* functions performed by the Transaction Manager which manages transactions, and finally
* Communication Resource Managers which allow exchanging information with other transactional domains.

image::../images/jts-standards.PNG.png[align="center"]

=== {parentProduct} Overview

{parentProduct} assures complete, accurate business transactions for any Java based applications, including those written for the Jakarta EE and EJB frameworks.

{parentProduct} is a 100% Java implementation of a distributed transaction management system based on the Jakarta EE Java Transaction Service (JTS) standard.
Our implementation of the JTS utilizes the Object Management Group's (OMG) Object Transaction Service (OTS) model for transaction interoperability as recommended in the Jakarta EE and EJB standards.
Although any JTS-compliant product will allow Java objects to participate in transactions, one of the key features of {parentProduct} is it's 100% Java implementation.
This allows {parentProduct} to support fully distributed transactions that can be coordinated by distributed parties.

{parentProduct} runs can be run both as an embedded distributed service of an application server (e.g. {appServer}), affording the user all the added benefits of the application server environment such as real-time load balancing, unlimited linear scalability and unmatched fault tolerance that allows you to deliver an always-on solution to your customers.
It is also available as a free-standing Java Transaction Service.

In addition to providing full compliance with the latest version of the JTS specification, {parentProduct} leads the market in providing many advanced features such as fully distributed transactions and ORB portability with POA support.

{parentProduct} works on a number of operating systems including Red Hat linux, Sun Solaris and Microsoft Windows XP.
It requires a Java 5 or later environment.

The Java Transaction API support for {parentProduct} comes in two flavours:

* a purely local implementation that does not require an ORB, but obviously requires all coordinated resources to reside within the same JVM.
* a fully distributed implementation.

==== Key features

* fully compliant with the Jakarta Transactions 2.0 specification:
** Purely local (ORB-less) JTA offers the fastest JTA performance
** JDBC 3 support
** XA compliance
** JDBC drivers for database access with full transaction support
** Automatic crash recovery for XAResources
* compliance with the JTS specification and OTS 1.2 specification from the OMG
** Distributed JTA implementation
** support for distributed transactions (utilizing two-phase commit)
** POA ORB support
** interposition
** transaction heuristics
** distributed transaction manager (co-located with the transaction initiator) or transaction manager server
** checked/unchecked transaction behaviour
** supports both flat and nested transaction models, with nested-aware resources and resource adapters
** independent concurrency control system with support for type-specific concurrency control
** support for CosTransaction::Current
** direct and indirect transaction management
** synchronization interface
** explicit and implicit transaction context propagation
** automatic crash recovery
** multi-thread aware
* transactional objects (TO) for Java
* ORB independence via the ORB portability layer

=== The Sample Application

==== The Banking Application

The sample application consists of a banking application that involves a bank able to manage accounts on behalf of clients.
Clients can obtain information on accounts and perform operations such credit, withdraw and transfer money from one account to an other.

.The Banking Applications
image::../images/jts-banking_application_1.PNG.png[align="center"]

The client application:

* Initializes the banking object.
* Choose an operation to be performed on the banking object.
Possible operations are:
** Create Account: this operation asks the bank to create a new account credit it with the first amount provided in the request.
The creation consists:
*** to create an Account Object, then
** Get Balance: this operation invokes the bank to obtain the balance of an account.
*** the account is first returned by the bank, then
*** the account is asked to return its balance
** Withdraw: this operation is invoked to withdraw money from an account.
If the final balance is negative, the withdraw is refused and the associated transaction aborted
** Credit: this operation is performed to credit an account
** Transfer: This operation is used to transfer money from an account to another.
If the transfer leads to get a negative balance of the debited account, the transfer is refused and the associated transaction is aborted.
** Exit: This operation terminates the client
* Waits for a response.

The Bank Object

* Creates Account Objects using name
* Maintains the list of created Accounts
* Returns, when asked, the Account Object requested by the client.
If the Account doesn't exist an exception is returned to the client.

An Account Object

* Performs operations requested by the client
** credit,
** withdraw (debit), and
** return the current balance.

Each operation provided to the client leads to the creation of a transaction; therefore in order to commit or rollback changes made on an account, a resource is associated with the account to participate to the transaction commitment protocol.
According to the final transaction decision, the resource is able to set the Account either to its initial state (in case of rollback) or to the final state (in case of commit).
From the transactional view, Figure 2 depicts of transactional components.

.The Banking Application and the transactional Component
image::../images/jts-banking_application_2.PNG.png[align="center"]

==== Deploying and Testing The Banking Application

Assuming that the {parentProduct} product has been installed, this trail provides a set of examples that show how to build transactional applications.
Two types of transactional applications are presented, those using the JTA interface and those accessing to the JTS (OTS) interfaces.

Please follow these steps before running the transactional applications

* Ensure you have the Ant build system installed.
Ant is a Java build tool, similar to make.
It is available for free from http://ant.apache.org/ The sample application requires version 1.5.1 or later.
* The `PATH` and `CLASSPATH` environment variables need to be set appropriately to use {parentProduct}.
To make this easier, we provide a shell script `setup_env.sh` (and for Windows a batch file `setup_env.bat`) in the directory `<jbossts_install_root>/bin/`
* From a command prompt, cd to the directory containing the `build.xml` file (`<jbossts_install_root>/trail_map`) and type 'ant', unless already done in the installation section.
This will compile a set of sources files located under `<jbossts_install_root>/trail_map/src` then create an application .jar file named `jbossts-demo.jar` under the directory `<jbossts_install_root>/trail_map/lib`
* Add the generated jar file to the `CLASSPATH` environment variable.
* The demo application is provided in several ways, accessing persistent data or not.
When JDBC is used as a mean to access a database, Oracle 9i is used.
For this aim the appropriate Oracle libraries (`classes12.zip`) should be added in the `CLASSPATH` environment variable.

===== Local transaction with JTA

To configure {parentProduct} for such transaction, edit the `jbossts-properties.xml` file and set the following properties to the appropriate values:

[source,xml]
----
<property
    name="com.arjuna.ats.jta.jtaTMImplementation"
    value="com.arjuna.ats.internal.jta.transaction.
    arjunacore.TransactionManagerImple"/>
<property
    name="com.arjuna.ats.jta.jtaUTImplementation"
    value="com.arjuna.ats.internal.jta.transaction.
    arjunacore.UserTransactionImple"/>
----

===== Distributed transaction with JTA

While for a distributed transactions case, {parentProduct} need to be configured as follows:

[source,xml]
----
<property
    name="com.arjuna.ats.jta.jtaTMImplementation"
    value="com.arjuna.ats.internal.jta.transaction.
    jts.TransactionManagerImple"/>
<property
    name="com.arjuna.ats.jta.jtaUTImplementation"
    value="com.arjuna.ats.internal.jta.transaction.
    jts.UserTransactionImple"/>
----

Using JTA to create a distributed transaction need the creation of an ORB instance as done by a JTS application (see JTS versions of the banking application), the difference is in the interface used to demarcate and control transactions.

===== The application programming interfaces used by the Banking Application

To illustrate the programming interfaces possibilities enabled by {parentProduct}, the banking application is provided in several versions: a version that uses the JTA API and a second that uses JTS/OTS interfaces.

This trail focuses to understanding concepts related to the creation of transactions and the behavior of the commitment protocol, while the next trail illustrates the similar application with persistent data.

* Testing the Banking application with JTA
* Testing the Banking application with JTS

====== Running The Banking application with JTA

*Configuring {parentProduct}*

Program Applications that create transactions using te JTA interface may invoke as well local services as remote services.
When a remote invocation need to be performed, the current transactional context need to be propagated to the remote service in order to involve it to the transaction in progress.{parentProduct} allows the possibility to provide such feature using the facilities provided by JTS and ORB.
More precisely {parentProduct} need to be configured to determine in which type of transaction, local or distributed, the JTA interface is used.

*Executing the JTA sample*

The Banking sample using JTA creates local transactions, ensure that JTA is configured for local transactions as explained above.

To launch the JTA version of the Banking application, which creates only local transactions, execute the following java program:

[source,shell]
----
java com.arjuna.demo.jta.localbank.BankClient
----

Once one of the program given above is launched the following lines are displayed:

[source,shell]
----
-------------------------------------------------
  Bank client
-------------------------------------------------
Select an option :
   0. Quit
   1. Create a new account.
   2. Get an account information.
   3. Make a transfer.
   4. Credit an account.
   5. Withdraw from an account

Your choice :
----

After introducing your choice, the appropriate operation is performed by the Bank object, to get the requested account, and by the account to execute the credit or withdraw or to return the current balance.
Let's consider the following execution.

Enter the number 1 as your choice, then give the name "Foo" as the account name and "1000" as an initial value of the account to create.
You should get the following lines:

[source,shell]
----
Your choice : 1
- Create a new account -
------------------------
Name : Foo
Initial balance : 1000
Beginning a User transaction to create account
XA_START[]
Attempt to commit the account creation transaction
XA_END[]
XA_COMMIT (ONE_PHASE)[]
----

* The line XA_START indicates that the AccountResource object that implements the XAResource interface and enlisted to participate in the account creation transaction, receives the indication from the Transaction Manager that the transaction has started.
* The line XA_END indicates that the calling thread in which the AccountRessource object is associated shall be ended to enable the transaction completion as recommended by the X/Open specification.
* Since only one AccountResource then only one XAResource is involved in the account creation transaction, the two phases needed to get a consensus in the 2PC protocol are not mandatory.
The one phase commit optimization, indicated by the "XA_COMMIT (ONE_PHASE)", is applied.

In the same way create a second account with the name "Bar" and the initial balance set to 500.

As a choice now, enter "3" to make a transfer (300) from "Foo" to "Bar".

[source,shell]
----
Your choice : 3
- Make a transfer -
-------------------
Take money from : Foo
Put money to : Bar
Transfert amount : 300
Beginning a User transaction to get balance
XA_START[]
XA_START[]
XA_END[]
XA_PREPARE[]
XA_END[]
XA_PREPARE[]
XA_COMMIT[]
XA_COMMIT[]
----

* Now two AccountResource objects, then two XAResource objects are enlisted with the transaction.
The displayed lines show that the two phases, prepare and commit, are applied.

Any attempt to manipulate an account that it doesn't exist leads to throw the NotExistingAccount exception and to rollback the transaction in progress.
For instance, let's withdraw money from an account FooBar not previously created.

[source,shell]
----
Your choice : 5
- Withdraw from an Account -
----------------------------
Give the Account name : FooBar
Amount to withdraw : 200
Beginning a User transaction to
withdraw from an account
The requested account does not exist!
ERROR - jakarta.transaction.RollbackException
----

*Building The Banking Application with JTA*

From an architectural point of view of JTA, the bank client is considered as an application program able to manage transactions via the `jakarta.transaction.UserTransaction` interface.
The following portion of the code illustrates how a JTA transaction is started and terminated when the client asks to transfer money from one account to another.
This also describes what are {parentProduct} packages that need to be used in order to obtain appropriate objects instances (such UserTransaction).

[NOTE]
====
The code below is a simplified view of the BankClient.java program.
====

Only the transfer operation is illustrated; other operations manage transactions in the same way. (see for details the `src/com/arjuna/demo/jta/localbank/BankClient.java`)

[source,Java]
----
public class BankClient {
    private Bank _bank;

    // This operation is used to make a transfer
    //from an account to another account
    private void makeTransfer() {
        System.out.print("Take money from : ");
        String name_supplier = input();

        System.out.print("Put money to : ");
        String name_consumer = input();

        System.out.print("Transfer amount : ");
        String amount = input();

        float famount = 0;
        try {
            famount = new Float(amount).floatValue();
        } catch (java.lang.Exception ex) {
            System.out.println("Invalid float number, abort operation...");
            return;
        }

        try {
            //the following instruction asks a specific {parentProduct}
            //class to obtain a UserTransaction instance
            jakarta.transaction.UserTransaction userTran =
                    com.arjuna.ats.jta.UserTransaction.userTransaction();
            System.out.println("Beginning a User transaction to get balance");
            userTran.begin();

            Account supplier = _bank.get_account(name_supplier);
            Account consumer = _bank.get_account(name_consumer);
            supplier.debit(famount);
            consumer.credit(famount);

            userTran.commit();
        } catch (Exception e) {
            System.err.println("ERROR - " + e);
        }
    }
   ......
}
----

The Bank object has mainly two operations: creating an account, which is added in the account list, and returning an Account object.
No transactional instruction is performed by the Bank object

[source,Java]
----
public class Bank {
    private java.util.Hashtable _accounts;

    public Bank() {
        _accounts = new java.util.Hashtable();
    }

    public Account create_account(String name) {
        Account acc = new Account(name);
        _accounts.put(name, acc);
        return acc;
    }

    public Account get_account(String name)
            throws NotExistingAccount {
        Account acc = (Account) _accounts.get(name);
        if (acc == null)
            throw new NotExistingAccount("The Account requested does not exist");
        return acc;
    }
}
----

The Account object provides mainly three methods balance, credit and withdraw.
However, in order to provide the transactional behaviour, rather than to modify the current account directly (according to credit or withdraw) this task is delegated to an AccountResource object that is able, according to the transaction outcome, to set the account value either to its initial state or its final state.

The AccountResource object is in fact an object that implements the javax.transaction.xa.XAResource, then able to participate to the transaction commitment.
For this aim, the Account object has to register or enlist the AccountResource object as a participant after having obtaining the reference of the `jakarta.transaction.Transaction` object via the `jakarta.transaction.TransactionManager` object

[source,Java]
----
package com.arjuna.demo.jta.localbank;

public class Account {
    float _balance;
    AccountResource accRes = null;

    public Account(String name) {
        _name = name;
        _balance = 0;
    }

    public float balance() {
        return getXAResource().balance();
        ;
    }

    public void credit(float value) {
        getXAResource().credit(value);
    }

    public void debit(float value) {
        getXAResource().debit(value);
    }

    public AccountResource getXAResource() {

        try {
            jakarta.transaction.TransactionManager transactionManager =
                    com.arjuna.ats.jta.TransactionManager.transactionManager();
            jakarta.transaction.Transaction currentTrans =
                    transactionManager.getTransaction();

            if (accRes == null) {
                currentTrans.enlistResource(
                        accRes = new AccountResource(this, _name));
            }

            currentTrans.delistResource(accRes, XAResource.TMSUCCESS);

        } catch (Exception e) {
            System.err.println("ERROR - " + e);
        }
        return accRes;
    }
   ...
}
----

The AccountResource class that implements the javax.transaction.xa.XAResource interface provides similar methods as the Account class (credit, withdraw and balance) but also all methods specified by the javax.transaction.xa.XAResource.
The following portion of code describes how the methods prepare, commit and rollback are implemented.

[source,Java]
----
public class AccountResource implements XAResource {
    public AccountResource(Account account, String name) {
        _name = name;
        _account = account;
        _initial_balance = account._balance;
        _current_balance = _initial_balance;
    }

    public float balance() {
        return _current_balance;
    }

    public void credit(float value) {
        _current_balance += value;
    }

    public void debit(float value) {
        _current_balance -= value;
    }

    public void commit(Xid id, boolean onePhase) throws XAException {
        //The value of the associated Account object is modified
        _account._balance = _current_balance;
    }

    public int prepare(Xid xid) throws XAException {
        if (_initial_balance == _current_balance) //account not modified
            return (XA_RDONLY);
        if (_current_balance < 0)
            throw new XAException(XAException.XA_RBINTEGRITY);
        //If the integrity of the account is corrupted then vote rollback
        return (XA_OK); //return OK
    }
}
----

[source,Java]
----
public void rollback(Xid xid) throws XAException {
    //Nothing is done
}

----

[source,Java]
----
private float _initial_balance;
private float _current_balance;
private Account _account;
----

*Sample Application Source Code*

Full source code for the banking application with JTA is included to provide you with a starting point for experimentation.

* `src/com/arjuna/demo/jta/localbank/BankClient.java`
* `src/com/arjuna/demo/jta/localbank/Bank.java` -> `Bank.java`
* `src/com/arjuna/demo/jta/localbank/Account.java` -> `Account.java`
* `src/com/arjuna/demo/jta/localbank/AccountResource.java`
* `src/com/arjuna/demo/jta/localbank/NotExistingAccount.java` -> `NotExistingAccount.java`

===== Running The Banking application with JTS

The JTS version of the Banking application means that the Object Request Broker will be used.
The {parentProduct} distribution is provided to work with the bundled JacORB version

To describe the possibilities provided by {parentProduct} to build a transactional application according to the programming models defined by the OTS specification, the Banking Application is programmed in different ways.

* Local transactions: The Bank Client and the Bank server are collocated in the same process.
* Distributed Transactions: The Bank Client and the Bank Server and located on different process.
To participate within a client's transaction, Account Objects needed to access the transactional context.
We describe the two of context propagation.
** implicit context propagation, and
** explicit context propagation.

JTS Local Transactions>

JTS Distributed Transactions

====== Running The Banking application with JTS

The JTS version of the Banking application means that the Object Request Broker will be used.
The {parentProduct} distribution is provided to work with the bundled JacORB version

_Note_ : Ensure that the jacorb jar files are added in your `CLASSPATH`

To launch the JTS version of the Banking application, execute the following java program

[source,shell]
----
java com.arjuna.demo.jts.localbank.BankClient
----

Once one of the program given above is launched the following lines are displayed:

[source,shell]
----
-------------------------------------------------
   Bank client
-------------------------------------------------
Select an option :
   0. Quit
   1. Create a new account.
   2. Get an account information.
   3. Make a transfer.
   4. Credit an account.
   5. Withdraw from an account

Your choice :
----

After introducing your choice, the appropriate operation is performed by the Bank object, to get the requested account, and by the account to execute the credit or withdraw or to return the current balance.
Let's consider the following execution.

Enter the number 1 as your choice, then give the name "Foo" as the account name and "1000" as an initial value of the account to create.
You should get the following lines:

[source,shell]
----
Your choice : 1
- Create a new account -
------------------------
Name : Foo
Initial balance : 1000
Beginning a User transaction to create account
[ Connected to 192.168.0.2:4799 from local port 4924 ]
Attempt to commit the account creation transaction
/[ Resource for Foo : Commit one phase ]
----

* Since only one AccountResource then only one CosTransaction.Resource is involved in the account creation transaction, the two phases needed to get a consensus in the 2PC protocol are not mandatory.
The one phase commit optimisation, indicated by the "Commit one phase", is applied.

In the same way create a second account with the name "Bar" and the initial balance set to 500.

As a choice now, enter "3" to make a transfer (300) from "Foo" to "Bar".

[source,shell]
----
Your choice : 3
- Make a transfer -
-------------------

Take money from : Foo
Put money to : Bar
Transfer amount : 300
Beginning a User transaction to Transfer money
[ Resource for Foo : Prepare ]
[ Resource for Bar : Prepare ]
[ Resource for Foo : Commit ]
[ Resource for Bar : Commit ]
----

* Now two AccountResource objects, then two CosTransactions.Resource objects are enlisted with the transaction.
The displayed lines show that the two phases, prepare and commit, are applied.

Any attempt to manipulate an account that it doesn't exist leads to throw the NotExistingAccount exception and to rollback the transaction in progress.
For instance, let's withdraw money from an account FooBar not previously created.

[source,shell]
----
Your choice : 5
- Withdraw from an Account -
----------------------------
Give the Account name : FooBar
Amount to withdraw : 200
Beginning a User transaction to withdraw from an account
The requested account does not exist!
ERROR - org.omg.CORBA.TRANSACTION_ROLLEDBACK:
minor code: 50001  completed: No
----

*Using a stand-alone Transaction Server*

By default {parentProduct} does not use a separate transaction manager server: transaction managers are co-located with each application process to improve performance and improve application fault-tolerance.
When running applications which require a separate transaction manager, you must set the com.arjuna.ats.jts.transactionManager property variable, in the `(jbossts_install_dir)/etc/jbossts-properties.xml` file, to YES.

In a separate window, the stand-alone Transaction Server is launched as follows:

[source,shell]
----
java com.arjuna.ats.jts.TransactionServer [-test]
----

The option `-test` allows to see the message "Ready" when the Transaction Server is started.

The Banking application presented above gives the same output.

*Running The Banking application with JTS*

The JTS version of the Banking application means that the Object Request Broker will be used.
The {parentProduct} distribution is provided to work with the bundled JacORB version

_Note_ : Ensure that the jacorb jar files are added in your `CLASSPATH`

* In a separate window launch the Recovery Manager, as follows:
+
[source,shell]
----
java com.arjuna.ats.arjuna.recovery.RecoveryManager
----
* Testing the distributed transaction with _Implicit Propagation Context_
* Start the Server
+
[source,shell]
----
java com.arjuna.demo.jts.remotebank.BankServer
----
* In a separate window, start the client
+
[source,shell]
----
java com.arjuna.demo.jts.remotebank.BankClient
----
* Testing the distributed transaction with _Explicit Propagation Context_

* Start the Server
+
[source,shell]
----
java com.arjuna.demo.jts.explicitremotebank.BankServer
----
* In a separate window, start the client
+
[source,shell]
----
java com.arjuna.demo.jts.explicitremotebank.BankClient
----

In both cases (implicit and explicit), the Bank Server, which can be stopped by hand, displays the following lines:

[source,shell]
----
The bank server is now ready...
----

In both cases (implicit and Explicit), the Bank Client window displays the following lines:

[source,shell]
----
-------------------------------------------------
Bank client
-------------------------------------------------
Select an option :
0. Quit
1. Create a new account.
2. Get an account information.
3. Make a transfer.
4. Credit an account.
5. Withdraw from an account

Your choice :
----

After entering your choice, the appropriate operation is performed by the remote Bank object, to get the requested account, and by the account to execute the credit or withdraw or to return the current balance.
Let's consider the following execution.

Enter the number 1 as your choice, then give the name "Foo" as the account name and "1000" as an initial value of the account to create.
You should get in the server window a result that terminates with the following line

[source,shell]
----
[ Resource for Foo : Commit one phase ]
----

* Since only one AccountResource then only one CosTransaction.Resource is involved in the account creation transaction, the two phases needed to get a consensus in the 2PC protocol are not mandatory.
The one phase commit optimisation, indicated by the "Commit one phase", is applied.

In the same way create a second account with the name "Bar" and the initial balance set to 500.

As a choice now, enter in the client window "3" to make a transfer (300) from "Foo" to "Bar".

[source,shell]
----
Your choice : 3
- Make a transfer -
-------------------

Take money from : Foo
Put money to : Bar
Transfer amount : 300
----

In the Server window you should see a result with the following lines

[source,shell]
----
[ Resource for Foo : Prepare ]
[ Resource for Bar : Prepare ]
[ Resource for Foo : Commit ]
[ Resource for Bar : Commit ]
----

* Now two AccountResource objects, then two CosTransactions.Resource objects are enlisted with the transaction.
The displayed lines show that the two phases, prepare and commit, are applied.

Any attempt to manipulate an account that it doesn't exist leads to throw the NotExistingAccount exception and to rollback the transaction in progress.
For instance, let's withdraw money from an account FooBar not previously created.

[source,shell]
----
Your choice : 5
- Withdraw from an Account -
----------------------------
Amount to withdraw : 200
Beginning a User transaction to withdraw from an account
The requested account does not exist!
ERROR - org.omg.CORBA.TRANSACTION_ROLLEDBACK:
minor code: 50001 completed: No
----

*Using a stand-alone Transaction Server*

By default {parentProduct} does not use a separate transaction manager server: transaction managers are co-located with each application process to improve performance and improve application fault-tolerance.
When running applications which require a separate transaction manager, you must set the com.arjuna.ats.jts.transactionManager property variable, in the `jbossts-properties.xml` file, to YES.

In a separate window, the stand-alone Transaction Server is launched as follows:

[source,shell]
----
java com.arjuna.ats.jts.TransactionServer [-test]
----

The option `-test` allows to see the message "Ready" when the Transaction Server is started.

The Banking application presented above gives the same output.

*Running the example on several machines*

It is possible to run the {parentProduct} Transaction Service and recovery manager processes on a different machine and have clients access these centralized services in a hub-and-spoke style architecture.

All that must be done is to provide the clients with enough information to contact the transaction service (such as the ORB's NameService).
However, configuring the ORB is beyond the remit of this trailmap and so we shall opt for a simpler mechanism wherby the transaction services IOR is shared by access to a common file.

This trailmap stage assumes that the transaction service has been appropriately installed and configured (the setenv.[bat|sh] script has been ran) onto two hosts (for the purpose of explanation we shall refer to these hosts as host1 and host2).

* Start the transaction service and recovery manager on host1

** Start the recovery manager in one command prompt terminal
+
[source,shell]
----
java com.arjuna.ats.arjuna.recovery.RecoveryManager [-test]
----

** Start the transaction service in a second command prompt terminal
+
[source,shell]
----
java com.arjuna.ats.jts.TransactionServer [-test]
----

* Share the transaction service IOR on host1 with host2

Open a command prompt on host2 and copy the CosServices.cfg file from the `<narayana-jts_install_root>/etc` directory on host1.

For example, using the popular scp package, open a shell prompt and issue the following command:
+
[source,shell]
----
scp user_
@ __host1__:<ats_root>/etc/CosServices.cfg
<host2_ats_root>/etc/
----

* Start the Bank Server and Bank Client applications on host2
+
[NOTE]
====
See the section above entitled "Using a stand-alone Transaction Server" for more information on how to configure these application to use a remote transaction service.
====

** _ Testing the distributed transaction with __Implicit Propagation Context___

** Start the Server
+
[source,shell]
----
java com.arjuna.demo.jts.remotebank.BankServer
----

** In a separate window, start the client
+
[source,shell]
----
java com.arjuna.demo.jts.remotebank.BankClient
----

** _ Testing the distributed transaction with __Explicit Propagation Context___

** Start the Server
+
[source,shell]
----
java com.arjuna.demo.jts.explicitremotebank.BankServer
----

** In a separate window, start the client
+
[source,shell]
----
java com.arjuna.demo.jts.explicitremotebank.BankClient
----

====== How the Banking Application is build using JTS interfaces

From an architectural point of view of JTS, the bank client is considered as an application program able to manage transactions either in a direct or indirect management mode, respectively with the interfaces org.omg.CosTransactions.TransactionFactory and org.omg.CosTransactions.Terminator or with the org.omg.CosTransactions.Current interface.
Transactions created by the client in the Banking application are done in the indirect mode.

The following portion of code illustrates how a JTS transaction is started and terminated when the client asks to transfer money from one account to another.
This also describes what are {parentProduct} packages that need to be used in order to obtain appropriate objects instances (such Current).

[NOTE]
====
The code below is a simplified view of the BankClient.java program.
Only the transfer operation is illustrated; other operations manage transactions in the same way.
(see `../src/com/arjuna/demo/jts/localbank/BankClient.java` for details)
====

[source,java]
----
package com.arjuna.demo.jta.localbank;
import com.arjuna.ats.jts.OTSManager;
import com.arjuna.ats.internal.jts.ORBManager;

public class BankClient {
    private Bank _bank; //Initialised on BankClient initializations
   ....

    // This operation is used to make a transfer from an account to another account
    private void makeTransfer() {
        System.out.print("Take money from : ");
        String name_supplier = input();

        System.out.print("Put money to : ");
        String name_consumer = input();

        System.out.print("Transfert amount : ");
        String amount = input();

        float famount = 0;
        try {
            famount = new Float(amount).floatValue();
        } catch (java.lang.Exception ex) {
            System.out.println("Invalid float number, abort operation...");
            return;
        }

        try {
            //the following instruction asks a specific {parentProduct} class to obtain a Current instance
            Current current = OTSManager.get_current();
            System.out.println("Beginning a User transaction to get balance");
            current.begin();

            Account supplier = _bank.get_account(name_supplier);
            Account consumer = _bank.get_account(name_consumer);
            supplier.debit(famount);
            consumer.credit(famount);

            current.commit();
        } catch (Exception e) {
            System.err.println("ERROR - " + e);
        }
    }
}
----

Since JTS is used invocations against an ORB are needed, such ORB and Object Adapter instantiation and initialisation.
To ensure a better portability, the ORB Portability API provides a set of methods that can be used as described below.

[source,Java]
----
public static void main(String[] args) {
    try {
        myORB = ORB.getInstance("test");// Create an ORB instance
        myOA = OA.getRootOA(myORB); //Obtain the Root POA
        myORB.initORB(args, null); //Initialise the ORB
        myOA.initOA(); //Initialise the POA

        // The ORBManager is a class provided by {parentProduct} to facilitate the association
        // of the ORB/POA with the transaction service
        ORBManager.setORB(myORB);
        ORBManager.setPOA(myOA);
     ....
    } catch (Exception e) {
        e.printStackTrace(System.err);
    }
}
----

The Bank object has mainly two operations: creating an account, which is added in the account list, and returning an Account object.
No transactional instruction is performed by the Bank object

[source,Java]
----
package com.arjuna.demo.jta.localbank;

public class Bank {
    private java.util.Hashtable _accounts;

    public Bank()
    {
        _accounts = new java.util.Hashtable();
    }

    public Account create_account( String name )
    {
        Account acc = new Account(name);
        _accounts.put( name, acc );
        return acc;
    }

    public Account get_account(String name)
            throws NotExistingAccount
    {
        Account acc = ( Account ) _accounts.get( name );
        if ( acc == null )
            throw new NotExistingAccount("The Account requested does not exist");
        return acc;
    }
}
----

The Account object provides mainly three methods balance, credit and withdraw.
However, in order to provide the transactional behaviour, rather than to modify the current account directly (according to credit or withdraw) this task is delegated to an AccountResource object that is able, according to the transaction outcome, to set the account value either to its initial state or its final state.

The AccountResource object is in fact an object that implements the org.omg.CosTransactions.Resource, then able to participate to the transaction commitment.
For this aim, the Account object has to register the AccountResource object as a participant, after having obtaining the reference of the org.omg.CosTransactions.Coordinator object , itself obtained via the org.omg.CosTransactions.Control object

[source,Java]
----
package com.arjuna.demo.jta.localbank;

public class Account {
    float _balance;
    AccountResource accRes = null;

    public Account(String name) {
        _name = name;
        _balance = 0;
    }

    public float balance() {
        return getResource().balance();
    }

    public void credit(float value) {
        getResource().credit(value);
    }

    public void debit(float value) {
        getResource().debit(value);
    }

    public AccountResource getResource() {
        try {
            if (accRes == null) {
                accRes = new AccountResource(this, _name);
                Resource ref = org.omg.CosTransactions.ResourceHelper.narrow(ORBManager.getPOA().corbaReference(accRes));
                // Note above the possibilities provided by the ORBManager to access the POA then to obtain
                // the CORBA reference of the created AccountResource object

                RecoveryCoordinator recoverycoordinator = OTSManager.get_current().get_control().
                        get_coordinator().register_resource(ref);

            }
        } catch (Exception e) {
            System.err.println("ERROR - " + e);
        }

        return accRes;
    }
    ...
}
----

To be considered as a org.omg.CosTransactions.Resource, the AccountResource class shall extends the class org.omg.CosTransactions.ResourcePOA generated by the CORBA IDL compiler.
The AccountRessource provides similar methods as the Account class (credit, withdraw and balance) with the appropriate methods to participate to the 2PC protocol.
The following portion of code describes how the methods prepare, commit and rollback are implemented.

[source,Java]
----
public class AccountResource extends org.omg.CosTransactions.ResourcePOA {
    public AccountResource(Account account, String name) {
        _name = name;
        _account = account;
        _initial_balance = account._balance;
        _current_balance = _initial_balance;
    }

    public float balance() {
        return _current_balance;
    }

    public void credit(float value) {
        _current_balance += value;
    }

    public void debit(float value) {
        _current_balance -= value;
    }

    public org.omg.CosTransactions.Vote prepare()
            throws org.omg.CosTransactions.HeuristicMixed, org.omg.CosTransactions.HeuristicHazard {
        if (_initial_balance == _current_balance)
            return org.omg.CosTransactions.Vote.VoteReadOnly;
        if (_current_balance < 0)
            return org.omg.CosTransactions.Vote.VoteRollback;
        return org.omg.CosTransactions.Vote.VoteCommit;
    }

    public void rollback()
            throws org.omg.CosTransactions.HeuristicCommit, org.omg.CosTransactions.HeuristicMixed,
            org.omg.CosTransactions.HeuristicHazard {
        //Nothing to do
    }

    public void commit()
            throws org.omg.CosTransactions.NotPrepared, org.omg.CosTransactions.HeuristicRollback,
            org.omg.CosTransactions.HeuristicMixed, org.omg.CosTransactions.HeuristicHazard {
        _account._balance = _current_balance;
    }

    public void commit_one_phase()
            throws org.omg.CosTransactions.HeuristicHazard {
        _account._balance = _current_balance;
    }

    .....

    private float _initial_balance;
    private float _current_balance;
    private Account _account;
}
----

*Sample Application Source Code*

Full source code for the banking application is included to provide you with a starting point for experimentation.

* JTS Version
** src/com/arjuna/demo/jts/localbank/BankClient.java
** src/com/arjuna/demo/jts/localbank/Bank.java">Bank.java
** src/com/arjuna/demo/jts/localbank/Account.java">Account.java
** src/com/arjuna/demo/jts/localbank/AccountResource.java
** src/com/arjuna/demo/jts/localbank/NotExistingAccount.java">NotExistingAccount.java

*How the Banking Application is build using JTS interfaces*

The bank client is an application program able to manage transactions either in a direct or indirect management mode, respectively with the interfaces org.omg.CosTransactions.TransactionFactory and org.omg.CosTransactions.Terminator or with the org.omg.CosTransactions.Current interface.
Transactions created by the client in the Banking application are done in the indirect mode.

Invoking a remote object within a CORBA environment means that the remote object implements a CORBA interface defined in a CORBA idl file.
The following Bank.idl describes the interfaces then the possible kind of distributed CORBA objects involved in the banking application.
There is no any interface that inherits the CosTransactions::TransactionalObject interface, which means that for any remote invocations the transactional context is normally not propagated.
However, since the Account object may have to register Resource objects that participate to transaction completion, a context is needed.
In the following Bank.idl file operations defined in the Account interface have explicitly in their signature the CosTransactions::Control argument meaning that it passed explicitly by the caller - in this case the Bank Client program.

[source,Java]
----
module arjuna {
    module demo {
     module jts {
      module explicitremotebank {

        interface Account :
        {
          float balance(in CosTransactions::Control ctrl);
          void credit( in CosTransactions::Control ctrl, in float value );
          void debit( in CosTransactions::Control ctrl, in float value );
        };

        exception NotExistingAccount
        { };

        interface Bank
        {
          Account create_account( in string name );
          Account get_account( in string name )
            raises( NotExistingAccount );
        };
       };
      };
     };
};

----

The following portion of code illustrates how a JTS transaction is started and terminated when the client asks to transfer money from one account to another.
This also describes what are {parentProduct} packages that need to be used in order to obtain appropriate objects instances (such Current).

[NOTE]
====
The code below is a simplified view of the `BankClient.java` program.
Only the transfer operation is illustrated; other operations manage transactions in the same way.
(see for details the `src/com/arjuna/demo/jts/explicitremotebank/BankClient.java`)
====

[source,Java]
----
package com.arjuna.demo.jta.remotebank;
import com.arjuna.ats.jts.OTSManager;

public class BankClient {
    private Bank _bank;
    ....

    // This operation is used to make a transfer
    //from an account to another account
    private void makeTransfer() {
        //get the name of the supplier(name_supplier) and
        // the consumer(name_consumer)
        // get the amount to transfer (famount)
        ...
        try {
            //the following instruction asks a specific
            //{parentProduct} class to obtain a Current instance
            Current current = OTSManager.get_current();
            System.out.println("Beginning a User transaction to get balance");
            current.begin();

            Account supplier = _bank.get_account(name_supplier);
            Account consumer = _bank.get_account(name_consumer);
            supplier.debit(current.get_control(), famount);
            //The Control is explicitly propagated
            consumer.credit(current.get_control(), famount);
            current.commit();
        } catch (Exception e) {
            ...
        }
    }
}
----

Since JTS is used invocations against an ORB are needed, such ORB and Object Adapter instantiation and initialisation.
To ensure a better portability, the ORB Portability API provides a set of methods that can be used as described below.

[source,Java]
----
public static void main(String[] args) {
  ....
    myORB = ORB.getInstance("test");// Create an ORB instance
    myORB.initORB(args, null); //Initialise the ORB

    org.omg.CORBA.Object obj = null;
    try {
        //Read the reference string from a file then convert to Object
        ....
        obj = myORB.orb().string_to_object(stringTarget);
    } catch (java.io.IOException ex) {
        ...
    }
    Bank bank = BankHelper.narrow(obj);
    ....
}
----

The Bank object has mainly two operations: creating an account, which is added in the account list, and returning an Account object.
No transactional instruction is performed by the Bank object.
The following lines decribe the implementation of the Bank CORBA object

[source,Java]
----
public class BankImpl extends BankPOA {
    public BankImpl(OA oa) {
        _accounts = new java.util.Hashtable();
        _oa = oa;
    }

    public Account create_account(String name) {
        AccountImpl acc = new AccountImpl(name);
        _accounts.put(name, acc);
        return com.arjuna.demo.jts.remotebank.AccountHelper.
                narrow(_oa.corbaReference(acc));
    }

    public Account get_account(String name)
            throws NotExistingAccount {
        AccountImpl acc = (AccountImpl) _accounts.get(name);
        if (acc == null)
            throw new NotExistingAccount("The Account requested does not exist");
        return com.arjuna.demo.jts.remotebank.AccountHelper.
                narrow(_oa.corbaReference(acc));
    }

    private java.util.Hashtable _accounts;// Accounts created by the Bank
    private OA _oa;
}
----

After having defined an implementation of the Bank object, we should now create an instance and make it available for client requests.
This is the role of the Bank Server that has the responsibility to create the ORB and the Object Adapater instances, then the Bank CORBA object that has its object reference stored in a file well known by the bank client.
The following lines describe how the Bank server is implemented.

[source,Java]
----
public class BankServer {
    public static void main(String[] args) {
        ORB myORB = null;
        RootOA myOA = null;
        try {
            myORB = ORB.getInstance("ServerSide");
            myOA = OA.getRootOA(myORB);
            myORB.initORB(args, null);
            myOA.initOA();
            ....
            BankImpl bank = new BankImpl(myOA);

            String reference = myORB.orb().
                    object_to_string(myOA.corbaReference(bank));
            //Store the Object reference in the file
            ...

            System.out.println("The bank server is now ready...");
            myOA.run();
        }
    }
}
----

The Account object provides mainly three methods balance, credit and withdraw.
However, in order to provide the transactional behaviour, rather than to modify the current account directly (according to credit or withdraw) this task is delegated to an AccountResource object that is able, according to the transaction outcome, to set the account value either to its initial state or its final state.

The AccountResource object is in fact an object that implements the org.omg.CosTransactions.Resource, then able to participate to the transaction commitment.
For this aim, the Account object has to register the AccountResource object as a participant, after having obtaining the reference of the org.omg.CosTransactions.Coordinator object , itself obtained via the org.omg.CosTransactions.Control object

[source,Java]
----
package com.arjuna.demo.jta.remotebank;

import org.omg.CosTransactions.*;
import ....

public class AccountImpl extends AccountPOA {
    float _balance;
    AccountResource accRes = null;

    public Account(String name) {
        _name = name;
        _balance = 0;
    }

    public float balance(Control ctrl) {
        return getResource(ctrl).balance();
    }

    public void credit(Control ctrl, float value) {
        getResource(ctrl).credit(value);
    }

    public void debit(Control ctrl, float value) {
        getResource(ctrl).debit(value);
    }

    public AccountResource getResource(Control control) {
        try {
            if (accRes == null) {
                accRes = new AccountResource(this, _name);

                //The invocation on the ORB illustrates the fact that the same
                //ORB instance created by the Bank Server is returned.
                ref = org.omg.CosTransactions.ResourceHelper.
                        narrow(OA.getRootOA(ORB.getInstance("ServerSide")).
                                corbaReference(accRes));
                RecoveryCoordinator recoverycoordinator =
                        control.get_coordinator().register_resource(ref);
            }
        } catch (Exception e) {...}
        return accRes;
    }
    ...
}
----

To be considered as a org.omg.CosTransactions.Resource, the AccountResource class shall extends the class org.omg.CosTransactions.ResourcePOA generated by the CORBA IDL compiler.
The AccountRessource provides similar methods as the Account class (credit, withdraw and balance) with the appropriate methods to participate to the 2PC protocol.
The following portion of code describes how the methods prepare, commit and rollback are implemented.

[source,Java]
----
public class AccountResource extends org.omg.CosTransactions.ResourcePOA {
    public AccountResource(Account account, String name) {
        _name = name;
        _account = account;
        _initial_balance = account._balance;
        _current_balance = _initial_balance;
    }

    public float balance() {
        return _current_balance;
    }

    public void credit(float value) {
        _current_balance += value;
    }

    public void debit(float value) {
        _current_balance -= value;
    }

    public org.omg.CosTransactions.Vote prepare()
            throws org.omg.CosTransactions.HeuristicMixed,
            org.omg.CosTransactions.HeuristicHazard {
        if (_initial_balance == _current_balance)
            return org.omg.CosTransactions.Vote.VoteReadOnly;
        if (_current_balance < 0)
            return org.omg.CosTransactions.Vote.VoteRollback;
        return org.omg.CosTransactions.Vote.VoteCommit;
    }

    public void rollback()
            throws org.omg.CosTransactions.HeuristicCommit,
            org.omg.CosTransactions.HeuristicMixed,
            org.omg.CosTransactions.HeuristicHazard {
            //Nothing to do
    }

    public void commit()
            throws org.omg.CosTransactions.NotPrepared,
            org.omg.CosTransactions.HeuristicRollback,
            org.omg.CosTransactions.HeuristicMixed,
            org.omg.CosTransactions.HeuristicHazard {
        _account._balance = _current_balance;
    }

    public void commit_one_phase()
            throws org.omg.CosTransactions.HeuristicHazard {
        _account._balance = _current_balance;
    }

    .....

    private float _initial_balance;
    private float _current_balance;
    private Account _account;

}
----

*Sample Application Source Code*

Full source code for the banking application is included to provide you with a starting point for experimentation.

* JTS Version
** `src/com/arjuna/demo/jts/explicitremotebank/Bank.idl`
** `src/com/arjuna/demo/jts/explicitremotebank/BankClient.java`
** `src/com/arjuna/demo/jts/explicitremotebank/BankServer.java`
** `src/com/arjuna/demo/jts/explicitremotebank/BankImpl.java`
** `src/com/arjuna/demo/jts/explicitremotebank/AccountImpl.java` -> `AccountImpl.java`
** `src/com/arjuna/demo/jts/explicitremotebank/AccountResource.java`

*How the Banking Application is build using JTS interfaces*

The bank client is an application program able to manage transactions either in a direct or indirect management mode, respectively with the interfaces org.omg.CosTransactions.TransactionFactory and org.omg.CosTransactions.Terminator or with the org.omg.CosTransactions.Current interface.
Transactions created by the client in the Banking application are done in the indirect mode.

Invoking a remote object within a CORBA environment means that the remote object implements a CORBA interface defined in a CORBA idl file.
The following Bank.idl describes the interfaces then the possible kind of distributed CORBA objects involved in the banking application.
Only the Account interface inherits the CosTransactions::TransactionalObject interface, this means that an Account CORBA object is expected to invoked within a scope of transaction and the transactional context is implicitly propagated.

[source,Java]
----
module arjuna {
   module demo {
     module jts {
      module remotebank {

        interface Account : CosTransactions::TransactionalObject
        {
          float balance();
          void credit( in float value );
          void debit( in float value );
        };

        exception NotExistingAccount
        { };

        interface Bank
        {
          Account create_account( in string name );
          Account get_account( in string name )
            raises( NotExistingAccount );
        };
       };
      };
     };
};
----

The following portion of code illustrates how a JTS transaction is started and terminated when the client asks to transfer money from one account to another.
This also describes what are {parentProduct} packages that need to be used in order to obtain appropriate standard JTS API objects instances (such Current).

[NOTE]
====
The code below is a simplified view of the `BankClient.java` program.
Only the transfer operation is illustrated; other operations manage transactions in the same way.
(see for details the `src/com/arjuna/demo/jts/localbank/BankClient.java`)
====

[source,Java]
----
package com.arjuna.demo.jta.remotebank;
import com.arjuna.ats.jts.OTSManager;

public class BankClient {
    private Bank _bank;
   ....

    // This operation is used to make a transfer
    // from an account to another account
    private void makeTransfer() {
        //get the name of the supplier(name_supplier)
        // and the consumer(name_consumer)
        // get the amount to transfer (famount)
        ...

        try {
            //the following instruction asks a
            // specific {parentProduct} class
            // to obtain a Current instance
            Current current = OTSManager.get_current();
            System.out.println("Beginning a User
                    transaction to get balance");
                    current.begin();

            Account supplier = _bank.get_account(name_supplier);
            Account consumer = _bank.get_account(name_consumer);
            supplier.debit(famount);
            consumer.credit(famount);

            current.commit();
        } catch (Exception e) {
            ...
        }
    }
}
----

Since JTS is used invocations against an ORB are needed, such ORB and Object Adapter instantiation and initialisation.
To ensure a better portability, the ORB Portability API provides a set of methods that can be used as described below.

[source,Java]
----
public static void main(String[] args) {
    ....
    myORB = ORB.getInstance("test");
    myORB.initORB(args, null); //Initialise the ORB

    org.omg.CORBA.Object obj = null;
    try {
        //Read the reference string from
        // a file then convert to Object
        ....
        obj = myORB.orb().string_to_object(stringTarget);
    } catch (java.io.IOException ex) {
       ...
    }
    Bank bank = BankHelper.narrow(obj);
    ....
}
----

The Bank object has mainly two operations: creating an account, which is added in the account list, and returning an Account object.
No transactional instruction is performed by the Bank object.
The following lines decribe the implementation of the Bank CORBA object

[source,Java]
----
public class BankImpl extends BankPOA {
    public BankImpl(OA oa) {
        _accounts = new java.util.Hashtable();
        _oa = oa;
    }

    public Account create_account(String name) {
        AccountImpl acc = new AccountImpl(name);
        _accounts.put(name, acc);
        return com.arjuna.demo.jts.remotebank.AccountHelper.
                narrow(_oa.corbaReference(acc));
    }

    public Account get_account(String name)
            throws NotExistingAccount {
        AccountImpl acc = (AccountImpl) _accounts.get(name);
        if (acc == null)
            throw new NotExistingAccount("The Account requested
                    does not exist");
        return com.arjuna.demo.jts.remotebank.AccountHelper.
                narrow(_oa.corbaReference(acc));
    }

    private java.util.Hashtable _accounts;
    // Accounts created by the Bank
    private OA _oa;
}
----

After having defined an implementation of the Bank object, we should now create an instance and make it available for client requests.
This is the role of the Bank Server that has the responsibility to create the ORB and the Object Adapater instances, then the Bank CORBA object that has its object reference stored in a file well known by the bank client.
The following lines describe how the Bank server is implemented.

[source,Java]
----
public class BankServer {
    public static void main(String[] args) {
        ORB myORB = null;
        RootOA myOA = null;
        try {
            myORB = ORB.getInstance("ServerSide");
            myOA = OA.getRootOA(myORB);
            myORB.initORB(args, null);
            myOA.initOA();
            ....
            BankImpl bank = new BankImpl(myOA);

            String reference = myORB.orb().
                    object_to_string(myOA.corbaReference(bank));
            //Store the Object reference in the file
            ...
            System.out.println("The bank server is now ready...");
            myOA.run();
        }
    }
}
----

The Account object provides mainly three methods balance, credit and withdraw.
However, in order to provide the transactional behaviour, rather than to modify the current account directly (according to credit or withdraw) this task is delegated to an AccountResource object that is able, according to the transaction outcome, to set the account value either to its initial state or its final state.

The AccountResource object is in fact an object that implements the org.omg.CosTransactions.Resource, then able to participate to the transaction commitment.
For this aim, the Account object has to register the AccountResource object as a participant, after having obtaining the reference of the org.omg.CosTransactions.Coordinator object , itself obtained via the org.omg.CosTransactions.Control object

[source,Java]
----
package com.arjuna.demo.jta.remotebank;
import ....

public class AccountImpl extends AccountPOA {
    float _balance;
    AccountResource accRes = null;

    public Account(String name) {
        _name = name;
        _balance = 0;
    }

    public float balance() {
        return getResource().balance();
    }

    public void credit(float value) {
        getResource().credit(value);
    }

    public void debit(float value) {
        getResource().debit(value);
    }

    public AccountResource getResource() {
        try {
            if (accRes == null) {
                accRes = new AccountResource(this, _name);
                //The invocation on the ORB illustrates the
                // fact that the same ORB instance created
                // by the Bank Server is returned.
                ref = org.omg.CosTransactions.ResourceHelper.
                        narrow(OA.getRootOA(ORB.getInstance("ServerSide")).
                                corbaReference(accRes));
                RecoveryCoordinator recoverycoordinator = OTSManager.get_current().
                        get_control().get_coordinator().register_resource(ref);

            }
        } catch (Exception e) {....}
        return accRes;
    }
    ...
}
----

To be considered as a org.omg.CosTransactions.Resource, the AccountResource class shall extends the class org.omg.CosTransactions.ResourcePOA generated by the CORBA IDL compiler.
The AccountResource provides similar methods as the Account class (credit, withdraw and balance) with the appropriate methods to participate to the 2PC protocol.
The following portion of code describes how the methods prepare, commit and rollback are implemented.

[source,Java]
----
public class AccountResource
        extends org.omg.CosTransactions.ResourcePOA {
    public AccountResource(Account account, String name) {
        _name = name;
        _account = account;
        _initial_balance = account._balance;
        _current_balance = _initial_balance;
    }

    public float balance() {
        return _current_balance;
    }

    public void credit(float value) {
        _current_balance += value;
    }

    public void debit(float value) {
        _current_balance -= value;
    }

    public org.omg.CosTransactions.Vote prepare()
            throws org.omg.CosTransactions.HeuristicMixed,
            org.omg.CosTransactions.HeuristicHazard {
        if (_initial_balance == _current_balance)
            return org.omg.CosTransactions.Vote.VoteReadOnly;
        if (_current_balance < 0)
            return org.omg.CosTransactions.Vote.VoteRollback;
        return org.omg.CosTransactions.Vote.VoteCommit;
    }

    public void rollback()
            throws org.omg.CosTransactions.HeuristicCommit,
            org.omg.CosTransactions.HeuristicMixed,
            org.omg.CosTransactions.HeuristicHazard {
        //Nothing to do
    }

    public void commit()
            throws org.omg.CosTransactions.NotPrepared,
            org.omg.CosTransactions.HeuristicRollback,
            org.omg.CosTransactions.HeuristicMixed,
            org.omg.CosTransactions.HeuristicHazard {
        _account._balance = _current_balance;
    }

    public void commit_one_phase()
            throws org.omg.CosTransactions.HeuristicHazard {
        _account._balance = _current_balance;
    }

    ....
    private float _initial_balance;
    private float _current_balance;
    private final Account _account;

}
----

*Sample Application Source Code*

Full source code for the banking application is included to provide you with a starting point for experimentation.

* JTS Version
** `src/com/arjuna/demo/jts/remotebank/Bank.idl">Bank.idl`
** `src/com/arjuna/demo/jts/remotebank/BankClient.java`
** `src/com/arjuna/demo/jts/remotebank/BankServer.java` -> `BankServer.java`
** `src/com/arjuna/demo/jts/remotebank/BankImpl.java`
** `src/com/arjuna/demo/jts/remotebank/AccountImpl.java` -> `AccountImpl.java`
** `src/com/arjuna/demo/jts/remotebank/AccountResource.java`

*How the Banking Application is build using JTS interfaces*

From an architectural point of view of JTS, the bank client is considered as an application program able to manage transactions either in a direct or indirect management mode, respectively with the interfaces org.omg.CosTransactions.TransactionFactory and org.omg.CosTransactions.Terminator or with the org.omg.CosTransactions.Current interface.
Transactions created by the client in the Banking application are done in the indirect mode.

The following portion of code illustrates how a JTS transaction is started and terminated when the client asks to transfer money from one account to another.
This also describes what are {parentProduct} packages that need to be used in order to obtain appropriate objects instances (such Current).

[NOTE]
====
The code below is a simplified view of the `BankClient.java` program.
Only the transfer operation is illustrated; other operations manage transactions in the same way.
(see for details the `src/com/arjuna/demo/jts/localbank/BankClient.java`)
====

[source,Java]
----
package com.arjuna.demo.jta.localbank;
import com.arjuna.ats.jts.OTSManager;

public class BankClient {
    private Bank _bank;
    ....

    // This operation is used to make
    //a transfer from an account to another account
    private void makeTransfer() {
        System.out.print("Take money from : ");
        String name_supplier = input();

        System.out.print("Put money to : ");
        String name_consumer = input();

        System.out.print("Transfert amount : ");
        String amount = input();

        float famount = 0;
        try {
            famount = Float.parseFloat(amount);
        } catch (java.lang.Exception ex) {
            System.out.println("Invalid float number,
                    abort operation...");
            return;
        }

        try {
            //the following instruction asks a specific
            // {parentProduct} class to obtain a Current instance
            Current current = OTSManager.get_current();
            System.out.println("Beginning a User
                    transaction to get balance");
                    current.begin();

            Account supplier = _bank.get_account(name_supplier);
            Account consumer = _bank.get_account(name_consumer);
            supplier.debit(famount);
            consumer.credit(famount);

            current.commit();
        } catch (Exception e) {
            System.err.println("ERROR - " + e);
        }
    }
}
----

Since JTS is used invocations against an ORB are needed, such ORB and Object Adapter instantiation and initialisation.
To ensure a better portability, the ORB Portability API provides a set of methods that can be used as described below.

[source,Java]
----
public static void main(String[] args) {
    try {
        // Create an ORB instance
        myORB = ORB.getInstance("test");
        //Obtain the Root POA
        myOA = OA.getRootOA(myORB);
        //Initialise the ORB
        myORB.initORB(args, null);
        //Initialise the POA
        myOA.initOA();
        ....

    } catch (Exception e) { ....}
}
----

The Bank object has mainly two operations: creating an account, which is added in the account list, and returning an Account object.
No transactional instruction is performed by the Bank object

[source,Java]
----
package com.arjuna.demo.jta.localbank;

public class Bank {
    private final java.util.Hashtable _accounts;

    public Bank() {
        _accounts = new java.util.Hashtable();
    }

    public Account create_account(String name) {
        Account acc = new Account(name);
        _accounts.put(name, acc);
        return acc;
    }

    public Account get_account(String name)
            throws NotExistingAccount {
        Account acc = (Account) _accounts.get(name);
        if (acc == null)
            throw new NotExistingAccount("The Account
                    requested does not exist");
        return acc;
    }
}
----

The Account object provides mainly three methods balance, credit and withdraw.
However, in order to provide the transactional behaviour, rather than to modify the current account directly (according to credit or withdraw) this task is delegated to an AccountResource object that is able, according to the transaction outcome, to set the account value either to its initial state or its final state.

The AccountResource object is in fact an object that implements the org.omg.CosTransactions.Resource, then able to participate to the transaction commitment.
For this aim, the Account object has to register the AccountResource object as a participant, after having obtaining the reference of the org.omg.CosTransactions.Coordinator object , itself obtained via the org.omg.CosTransactions.Control object

[source,Java]
----
package com.arjuna.demo.jta.localbank;

public class Account {
    float _balance;
    AccountResource accRes = null;

    public Account(String name) {
        _name = name;
        _balance = 0;
    }

    public float balance() {
        return getResource().balance();
    }

    public void credit(float value) {
        getResource().credit(value);
    }

    public void debit(float value) {
        getResource().debit(value);
    }

    public AccountResource getResource() {
        try {
            if (accRes == null) {
                accRes = new AccountResource(this, _name);
                Resource ref = org.omg.CosTransactions.ResourceHelper.
                        narrow(OA.getRootOA(ORB.getInstance("test")).corbaReference(accRes));
                RecoveryCoordinator recoverycoordinator = OTSManager.get_current().
                        get_control().get_coordinator().register_resource(ref);
            }
        } catch (Exception e) {...}
        return accRes;
    }
    ...
}
----

To be considered as a org.omg.CosTransactions.Resource, the AccountResource class shall extends the class org.omg.CosTransactions.ResourcePOA generated by the CORBA IDL compiler.
The AccountRessource provides similar methods as the Account class (credit, withdraw and balance) with the appropriate methods to participate to the 2PC protocol.
The following portion of code describes how the methods prepare, commit and rollback are implemented.

[source,Java]
----
public class AccountResource extends org.omg.CosTransactions.ResourcePOA {
    public AccountResource(Account account, String name) {
        _name = name;
        _account = account;
        _initial_balance = account._balance;
        _current_balance = _initial_balance;
    }

    public float balance() {
        return _current_balance;
    }

    public void credit(float value) {
        _current_balance += value;
    }

    public void debit(float value) {
        _current_balance -= value;
    }

    public org.omg.CosTransactions.Vote prepare()
            throws org.omg.CosTransactions.HeuristicMixed,
            org.omg.CosTransactions.HeuristicHazard {
        if (_initial_balance == _current_balance)
            return org.omg.CosTransactions.Vote.VoteReadOnly;
        if (_current_balance < 0)
            return org.omg.CosTransactions.Vote.VoteRollback;
        return org.omg.CosTransactions.Vote.VoteCommit;
    }

    public void rollback()
            throws org.omg.CosTransactions.HeuristicCommit,
            org.omg.CosTransactions.HeuristicMixed,
            org.omg.CosTransactions.HeuristicHazard {
        //Nothing to do
    }

    public void commit()
            throws org.omg.CosTransactions.NotPrepared,
            org.omg.CosTransactions.HeuristicRollback,
            org.omg.CosTransactions.HeuristicMixed,
            org.omg.CosTransactions.HeuristicHazard {
        _account._balance = _current_balance;
    }

    public void commit_one_phase()
            throws org.omg.CosTransactions.HeuristicHazard {
        _account._balance = _current_balance;
    }
    .....
    private final float _initial_balance;
    private float _current_balance;
    private final Account _account;
}
----

*Sample Application Source Code*

Full source code for the banking application is included to provide you with a starting point for experimentation.

* JTS Version
** `src/com/arjuna/demo/jts/localbank/BankClient.java`
** `src/com/arjuna/demo/jts/localbank/Bank.java` -> `Bank.java`
** `src/com/arjuna/demo/jts/localbank/Account.java` -> `Account.java`
** `src/com/arjuna/demo/jts/localbank/AccountResource.java`
** `src/com/arjuna/demo/jts/localbank/NotExistingAccount.java` -> `NotExistingAccount.java`

=== Making the Banking Application Persistent

The way the banking application is built and deployed in the previous trail does not it make it persistent, in such way that any created account can be retrieved later after stopping the bank server or if the application crashes; moreover, it does not allow concurrent access to accounts without leading to inconsistent values.

Two ways will be presented in this trail on the way to build the banking application as a persistent and sharable application:

* Using the {parentProduct} Object For Java (TXOJ) mechanisms
** Overview of the Transactional Object For Java
** Deploying the Banking application with TXOJ mechanisms
* Using the JDBC API by considering the banking application as a relational database.
** Developing applications with JDBC and {parentProduct}
** The banking application as a relational database accessed with JDBC

=== What is Transactional Object For Java

ArjunaCore exploits object-oriented techniques to present programmers with a toolkit of Java classes from which application classes can inherit to obtain desired properties, such as persistence and concurrency control.
These classes form a hierarchy, part of which is shown below.

.ArjunaCore class hierarchy
image::../images/jts-ArjunaCore_Classes.PNG.png[align="center"]

Apart from specifying the scopes of transactions, and setting appropriate locks within objects, the application programmer does not have any other responsibilities: ArjunaCore and Transactional Objects for Java (TXOJ) guarantee that transactional objects will be registered with, and be driven by, the appropriate transactions, and crash recovery mechanisms are invoked automatically in the event of failures.

==== Recovery and Persistency

Making an object persistent and recoverable means that we shall be able to store its final state or to retrieve its initial state according to the final status of a transaction even in the presence of failures.
ArjunaCore provides a set of techniques to save to and to retrieve from the Object Store states of objects.
All objects made persistent with these ArjunaCore mechanisms are assigned unique identifiers (instances of the Uid class), when they are created, and this is to identify them within the object store.
Due to common functionality for persistency and recovery required by several applications, objects are stored and retrieved from the object store using the same mechanism: the classes OutputObjectState and InputObjecState.

At the root of the class hierarchy, given in Figure 1, is the class StateManager.
This class is responsible for object activation and deactivation and object recovery.
The simplified signature of the class is:

[source,Java]
----
public abstract class StateManager {
    public boolean activate();

    public boolean deactivate(boolean commit);

    public Uid get_uid(); // object’s identifier.

    // methods to be provided by a derived class
    public boolean restore_state(InputObjectState os);

    public boolean save_state(OutputObjectState os);

    protected StateManager();

    protected StateManager(Uid id);
}
----

Objects are assumed to be of three possible flavours.
They may simply be recoverable, in which case StateManager will attempt to generate and maintain appropriate recovery information for the object.
Such objects have lifetimes that do not exceed the application program that creates them.
Objects may be recoverable and persistent, in which case the lifetime of the object is assumed to be greater than that of the creating or accessing application, so that in addition to maintaining recovery information StateManager will attempt to automatically load (unload) any existing persistent state for the object by calling the activate (deactivate) operation at appropriate times.
Finally, objects may possess none of these capabilities, in which case no recovery information is ever kept nor is object activation/deactivation ever automatically attempted.

According to the its activation or deactivation a transactional object for Java move from a passive state to an active state and vice-versa.
The fundamental life cycle of a persistent object in TXOJ is shown in Figure 2.

.The life cycle of a persistent object.
image::../images/jts-txoj_lifecycle.PNG.png[align="center"]

* The object is initially passive, and is stored in the object store as an instance of the class OutputObjectState.
* When required by an application the object is automatically activated by reading it from the store using a read_committed operation and is then converted from an InputObjectState instance into a fully-fledged object by the restore_state operation of the object.
* When the application has finished with the object it is deactivated by converting it back into an OutputObjectState instance using the save_state operation, and is then stored back into the object store as a shadow copy using write_uncommitted.
This shadow copy can be committed, overwriting the previous version, using the commit_state operation.
The existence of shadow copies is normally hidden from the programmer by the transaction system.
Object de-activation normally only occurs when the top-level transaction within which the object was activated commits.

While deactivating and activating a transactional object for java, the operations save_state and restore_state are respectively invoked.
These operations must be implemented by the programmer since StateManager cannot detect user level state changes.
This gives the programmer the ability to decide which parts of an object's state should be made persistent.
For example, for a spreadsheet it may not be necessary to save all entries if some values can simply be recomputed.
The save_state implementation for a class Example that has two integer member variables called A and B and one String member variable called C could simply be:

[source,Java]
----
public boolean save_state(OutputObjectState o) {
    if (!super.save_state(o))
        return false;
    try {
        o.packInt(A);
        o.packInt(B);
        o.packString(C))
    } catch (Exception e) {
        return false;
    }
    return true;
}
----

while, the corresponding restore_state implementation allowing to retrieve similar values is:

[source,Java]
----
public boolean restore_state(InputObjectState o) {
    if (!super.restore_state(o))
        return false;
    try {
        A = o.unpackInt();
        B = o.unpackInt();
        S = o.unpackString())
    } catch (Exception e) {
        return false;
    }
    return true;
}
----

Classes OutputObjectState and InputObjectState provide respectively operations to pack and unpack instances of standard Java data types.
In other words for a standard Java data type, for instance Long or Short, there are corresponding methods to pack and unpack, i.e., packLong or packShort and unpackLong or unpackShort.

_Note:_ it is necessary for all save_state and restore_state methods to call super.save_state and super.restore_state.
This is to cater for improvements in the crash recovery mechanisms.

==== The concurrency controller

The concurrency controller is implemented by the class LockManager which provides sensible default behaviour while allowing the programmer to override it if deemed necessary by the particular semantics of the class being programmed.
The primary programmer interface to the concurrency controller is via the setlock operation.
By default, the runtime system enforces strict two-phase locking following a multiple reader, single writer policy on a per object basis.
However, as shown in Figure 1, by inheriting from the Lock class it is possible for programmers to provide their own lock implementations with different lock conflict rules to enable type specific concurrency control.

Lock acquisition is (of necessity) under programmer control, since just as StateManager cannot determine if an operation modifies an object, LockManager cannot determine if an operation requires a read or write lock.
Lock release, however, is under control of the system and requires no further intervention by the programmer.
This ensures that the two-phase property can be correctly maintained.

[source,Java]
----
public abstract class LockManager extends StateManager {
   public LockResult setlock (Lock toSet, int retry, int timeout);
}
----

The LockManager class is primarily responsible for managing requests to set a lock on an object or to release a lock as appropriate.
However, since it is derived from StateManager, it can also control when some of the inherited facilities are invoked.
For example, LockManager assumes that the setting of a write lock implies that the invoking operation must be about to modify the object.
This may in turn cause recovery information to be saved if the object is recoverable.
In a similar fashion, successful lock acquisition causes activate to be invoked.

The code below shows how we may try to obtain a write lock on an object:

[source,Java]
----
public class Example extends LockManager {
    public boolean foobar() {
        AtomicAction A = new AtomicAction;
        /*
         * The ArjunaCore AtomicAction class is here used to create
         * a transaction. Any interface provided by the JTA or
         * JTS interfaces that allow to create transactions can
         * be used in association with the Locking mechanisms
         * described in this trail.
         */
        boolean result = false;

        A.begin();
        if (setlock(new Lock(LockMode.WRITE), 0) == Lock.GRANTED) {
            /*
             * Do some work, and TXOJ will
             * guarantee ACID properties.
             */
            // automatically aborts if fails
            if (A.commit() == AtomicAction.COMMITTED) {
                result = true;
            }
        } else
            A.rollback();

        return result;
    }
}
----

==== Further Reading

More details on Transactional Object For Java can be found in the ArjunaCore Programming Guide.

==== Making the Banking Application Persistent with Transactional Object For Java

The banking application consists of a Bank object that contains a list of Account object, which in turn have a String (name) and a float (the value) as member variables.
It appears clearly that from the persistent point of view, an Account Object need to store its name and its current balance or value, while the Bank Object need to store the list of accounts that it manages.

===== Distributed Configuration

The banking application with Transactional Object for Java (TXOJ) is configured to use JTS interfaces as the API to create the transaction, then an ORB to deploy it.
The {parentProduct} distribution is provided to work with the bundled JacORB version

_Note_ : Ensure that the jacorb jar files are added in your `CLASSPATH`

===== Delpoy the Application

- Start the Server
+
[source,shell]
----
java com.arjuna.demo.jts.txojbank.BankServer
----

- In a separate window, start the client
+
[source,shell]
----
java com.arjuna.demo.jts.txojbank.BankClient
----

As for the demonstrations presented in the previous trails, the same menu is presented for the client with a set of operations such creating an account, credit/withdraw money to/from an account and making a transfer.

Building the banking application with TXOJ tools

===== Building the banking application with TXOJ

===== The Bank IDL

Since a distributed version has been adopted to present the application with Transactional Object for Java, an IDL file named Bank.idl described below is needed.
The difference with the Bank.idl presented in previous trails is the fact that the Bank interface inherits the CosTransactions::TransactionalObject interface.
Since we consider now that a Bank object need to modify its list in a transactional, we consider now a Bank object as a CORBA transactional.

[source,Java]
----
module arjuna {
   module demo {
     module jts {
      module txojbank {

        interface Account : CosTransactions::TransactionalObject
        {
          float balance();
          void credit( in float value );
          void debit( in float value );
        };

        exception NotExistingAccount
        { };

        interface Bank : CosTransactions::TransactionalObject
        {
          Account create_account( in string name );
          Account get_account( in string name )
            raises( NotExistingAccount );
        };
       };
      };
     };
};
----

* The client program
+
Basically the client program (`src/com/arjuna/demo/jts/txojbank/BankClient.java`) is equivalent to the one described in the distributed jts version with implicit propagation, the difference is on the package name.
* Implementing the Account Interface
* Implementing the Bank Interface
* Implementing the Bank Server.

===== Implementing the Account interface

To take benefit from the persistency and locking mechanism provided by ArjunaCore, a user class can inherit from the appropriate class (StateManager for recovery, and LockManager for recovery and concurrency control).
The AccountImpl class that implements the Account interface inherits the LockManager and implements the AccountOperations interface generated by the CORBA IDL compiler.
Since multiple inheritance is not allowed in Java, inheriting the AccountPOA class, as made in simple jts remote version, in addition to the LockManager is not possible.
That we use in this version a CORBA TIE mechanism to associate a servant to an CORBA object reference.

The Java interface definition of the AccountImpl class is given below:

[source,Java]
----
public class AccountImpl extends LockManager implements AccountOperations {
    float _balance;
    String _name;

    public AccountImpl(String name);

    public AccountImpl(Uid uid);

    protected void finalize();

    public float balance();

    public void credit(float value);

    public void debit(float value);

    public boolean save_state(OutputObjectState os, int ObjectType);

    public boolean restore_state(InputObjectState os, int ObjectType);

    public String type();
}
----

* Constructors and Destructor
+
To use an existing persistent object requires the use of a special constructor that is required to take the Uid of the persistent object; the implementation of such a constructor is given below:
+
[source,Java]
----
public AccountImpl(Uid uid) {
    super(uid);
    // Invoking super will lead to invoke the
    // restore_state method of this AccountImpl class
}
----
+
There is no particular behaviour applied by the Constructor with the Uid parameter The following constructor is used for a new Account creation.
+
[source,Java]
----
public AccountImpl(String name ) {
    super(ObjectType.ANDPERSISTENT);
    _name = name;
    _balance = 0;
}
----
+
The destructor of the queue class is only required to call the terminate operation of LockManager.
* save_state, restore_state and type
+
The implementations of save_state and restore_state are relatively simple for this example:
+
[source,Java]
----
public boolean save_state(OutputObjectState os, int ObjectType) {
    if (!super.save_state(os, ObjectType))
        return false;

    try {
        os.packString(_name);
        os.packFloat(_balance);
        return true;
    } catch (Exception e) {
        return false;
    }
}
----
+
[source,Java]
----
public boolean restore_state(InputObjectState os, int ObjectType) {
    if (!super.restore_state(os, ObjectType))
        return false;

    try {
        _name = os.unpackString();
        _balance = os.unpackFloat();
        return true;
    } catch (Exception e) {
        return false;
    }
}
----
+
Because the AccountImpl class is derived from the LockManager class, the operation type should be:
* account management operations
+
[source,Java]
----
public float balance() {
    float result = 0;
    if (setlock(new Lock(LockMode.READ), 0) == LockResult.GRANTED) {
        result = _balance;
    }
    ...

    return result;
}
----
+
Since the balance operation consists only to get the current balance, acquiring a lock in READ mode is enough.
This is not the case of the credit and debit methods that need to modify the current balance, that is a WRITE mode is needed.
+
[source,Java]
----
public void credit(float value) {
    if (setlock(new Lock(LockMode.WRITE), 0) == LockResult.GRANTED) {
        _balance += value;
    }
    ...
}

public void debit(float value) {
    if (setlock(new Lock(LockMode.WRITE), 0) == LockResult.GRANTED) {
        _balance -= value;
    }
    ...
}
----

===== Sample Application Source Code

Full source code for the `src/com/arjuna/demo/jts/txojbank/AccountImpl.java` -> AccountImpl class is included to provide you with a starting point for experimentation.

===== Implementing the Bank interface

To take benefit from the persistency and locking mechanism provided by ArjunaCore, a user class can inherit from the appropriate class (StateManager for recovery, and LockManager for recovery and concurrency control).
The BankImpl class that implements the Bank interface inherits the LockManager and implements the BankOperations interface generated by the CORBA IDL compiler.
Since multiple inheritance is not allowed in Java, inheriting the BankPOA class, as made in simple jts remote version, in addition to the LockManager is not possible.
That we use in this version a CORBA TIE mechanism to associate a servant to an CORBA object reference.

The Java interface definition of the BankImpl class is given below:

[source,Java]
----
public class BankImpl extends LockManager implements BankOperations {
    public BankImpl(OA oa);

    public BankImpl(Uid uid, OA oa);

    public BankImpl(Uid uid);

    public Account create_account(String name);

    public Account get_account(String name);

    public boolean save_state(OutputObjectState os, int ObjectType);

    public boolean restore_state(InputObjectState os, int ObjectType);

    public String type();

    public static final int ACCOUNT_SIZE = 10;
    // ACCOUNT_SIZE is the maximum number of accounts
    private String[] accounts;
    private int numberOfAccounts;
    private ORB _orb;
    private OA _oa;
    private java.util.Hashtable _accounts; //The list of accounts
}
----

* Constructors and Destructor
+
To use an existing persistent object requires the use of a special constructor that is required to take the Uid of the persistent object; the implementation of such a constructor is given below:
+
[source,Java]
----
public BankImpl(Uid uid) {
    super(uid);
    _accounts = new java.util.Hashtable();
    numberOfAccounts = 0;
    accounts = new String[ACCOUNT_SIZE];
}
----
+
The following constructor is invoked during the first creation of the Bank Object.
+
[source,Java]
----
public BankImpl(OA oa) {
    super(ObjectType.ANDPERSISTENT);
    _accounts = new java.util.Hashtable();
    _oa = oa;
    numberOfAccounts = 0;
    accounts = new String[ACCOUNT_SIZE];
}
----
+
The following constructor is invoked on successive BankServer restart.
A bank already exists and should be recreated.
Invoking super or the constructor of the inherited class leads to execute the restore_state method, described below, of the BankImpl class to rebuild the list of accounts previously created, if any.
+
[source,Java]
----
public BankImpl(Uid uid, OA oa) {
    super(uid);
    _accounts = new java.util.Hashtable();
    _oa = oa;
    numberOfAccounts = 0;
    accounts = new String[ACCOUNT_SIZE];
}
----
+
The destructor of the queue class is only required to call the terminate operation of LockManager.

[source,Java]
----
protected void finalize() {
    super.terminate();
}
----

* account management operations
+
[source,Java]
----
public Account create_account(String name) {
    AccountImpl acc;
    AccountPOA account = null;
    //Attempt to obtain the lock for change
    if (setlock(new Lock(LockMode.WRITE), 0) == LockResult.GRANTED) {
        //Check if the maximum number of accounts is not reached
        if (numberOfAccounts < ACCOUNT_SIZE) {
            acc = new AccountImpl(name); //Create a new account
            //Use the TIE mechanism to create a CORBA object
            account = new AccountPOATie(acc);
            //Add the account to the list of accounts that
            //facilitate to retrieve accounts
            _accounts.put(name, acc);
            //The Uid of the created account is put in the array
            accounts[numberOfAccounts] = acc.get_uid().toString();
            numberOfAccounts++;
        }
    }
    return com.arjuna.demo.jts.txojbank.
            AccountHelper.narrow(_oa.corbaReference(account));
}

public Account get_account(String name)
        throws NotExistingAccount {
    // Only the hashtable list is used to retrieve the account
    AccountImpl acc = (AccountImpl) _accounts.get(name);
    AccountPOA account = new AccountPOATie(acc);
    if (acc == null)
        throw new NotExistingAccount("The Account
                requested does not exist");
    return com.arjuna.demo.jts.txojbank.
            AccountHelper.narrow(_oa.corbaReference(account));
}
----

* save_state, restore_state and type
+
[source,Java]
----
public boolean save_state(OutputObjectState os, int ObjectType) {
    if (!super.save_state(os, ObjectType))
        return false;

    try {
        os.packInt(numberOfAccounts);
        if (numberOfAccounts > 0) {
            // All Uid located in the array will be saved
            for (int i = 0; i < numberOfAccounts; i++)
                os.packString(accounts[i]);
        }
        return true;
    } catch (Exception e) {
        return false;
    }
}
----
+
[source,Java]
----
public boolean restore_state(InputObjectState os, int ObjectType) {
    if (!super.restore_state(os, ObjectType)) {
        return false;
    }
    try {
        numberOfAccounts = os.unpackInt();

        if (numberOfAccounts > 0) {
            for (int i = 0; i < numberOfAccounts; i++) {
                accounts[i] = os.unpackString();
                //each stored Uid is re-used to recreate
                //a stored account object
                AccountImpl acc = new AccountImpl(new Uid(accounts[i]));
                acc.activate();
                //Once recreated the account object
                //is activated and added to the list.
                _accounts.put(acc.getName(), acc);
            }
        }
        return true;
    } catch (Exception e) {
        return false;
    }
}
----
+
[source,Java]
----
public String type () {
    return "/StateManager/LockManager/BankServer";
}
----

===== Sample Application Source Code

Full source code for the `src/com/arjuna/demo/jts/txojbank/BankImpl.java` -> BankImpl class is included to provide you with a starting point for experimentation.

===== Implementing the BankServer

The role of the BankServer class is mainly to initialise the ORB and the Object Adapter and to create the default Bank object responsible to create banking accounts.

Globally the BankServer has the following structure.

* Initialise the ORB
+
This done using the ORB Portability API
* Create the BankImpl object, an instance that implements the Bank interface.
Two ways are provided to build such Bank object according to the fact it's the first time we create such object or not.
This depends on the existence or not of the file named "
** {blank}
+
[source,Java]
----
...
java.io.FileInputStream file = new java.io.FileInputStream("UidBankFile");
java.io.InputStreamReader input = new java.io.InputStreamReader(file);
java.io.BufferedReader reader = new java.io.BufferedReader(input);
String stringUid = reader.readLine();
file.close();
_bank = new BankImpl(new Uid(stringUid), myOA);
boolean result =_bank.activate();
...
----
** If the file does not exist, a new BankImpl object is created, then the Uid of the created object is stored in the file named "UidBankFile"
+
[source,Java]
----
...
_bank = new BankImpl(myOA);
java.io.FileOutputStream file = new java.io.FileOutputStream("UidBankFile");
java.io.PrintStream pfile=new java.io.PrintStream(file);
pfile.println(_bank.get_uid().toString());
file.close();
...
----
* Store the CORBA object reference of the BankImpl object in a file in such way the client can retrieve it from that file.

===== Sample Application Source Code

Full source code for the `src/com/arjuna/demo/jts/txojbank/BankServer.java` -> `BankServer` class is included to provide you with a starting point for experimentation.

==== Developing applications with JDBC and {parentProduct} JTS

{parentProduct} JTS supports the construction of both local and distributed transactional applications which access databases using the JDBC APIs.
JDBC supports two-phase commit of transactions, and is similar to the XA X/Open standard.
The JDBC support is found in the com.arjuna.ats.jdbc package.

===== Transactional Driver

The {parentProduct} JTS approach to incorporating JDBC connections within transactions is to provide transactional JDBC drivers through which all interactions occur.
These drivers intercept all invocations and ensure that they are registered with, and driven by, appropriate transactions.
There is a single type of transactional driver through which any JDBC driver can be driven; obviously if the database is not transactional then ACID properties cannot be guaranteed.
This driver is com.arjuna.ats.jdbc.TransactionalDriver, which implements the java.sql.Driver interface.

The driver may be directly instantiated and used within an application.
For example:

[source,Java]
----
 TransactionalDriver arjunaJDBC2Driver = new TransactionalDriver();
----

It can be registered with the JDBC driver manager (`java.sql.DriverManager`) by adding them to the Java system properties.
The `jdbc.drivers` property contains a list of driver class names, separated by colons, that are loaded by the JDBC driver manager when it is initialised, for instance:

[source,xml]
----
jdbc.drivers=foo.bar.Driver:mydata.sql.Driver:bar.test.myDriver
----

On running an application, it is the DriverManager's responsibility to load all the drivers found in the system property jdbc.drivers.
For example, this is where the driver for the Oracle database may be defined.
When opening a connection to a database it is the DriverManager' s role to choose the most appropriate driver from the previously loaded drivers.

A program can also explicitly load JDBC drivers at any time.
For example, the `my.sql.Driver` is loaded with the following statement:

[source,Java]
----
Class.forName("my.sql.Driver");
----

Calling Class.forName() will automatically register the driver with the JDBC driver manager.
It is also possible to explicitly create an instance of the JDBC driver using the registerDriver method of the DriverManager.
This is the case for instance for the TransactionalDriver that can be registered as follows:

[source,Java]
----
TransactionalDriver arjunaJDBC2Driver = new TransactionalDriver();
DriverManager.registerDriver(arjunaJDBC2Driver);
----

When you have loaded a driver, it is available for making a connection with a DBMS.

===== Making Connections

Once a driver is loaded and ready for a connection to be made, instances of a Connection class can be created using the getConnection method on the DriverManager, as follows:

[source,Java]
----
Connection con = DriverManager.getConnection(url, username, password);
----

From its version 2.0, the JDBC API has introduced a new way to obtain instances of the Connection class.
This is the case of the interfaces DataSource and XADataSource that creates transactional connections.
When using a JDBC 2.0 driver, {parentProduct} will use the appropriate DataSource whenever a connection to the database is made.
It will then obtain XAResources and register them with the transaction via the JTA interfaces.
It is these XAResources which the transaction service will use when the transaction terminates in order to drive the database to either commit or rollback the changes made via the JDBC connection.

There are two ways in which the {parentProduct} JDBC 2.0 support can obtain XADataSources.
These will be explained in the following sections.
Note, for simplicity we shall assume that the JDBC 2.0 driver is instantiated directly by the application.

* Java Naming and Directory Interface (JNDI)
+
To get the ArjunaJDBC2Driver class to use a JNDI registered XADataSource it is first necessary to create the XADataSource instance and store it in an appropriate JNDI implementation.
Details of how to do this can be found in the JDBC 2.0 tutorial available at JavaSoft.
An example is show below:
+
[source,Java]
----
XADataSource ds = MyXADataSource();
Hashtable env = new Hashtable();
String initialCtx = PropertyManager.getProperty("Context.INITIAL_CONTEXT_FACTORY");
env.put(Context.INITIAL_CONTEXT_FACTORY, initialCtx);
initialContext ctx = new InitialContext(env);
ctx.bind("jdbc/foo", ds);
----
+
Where the Context.INITIAL_CONTEXT_FACTORY property is the JNDI way of specifying the type of JNDI implementation to use.
+
Then the application must pass an appropriate connection URL to the JDBC 2.0 driver:
+
[source,Java]
----
Properties dbProps = new Properties();
dbProps.setProperty(TransactionalDriver.userName, "user");
dbProps.setProperty(TransactionalDriver.password, "password");
TransactionalDriver arjunaJDBC2Driver = new TransactionalDriver();
Connection connection = arjunaJDBC2Driver.connect("jdbc:arjuna:jdbc/foo", dbProps);
----
+
The JNDI URL must be pre-pended with jdbc:arjuna: in order for the ArjunaJDBC2Driver to recognise that the DataSource must participate within transactions and be driven accordingly.
* Dynamic class instantiation
+
Many JDBC implementations provide proprietary implementations of XADataSources that provide non-standard extensions to the specification.
In order to allow the application to remain isolated from the actual JDBC 2.0 implementation it is using and yet continue to be able to use these extensions, {parentProduct} hides the details of these proprietary implementations using dynamic class instantiation.
In addition, the use of JNDI is not required when using this mechanism because the actual implementation of the XADataSource will be directly instantiated, albeit in a manner which will not tie an application or driver to a specific implementation.
{parentProduct} therefore has several classes which are for specific JDBC implementations, and these can be selected at runtime by the application setting the dynamicClass property appropriately:

[cols=",",]
|===
|_Database Type_ |_Property Name_
|Cloudscape 3.6 |com.arjuna.ats.internal.jdbc.drivers.cloudscape_3_6
|Sequelink 5.1 |com.arjuna.ats.internal.jdbc.drivers.sequelink_5_1
|Oracle 8.1.6 |com.arjuna.ats.internal.jdbc.drivers.oracle_8_1_6
|SQL Server 2000 |com.arjuna.ats.internal.jdbc.drivers.sqlserver_2_2
|===

The application code must specify which dynamic class the TransactionalDriver should instantiate when setting up the connection:

[source,java]
----
Properties dbProps = new Properties();
dbProps.setProperty(TransactionalDriver.userName, "user");
dbProps.setProperty(TransactionalDriver.password, "password");
dbProps.setProperty(TransactionalDriver.dynamicClass,
        "com.arjuna.ats.internal.jdbc.drivers.sequelink_5_0");
TransactionalDriver arjunaJDBC2Driver = new TransactionalDriver();
Connection connection = arjunaJDBC2Driver.connect("jdbc:arjuna:
        sequelink/*:host:port;databaseName=foo",dbProperties*/);
----

Note on properties used by the `com.arjuna.ats.jdbc.TransactionalDriver` class

* _userName_: the user name to use when attempting to connect to the database.
* _password_: the password to use when attempting to connect to the database.
* _createDb_: if set to true, the driver will attempt to create the database when it connects.
+
[NOTE]
This may not be supported by all JDBC 2.0 implementations.
* _dynamicClass_: this specifies a class to instantiate to connect to the database, rather than using JNDI.

===== Using the Connection

Once the connection has been established (for example, using the `java.sql.DriverManager.getConnection` method), all operations on the connection will be monitored by {parentProduct}.
Once created, the driver and any connection can be used in the same way as any other JDBC driver or connection.

{parentProduct} connections can be used within multiple different transactions simultaneously, i.e., different threads, with different notions of the current transaction, may use the same JDBC connection. {parentProduct} does connection pooling for each transaction within the JDBC connection.
So, although multiple threads may use the same instance of the JDBC connection, internally this may be using a different connection instance per transaction.
With the exception of close, all operations performed on the connection at the application level will only be performed on this transaction-specific connection.

{parentProduct} will automatically register the JDBC driver connection with the transaction via an appropriate resource . When the transaction terminates, this resource will be responsible for either committing or rolling back any changes made to the underlying database via appropriate calls on the JDBC driver.

===== Further reading

More details on the way to manage applications using the JDBC API can be found in the {parentProduct} Programming Guide.

===== The banking application as a relational database accessed with JDBC

In regards to the its structure in the previous trails, the banking application described here has been slightly simplified.
In this version creating local JTA transactions, accounts managed by a bank object are in fact instances or tuples within a SQL relational table named "accounts".
When the Bank object is requested for instance to create an account or to get information on an account, the Bank object performs SQL statement such SQL INSERT or SQL SELECT.

===== Deploy the application

Executing the demonstration consists to launch the folowing program

[source,shell]
----
java com.arjuna.demo.jta.jdbcbank.BankClient  -host <hostName>
  -port portNumber  -username <userName>  -dbName <DBName>
  -password <password> -clean|-create
----

Where:

* _hostName_ - the name of the machine where is located the database
* _userName_ - the user name used to access the database
* _password_ - the password used to access to database
* _DBName_ - the database name
* _clean_ - the existing relational table will be deleted then created
* _create_ - a new relational table will be created

[NOTE]
Due to an issue with Oracle, it is possible that an XA exception is thrown when attempting to perform this test (see Release Notes).
If an xa error is returned you can use the following property property _com.arjuna.ats.jdbc.isolationLevel_ set to _TRANSACTION_READ_COMMITTED_ .

This property can be added in previous command as follows:

[source,shell]
----
java -Dcom.arjuna.ats.jdbc.isolationLevel=TRANSACTION_READ_COMMITTED
  com.arjuna.demo.jta.jdbcbank.BankClient  -host <hostName>
  -port portNumber  -userName <userName>
  -password <password> -clean|-create
----

===== How JDBC is used

The following Banking application illustrates some methods that use the JDBC API.
In this application, the way to create a jdbc connection is made via an XADataSource obtained with JNDI operations, es explained in the previous trail jdbc introduction The BankClient class instantiates an XADataSource and bind it to a jndi naming in order to be retrieved to create transactional connections.
This portion of code illustrates how this made against oracle (tested on version 9i).
A similar code could tested against an other database by providng the appropriate XADataSource implementation.
Details of the BankClient class can be found in the file `src/com/arjuna/demo/jta/jdbcbank/BankClient.java`

[source,Java]
----
package com.arjuna.demo.jta.jdbcbank;

import javax.naming .*;
        import java.util.Hashtable;
  import oracle.jdbc.xa.client.OracleXADataSource;
  import com.arjuna.ats.jdbc.common.jdbcPropertyManager;

public class BankClient {
    .....

    public static void main(String[] args) {
        //Provide the apporopriate information to access the database
        for (int i = 0; i < args.length; i++) {
            if (args[i].compareTo("-host") == 0)
                host = args[i + 1]
            if (args[i].compareTo("-port") == 0)
                port = args[i + 1];
            if (args[i].compareTo("-username") == 0)
                user = args[i + 1];
            if (args[i].compareTo("-password") == 0)
                password = args[i + 1];
            if (args[i].compareTo("-dbName") == 0)
                dbName = args[i + 1];
            ....
        }

        try {
            // create DataSource
            OracleXADataSource ds = new OracleXADataSource();
            ds.setURL("jdbc:oracle:thin:@" + host + ":" + port + ":" + dbName);

            // now stick it into JNDI
            Hashtable env = new Hashtable();
            env.put(Context.INITIAL_CONTEXT_FACTORY,
                    "com.sun.jndi.fscontext.RefFSContextFactory");
            env.put(Context.PROVIDER_URL, "file:/tmp/JNDI");
            InitialContext ctx = new InitialContext(env);
            ctx.rebind("jdbc/DB", ds);
        } catch (Exception ex) {
        }
        //Set the jndi information to be user by the Arjuna JDBC Property Manager
        jdbcPropertyManager.propertyManager.setProperty("Context.INITIAL_CONTEXT_FACTORY",
                "com.sun.jndi.fscontext.RefFSContextFactory");
        jdbcPropertyManager.propertyManager.setProperty("Context.PROVIDER_URL",
                "file:/tmp/JNDI");

        Bank bank = new Bank();
        BankClient client = new BankClient(bank);

    }

    ....
----

While the BankClient class is responsible to obtain information to access the database, tocreate the XADataSource and bind it to jndi, and also to get order from a user (create_account, debit, transfer, ..), the Bank class is resposnible to create jdbc connections to perform user's requests.
The Bank class is illustarted below where.
All methods are not illusrated here but have a similar behavior; they could be found in details in the `src/com/arjuna/demo/jta/jdbcbank/Bank.java` -> `Bank.java` program.
Note that for simplicity, much error checking code has been removed.

[source,Java]
----
    public Bank() {
        try {
            DriverManager.registerDriver(new TransactionalDriver());
            dbProperties = new Properties();
            dbProperties.put(TransactionalDriver.userName, user);
            dbProperties.put(TransactionalDriver.password, password);
            arjunaJDBC2Driver = new TransactionalDriver(); //
            create_table();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(0);
        }

        _accounts = new java.util.Hashtable();
        reuseConnection = true;
    }

    public void create_account(String _name, float _value) {
        try {
            Connection conne = arjunaJDBC2Driver.connect("jdbc:arjuna:jdbc/DB", dbProperties);
            Statement stmtx = conne.createStatement(); // tx statement
            stmtx.executeUpdate
                    ("INSERT INTO accounts (name, value)
                            VALUES('"+_name+"', "+_value+")");
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public float get_balance(String _name)
            throws NotExistingAccount {
        float theBalance = 0;
        try {
            Connection conne = arjunaJDBC2Driver.connect("jdbc:arjuna:jdbc/DB", dbProperties);
            Statement stmtx = conne.createStatement(); // tx statement
            ResultSet rs = stmtx.executeQuery
                    ("SELECT value from accounts
                            WHERE name = '"+_name+"'");
            while (rs.next()) {
                theBalance = rs.getFloat("value");
            }
        } catch (SQLException e) {
            e.printStackTrace();
            throw new NotExistingAccount("The Account requested does not exist");
        }
        return theBalance;
    }

    ....
}
----

===== Note

Although, this version of the banking application creates JTA local transactions, the way to manipulate JDBC API and the associated {parentProduct} mechanisms in the case of distributed transactions is the same.

=== Recovery From Failure Examples

==== Introduction

Recovery is the mechanism which preserves the transaction atomicity in presence of failures.
The basic technique for implementing transactions in presence of failures is based on the use of logs.
That is, a transaction system has to record enough information to ensure that it can be able to return to a previous state in case of failure or to ensure that changes committed by a transaction are properly stored.

{parentProduct} ensures that results of a transaction are applied consistently to all resources involved in a transaction, even in the presence of failure.
To recover from failure, {parentProduct} relies on its Recovery Manager.

Basically, the Recovery Manager is a daemon process that invokes a set of well known Recovery Modules periodically in two steps; a first to determine transactions in doubt state and a second step to continue the completion of those transactions found in the first step.
Since different type of resources may be involved in a transaction, different type of Recovery Modules may exist. {parentProduct} provides several type of modules that manage resources according to their position in the transaction tree (root, subordinate, leaf) or the nature of the data itself, transactional object for java or XAResource as seen in the previous trail.

Whatever the nature of the involved resource, recovery is based on information or logs held in the Object Store, which contains specific subdirectory holding information according to the nature of the participant.

==== Running the Recovery Manager

_This section provides only brief information on running the recovery manager from provided scripts.
For complete information on the recovery manager (including how to configure it), see the {parentProduct} recovery information._

===== Windows

To run the Recovery Manager as a Windows service, simply:

* Open a command prompt
* cd to the directory <jbossts_install_root>\services\bin\windows
* Type InstallRecoveryManagerService-NT.bat

[NOTE]
This directory also contains the uninstall script which is ran in the same manner.

To launch the Recovery Manager as a Windows process, simply:

* Open a command prompt
* cd to the directory <jbossts_install_root>\services\bin\windows
* Type recoverymanagerservice.bat

===== UNIX

To launch the Recovery Manager on a Linux/UNIX platform, simply:

* Open a command prompt
* cd to the directory <jbossts_install_root>\services\bin\[platform]
* Type recoverymanagerservice.sh start

[NOTE]
====
To uninstall the recovery manager, rerun the script specifying the stop flag.
====

==== The Recovery Process and XAResources

The {parentProduct} recovery manager provides support for recovering XAResources whether or not they are Serializable.
XAResources that _do_ implement the Serializable interface are handled without requiring additional programmer defined classes.
For those XAResources that need to recover but which cannot implement Serializable, it is possible to provide a small class which is used to help recover them.

This example shows the {parentProduct} recovery manager recovering a Serializable XAResource and a non-Serializable XAResource.

===== The demo's components

The application consists of four classes.
Each class is well documented and it is recommended that the provided code is inspected to gain useful insight into some of the nuances of the recovery process.

* The code of the main class that controls the application (`src/com/arjuna/demo/recovery/xaresource/TestXAResourceRecovery.java` -> `TestRecoveryModule.java`), allows the user to specify a number of options: `[-waitForRecovery] [-useExternalRecoveryManager]`
* Programmer-defined support of the Serializable XAResource is only required in the XAResource implementation class `src/com/arjuna/demo/recovery/xaresource/ExampleXAResource.java` -> `ExampleXAResource.java`
* Programmer-defined support of the non-Serializable XAResource is required both in the XAResource implementation class `src/com/arjuna/demo/recovery/xaresource/NonSerializableExampleXAResource.java` -> `NonSerializableExampleXAResource`, and in a class that implements a helper for the {parentProduct} recovery process `src/com/arjuna/demo/recovery/xaresource/NonSerializableExampleXAResourceRecovery.java` -> `NonSerializableExampleXAResourceRecovery.java`

===== XAResourceRecovery registration

When recovering from failures, {parentProduct} requires the ability to reconnect to the resource managers that were in use prior to the failures in order to resolve any outstanding transactions.
In order to recreate those connections for non-Serializable XAResources it is necessary to provide implementations of the following {parentProduct} interface com.arjuna.ats.jta.recovery.XAResourceRecovery.

To inform the recovery system about each of the XAResourceRecovery instances, it is necessary to specify their class names through property variables in the `jbossts-properties.xml` file.
Any property variable which starts with the name XAResourceRecovery will be assumed to represent one of these instances, and its value should be the class name.

When running XA transaction recovery it is necessary to tell {parentProduct} which types of Xid it can recover.
Each Xid that {parentProduct} creates has a unique node identifier encoded within it and {parentProduct} will only recover transactions and states that match a specified node identifier.
The node identifier to use should be provided to {parentProduct} via a property that starts with the name com.arjuna.ats.jta.xaRecoveryNode (multiple values may be provided).
A value of * will force {parentProduct} to recover (and possibly rollback) all transactions irrespective of their node identifier and should be used with caution.

The recovery module for the non-Serializable XAResource must be deployed in order to provide support to recover the non-Serializable XAResource.
If this step was missed out the Serializable XAResource would recover OK but {parentProduct} would have no knowledge of the non-Serializable XAResource and so it could not recover it.
To register the non-Serializable XAResource XAResourceRecovery module, add an entry to the `jbossts-properties.xml`.

Under the element `<properties depends="jts" name="jta">`, add:

[source,xml]
----
<property name="com.arjuna.ats.jta.recovery.XAResourceRecovery1" value= "com.arjuna.demo.recovery.xaresource.NonSerializableExampleXAResourceRecovery"/>
<property name="com.arjuna.ats.jta.xaRecoveryNode" value="*"/>
----

====== Configure the recovery manager scan period

By default, the recovery manager is configured to perform a pass over resources to be recovered every two minutes.
It will then wait for ten seconds before re-checking the resources.
Although the test will run OK with this configuration, it is possible to configure the recovery manager scan times to reduce the time waiting.
To configure the intervals, edit the `jbossts-properties.xml` as follows:

* Edit the property "com.arjuna.ats.arjuna.recovery.periodicRecoveryPeriod" to change the value from 120 to 5.
* Edit the property "com.arjuna.ats.arjuna.recovery.recoveryBackoffPeriod" to change the value from 10 to 5.

====== Specify the transaction manager type to use

The recovery manager will work in the same manner for either the JTA or JTS implementation.
By default {parentProduct} is configured to use a JTS transaction manager, in order to configure it to use a JTA transaction manager a change must again be made to the `jbossts-properties.xml`.
_See "Testing JTA" for more information on how to configure the {parentProduct} transaction manager to use JTA rather than JTS._

_If you do change the transaction manager type remember to reconfigure the recovery manager as follows:_

If you are using the ArjunaCore (raw JTA) transaction manager implementation comment out the element in `jbossts-properties.xml` containing the following text:

[source,xml]
----
internal.jta.recovery.jts.XARecoveryModule
----

If you are using the JTS transaction manager implementation comment out the element in `jbossts-properties.xml` containing the following text:

[source,xml]
----
internal.jta.recovery.arjunacore.XARecoveryModule
----

====== Launching the demo

To launch the Test Recovery Module, execute the following java program

* Open a command prompt
* cd to the directory `<jbossts_install_root>\trail_map`
* Type `java com.arjuna.demo.recovery.xaresource.TestXAResourceRecovery`
* View the output noting the crash during commit.
* Inspect the current working directory to note that the applications have created several log files which you may like to review.
* Type `java com.arjuna.demo.recovery.xaresource.TestXAResourceRecovery -waitForRecovery`
* Wait for the two resources to be recovered and committed.
* Re-review the log files from the working directory, if wanted.

[NOTE]
As you can see, the Serializable XAResource does not need it's recover() method called as the transaction manager is aware of all the information about this resource.

====== The Recovery Process and AbstractRecords

_WARNING: Implementing a RecoveryModule and AbstractRecord is a very advanced feature of the transaction service.
It should only be performed by users familiar with the all the concepts used in the {parentProduct} product.
Please see the ArjunaCore guide for more information about RecoveryModules and AbstractRecords._

The following sample gives an overview how the Recovery Manager invokes a module to recover from failure.
This basic sample does not aim to present a complete process to recover from failure, but mainly to illustrate the way to implement a recovery module.
More details can be found in "Failure Recovery Guide".

The application used here consists to create an atomic transaction, to register a participant within the created transaction and finally to terminate it either by commit or abort.
A set of arguments are provided:

* to decide committing or aborting the transaction,
* to decide generating a crash during the commitment process.

*The demo's components*

The application consists of three programs

* The code of the main class that control the application (`src/com/arjuna/demo/recoverymodule/TestRecoveryModule.java` -> `TestRecoveryModule.java`), which consists to give the choice to either commit or abort the transaction and also to generate a crash.
* The registered participant (`src/com/arjuna/demo/recoverymodule/SimpleRecord.java` -> `SimpleRecord.java`) has the following behaviour:
+
- During the prepare phase, it writes a simple message - "I'm prepared" - on the disk such message is written in a well known file
- During the commit phase, it writes another message - "I'm committed" - in the same file used during prepare
- If it receives an abort message, it removes from the disk the file used for prepare if any.
- if a crash has been decided for the test, then it crashes during the commit phase - the file remains with the message "I'm prepared".

* A Recovery Module (`src/com/arjuna/demo/recoverymodule/SimpleRecoveryModule.java` -> `SimpleRecoveryModule.java`) that consists to read the content of the file used to store the status of the participant, to determine that status and print a message indicating if a recovery action is needed or not.

Using the provided {parentProduct} Recovery Modules ensures that resources are correctly recovered.
This sample illustrates how to define and register its own module.
It's the responsibility of the module to re-create the appropriate objects using information retrieved from a log.

*Recovery Module registration*

The recovery module should now be deployed in order to be called by the Recovery Manager.
To do so, we just need to add an entry in the `jbossts-properties.xml` by adding a new property as follows:

[source,xml]
----
<property name="com.arjuna.ats.arjuna.recovery.recoveryExtension<i>" value="com.arjuna.demo.recoverymodule.SimpleRecoveryModule"/>
----

Where <i> represent the new occurrence number that follows the last that already exists in the file.
Once started, the Recovery Manager will automatically load the added Recovery module.

*Starting the Recovery Manager*

In a separate window launch the Recovery Manager, as follows:

[source,shell]
----
java com.arjuna.ats.arjuna.recovery.RecoveryManager -test
----

*Launching the demo*

To launch the Test Recovery Module, execute the following java program

[source,shell]
----
java com.arjuna.demo.recoverymodule.TestRecoveryModule
  [-commit|-abort] [-crash]
----
