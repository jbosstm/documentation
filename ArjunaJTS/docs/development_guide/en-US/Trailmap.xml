<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "JBossJTS_Development_Guide.ent">
%BOOK_ENTITIES;
]>
<chapter>
    <title>Trail map</title>
    <section>
        <title>Introduction</title>
        <para>&PARENT_PRODUCT; assures complete, accurate business
  transactions for any Java based applications, including those written for the
  Java EE and EJB frameworks.</para>
        <para>&PARENT_PRODUCT; is a 100% Java implementation of a distributed transaction management system
  based on the Sun Microsystems Java EE Java Transaction Service (JTS) standard.
  Our implementation of the JTS utilizes the Object Management Group's (OMG) Object
  Transaction Service (OTS) model for transaction interoperability as recommended
  in the Java EE and EJB standards. Although any JTS-compliant product will allow
  Java objects to participate in transactions, one of the key features of &PARENT_PRODUCT;
  is it's 100% Java implementation. This allows &PARENT_PRODUCT; to support fully distributed
  transactions that can be coordinated by distributed parties.
<para>&PARENT_PRODUCT; runs can be run both as an embedded distributed service of an application
  server (e.g. &APPSERVER;), affording the user all the added benefits of the
  application server environment such as real-time load balancing, unlimited linear
  scalability and unmatched fault tolerance that allows you to deliver an always-on
  solution to your customers. It is also available as a free-standing Java Transaction
  Service.</para>
					<para>In addition to providing full compliance with the latest version of the JTS
specification, &PARENT_PRODUCT; leads the market in providing many advanced features such
as fully distributed transactions and ORB portability with POA support.</para>
					<para>&PARENT_PRODUCT; is tested on HP-UX 11i, Red Hat Linux, Windows Server 2003,
  and Sun Solaris 10, using Sun's JDK 5. It should howerver work on any system with JDK 5 or 6.</para>
					<para>The Java Transaction API support for &PARENT_PRODUCT; comes in two flavours:</para>
					<itemizedlist><listitem>a purely local implementation, that does not require an ORB, but obviously
  requires all coordinated resources to reside within the same JVM. </listitem><listitem>a fully distributed implementation. </listitem></itemizedlist>
					<para>Key features</para>
					<itemizedlist><listitem>full compliant with the JTA 1.1 specification:
    <itemizedlist><listitem>Purely local (ORB-less) JTA offers the fastest JTA performance </listitem><listitem>JDBC support </listitem><listitem>XA compliance </listitem><listitem>JDBC drivers for database access with full transaction support </listitem><listitem>Automatic crash recovery for XAResources </listitem></itemizedlist>
						</listitem><listitem>compliance with the JTS specification and OTS 1.2 specification from the
    OMG
    <itemizedlist><listitem>Distributed JTA implementation </listitem><listitem>support for distributed transactions (utilizing two-phase commit) </listitem><listitem>POA ORB support </listitem><listitem>interposition </listitem><listitem>transaction heuristics</listitem><listitem>distributed transaction manager (co-located with the transaction initiator)
        or transaction manager server </listitem><listitem>checked/unchecked transaction behaviour </listitem><listitem>supports both flat and nested transaction models, with nested-aware
        resources and resource adapters </listitem><listitem>independent concurrency control system with support for type-specific
        concurrency control </listitem><listitem>support for CosTransaction::Current </listitem><listitem>direct and indirect transaction management </listitem><listitem>synchronization interface </listitem><listitem>explicit and implicit transaction context propagation </listitem><listitem>automatic crash recovery </listitem><listitem>multi-thread aware </listitem></itemizedlist>
						</listitem><listitem>transactional objects (TO) for Java </listitem><listitem>ORB independence via the ORB portability layer </listitem></itemizedlist>
				</para>
        <para>
                    This trail map will help you get started with running &PARENT_PRODUCT; product.
                    It is structured as follows:</para>
        <itemizedlist>
            <listitem>1. Installation Content: This trail describes the content installed by the &PARENT_PRODUCT; distribution </listitem>
            <listitem>2. The Sample Application: This trail describes via a set of examples how &PARENT_PRODUCT; is used to build transactional applications</listitem>
            <listitem>3. Deploying and testing the Sample Application: This trail describes how to deploy and to test the sample application</listitem>
            <listitem>4. Making the Sample Application Persistent: This trail describes tools allowing to build a persistent application</listitem>
            <listitem>5. Recovery from Failure: This trail describes via a simple scenario how &PARENT_PRODUCT; manages recovery from failure.</listitem>
            <listitem>6. Where Next?: This trail indicates where to find additional information</listitem>
        </itemizedlist>
        <para>
					In addition to the trails listed above, a set of trails giving more explanation on concept around
					transaction processing and standards, and also a quick access to section explaining how to configure &PARENT_PRODUCT;
					are listed in the section "Additional Trails".</para>
        <para><emphasis>Note:</emphasis>When running the local JTS transactions part of the trailmap, you will need to start
the recovery manager: java com.arjuna.ats.arjuna.recovery.RecoveryManager -test</para>
    </section>
    <section><title>Overview of the X/Open DTP model</title>

				The X/Open Distributed Transaction Processing (DTP) model is a distributed
transaction processing model proposed by the Open Group, a vendor consortium.
This model is a standard among most of the commercial vendors in transaction
processing and database domains.
<para>This model consists of the follwng components (illustrated in Figure 1)</para>
				<itemizedlist><listitem>
an Application Program (AP), which defines transaction boundaries and specifies
actions that constitute a transaction</listitem><listitem>
Resource Managers (RMs) such as databases or file access systems, which
provide access to resources</listitem><listitem>
a Transaction Manager (TM), which assigns identifiers to transactions,
monitors their progress, and takes responsibility for transaction completion
and for coordinating failure recovery</listitem><listitem>
Communication Resource Managers (CRMs), which control communication between
distributed applications within or across TM domains</listitem></itemizedlist>
				<imagedata fileref="images/xopen.PNG.png" format="PNG"/>
				<para>Figure 1 - The X/Open DTP model</para>
				</section>
    <section><title> Interface between functional components</title>
There are six interfaces between software components in the X/Open DTP model.
<itemizedlist><listitem>
AP-RM. The AP-RM interfaces give the AP access to resources. X/Open interfaces,
such as SQL and ISAM provide AP portability. The X/Open DTP model imposes
few constraints on native RM APIs. The constraints involve only those native
RM interfaces that define transactions.</listitem><listitem>
AP-TM. The AP-TM interface (the TX interface) provides the AP with an Application
Programming Interface (API) by which the AP coordinates global transaction
management with the TM. For example, when the AP calls tx_begin( ) the
TM informs the participating RMs of the start of a global transaction.
After each request is completed, the TM provides a return value to the
AP reporting back the success or otherwise of the TX call.</listitem><listitem>
TM-RM. The TM-RM interface (the XA interface) lets the TM structure the
work of RMs into global transactions and coordinate completion or recovery.
The XA interface is the bidirectional interface between the TM and RM.</listitem><para>The functions that each RM provides for the TM are called the xa_*()
functions. For example the TM calls xa_start( ) in each participating
RM to start an RM-internal transaction as part of a new global transaction.
Later, the TM may call in sequence xa_end() xa_prepare( ) and xa_commit()
to coordinate a (successful in this case) two-phase commit protocol.
The functions that the TM provides for each RM are called the ax_*( ) functions.
For example an RM calls ax_reg( ) to register dynamically with the TM.</para><listitem>
TM-CRM. The TM-CRM interface (the XA+ interface) supports global transaction
information flow across TM Domains. In particular TMs can instruct CRMs
by use of xa_*() function calls to suspend or complete transaction branches,
and to propagate global transaction commitment protocols to other transaction
branches. CRMs pass information to TMs in subordinate branches by use of
ax_*( ) function calls. CRMs also use ax_*( ) function calls to request
the TM to create subordinate transaction branches, to save and retrieve
recovery information, and to inform the TM of the start and end of blocking
conditions.</listitem><listitem>
AP-CRM. X/Open provides portable APIs for DTP communication between APs
within a global transaction. The API chosen can significantly influence
(and may indeed be fundamental to) the whole architecture of the application.
For this reason, these APIs are frequently referred to in this specification
and elsewhere as communication paradigms.In practice, each paradigm has
unique strengths, so X/Open offers the following popular paradigms:</listitem><itemizedlist><listitem>
the TxRPC interface (see the referenced TxRPC specification)</listitem><listitem>
the XATMI interface (see the referenced XATMI specification)</listitem><listitem>
the CPI-C interface (see the referenced CPI-C specification).</listitem></itemizedlist>
X/Open interfaces, such as the CRM APIs listed above, provide application
portability. The X/Open DTP model imposes few constraints on native CRM
APIs.
<listitem>
CRM-OSI TP. This interface (the XAP-TP interface) provides a programming
interface between a CRM and Open Systems Interconnection Distributed Transaction
Processing (OSI TP) services. XAP-TP interfaces with the OSI TP Service
and the Presentation Layer of the seven-layer OSI model. X/Open has defined
this interface to support portable implementations of application-specific
OSI services. The use of OSI TP is mandatory for communication between
heterogeneous TM domains. For details of this interface, see the referenced
XAP-TP specification and the OSI TP standards.</listitem>
				</itemizedlist>
Although the aim of the Open Group was providing portable interfaces, only
the XA interface appears to be accepted and implemented by a wide
range of vendors.
<para>XA is a bidirectional interface between resource managers and transaction
managers. This interface specifies two sets of functions. The first set,
called as xa_*() functions are implemented by resource managers for use
by the transaction manager.</para>
				<para>Table 1 - XA Interface of X/Open DTP Model for the transaction manager</para>
				<table BORDER="" WIDTH="100%"><tr BGCOLOR="#8BD5FC"><td><emphasis>Function</emphasis></td><td><emphasis>Purpose</emphasis></td></tr><tr><td>xa_start</td><td>Directs a resource manager to associate the subsequent requests by
application programs to a transaction identified by the supplied identifier.</td></tr><tr><td>xa_end</td><td>Ends the association of a resource manager with the transaction.</td></tr><tr><td>xa_prepare</td><td>Prepares the resource manager for the commit operation. Issued by the
transaction manager in the first phase of the two-phase commit operation.</td></tr><tr><td>xa_commit</td><td>Commits the transactional operations. Issued by the transaction manager
in the second phase of the two-phase commit operation.</td></tr><tr><td>xa_recover</td><td>Retrieves a list of prepared and heuristically committed or heuristically
rolled back transactions</td></tr><tr><td>xa_forget</td><td>Forgets the heuristic transaction associated with the given transaction
identifier</td></tr></table>
				<para>The second set of functions, called as ax_*() functions, are implemented
by the transaction manager for use by resource managers.</para>
				<para>Table 2 - XA Interface of X/Open DTP Model for resource managers</para>
				<table BORDER="" WIDTH="58%"><tr BGCOLOR="#8BD5FC"><td><emphasis>Function</emphasis></td><td><emphasis>Purpose</emphasis></td></tr><tr><td>ax_reg()</td><td>Dynamically enlists with the transaction manager.</td></tr><tr><td>ax_unreg()</td><td>Dynamically delists from the transaction manager.</td></tr></table>


	</section>
    <section>
        <title>Overview of the Distributed Transaction Processing</title>
        <para>Transaction management is one of the most crucial requirements for enterprise application development. Most of the large enterprise applications
  	in the domains of finance, banking and electronic commerce rely on transaction processing for delivering their business functionality. </para>
        <para>Enterprise applications often require concurrent access to distributed data  shared amongst multiple components, to perform operations on data. Such
  applications should maintain integrity of data (as defined by the business  rules of the application) under the following circumstances: </para>
        <itemizedlist>
            <listitem>distributed access to a single resource of data, and </listitem>
            <listitem>access to distributed resources from a single application component.
   	 </listitem>
        </itemizedlist>
        <para>In such cases, it may be required that a group of operations on (distributed) resources be treated as one unit of work. In a unit of work, all
	  the participating operations should either succeed or fail and recover together. This problem is more complicated when </para>
        <itemizedlist>
            <listitem>a unit of work is implemented across a group of distributed components operating on data from multiple resources, and/or </listitem>
            <listitem>the participating operations are executed sequentially or in parallel  threads requiring coordination and/or synchronization. </listitem>
        </itemizedlist>
        <para>In either case, it is required that success or failure of a unit of work be maintained by the application. In case of a failure, all the resources should
 	 bring back the state of the data to the previous state (<emphasis>i.e.,</emphasis> the state prior to the commencement of the unit of work). </para>
        <para> From the programmer's perspective a transaction is a scoping mechanism for a collection of actions which must complete as a unit. It provides a
    simplified model for exception handling since only two outcomes are possible: </para>
        <itemizedlist>
            <listitem> success - meaning that all actions involved within a transaction are completed </listitem>
            <listitem> 	failure - no actions complete 	</listitem>
        </itemizedlist>
        <imagedata fileref="images/trans_succes_failure.PNG.png" format="PNG"/>
    </section>
    <section><title>Example</title><para>
			  		 To illustrate the reliability expected by the application let’s consider  the funds transfer example which is familiar to all of us.
					</para>

      The Money transfer involves two operations: Deposit and Withdrawal

				<para>
					The complexity of implementation doesn't matter; money moves from one place to
      another. For instance, involved accounts may be either located in a same relational table within
      a database or  located on different databases.
				</para>
				<para>
					A Simple transfer consists on moving money from savings to checking while a Complex transfer can be performed at the end- of- day according
      to a reconciliation between international banks </para>
				<imagedata fileref="images/example_transfer.PNG.png" format="PNG"/>
				<para>The concept of a transaction, and a transaction manager (or a transaction
  processing service) simplifies construction of such enterprise level
  distributed applications while maintaining integrity of data in a unit of
  work. </para>
				<para>A transaction is a unit of work that has the following properties: </para>
				<itemizedlist><listitem><emphasis>Atomicity</emphasis> – either the whole transaction completes or
    nothing completes - partial completion is not permitted. </listitem><listitem><emphasis>Consistency</emphasis> – a transaction transforms the system from
    one consistent state to another. In other words, On completion of a
    successful transaction, the data should be in a consistent state. For
    example, in the case of relational databases, a consistent transaction
    should preserve all the integrity constraints defined on the data. </listitem><listitem><emphasis>Isolation:</emphasis> Each transaction should appear to execute
    independently of other transactions that may be executing concurrently in
    the same environment. The effect of executing a set of transactions serially
    should be the same as that of running them concurrently. This requires two
    things:
    <itemizedlist><listitem>During the course of a transaction, intermediate (possibly
      inconsistent) state of the data should not be exposed to all other
      transactions. </listitem><listitem>Two concurrent transactions should not be able to operate on the same
      data. Database management systems usually implement this feature using
      locking. </listitem></itemizedlist>
					</listitem><listitem><emphasis>Durabiliy:</emphasis> The effects of a completed transaction should always
    be persistent. </listitem></itemizedlist>
				<para>These properties, called as <emphasis>ACID</emphasis> properties, guarantee that a
  transaction is never incomplete, the data is never inconsistent, concurrent
  transactions are independent, and the effects of a transaction are persistent.
  </para>
				<section><title>Transactional Concepts</title></section>
				<section><title>Transaction Components</title></section>
				<para>A collection of actions is said to be transactional if they possess the ACID properties. These properties
are assumed to be ensured, in the presence of failures; if actions involved within the transaction
are performed by a Transactional System. A transaction system includes a set of components where each of
them has a particular role. Main components are described below. </para>
				<imagedata fileref="images/transaction_components.PNG.png" format="PNG"/>
                <section><title>Application
      Programs</title><para>Application Programs are clients for the transactional resources. These
      are the programs with which the application developer implements business
      transactions. With the help of the transaction manager, these components
      create global transactions and operate on the transactional resources with
      in the scope of these transactions. These components are not responsible
      for implementing mechanisms for preserving ACID properties of
      transactions. However, as part of the application logic, these components
      generally make a decision whether to commit or rollback transactions.</para><para>Application responsibilities could be summarized as follow:</para><itemizedlist><listitem>Create and demarcate transactions </listitem><listitem>Operate on data via resource managers</listitem></itemizedlist><title>Resource
      Managers</title><para>A resource manager is in general a component that manages persistent
      and stable data storage system, and participates in the two phase commit
      and recovery protocols with the transaction manager. </para><para>A resource manager is typically a driver that provides two
      sets of interfaces: one set for the application components to get
      connections and operating, and the other set for participating in two
      phase commit and recovery protocols coordinated by a transaction manager.
      This component may also, directly or indirectly, register resources with
      the transaction manager so that the transaction manager can keep track of
      all the resources participating in a transaction. This process is called
      as resource enlistment. </para><para>Resource Manager responsibilities could be summarized as follow</para><itemizedlist><listitem>Enlist resources with the transaction manager </listitem><listitem>Participate in two-phase commit and recovery protocol </listitem></itemizedlist><title>Transaction Manager</title><para>The transaction manager is the core component of a transaction
      processing environment. Its main responsibilities are to create
      transactions when requested by application components, allow resource
      enlistment and delistment, and to manage the two-phase commit or recovery
      protocol with the resource managers. </para><para>A typical transactional application begins a transaction by issuing a
      request to a transaction manager to initiate a transaction. In response,
      the transaction manager starts a transaction and associates it with the
      calling thread. The transaction manager also establishes a transaction
      context. All application components and/or threads participating in the
      transaction share the transaction context. The thread that initially
      issued the request for beginning the transaction, or, if the transaction
      manager allows, any other thread may eventually terminate the transaction
      by issuing a commit or rollback request. </para><para>Before a transaction is terminated, any number of components and/or
      threads may perform transactional operations on any number of
      transactional resources known to the transaction manager. If allowed by
      the transaction manager, a transaction may be suspended or resumed before
      finally completing the transaction. </para><para>Once the application issues the commit request, the transaction manager
      prepares all the resources for a commit operation, and based on whether
      all resources are ready for a commit or not, issues a commit or rollback
      request to all the resources.</para><para>Resource Manager responsibilities could be summarized as follow:</para><itemizedlist><listitem>Establish and maintain transaction context </listitem><listitem>Maintain association between a transaction and the participating
        resources. </listitem><listitem>Initiate and conduct two-phase commit and recovery protocol with the
        resource managers. </listitem><listitem>Make synchronization calls to the application components before
        beginning and after end of the two-phase commit and recovery process
        </listitem></itemizedlist><section><title>Local vs. Distributed Transaction</title><para>
					 A transaction that involves only one transactional resource, such a database,
  is considered as <emphasis>local transaction</emphasis>, while a transaction that involves
  more than one transactional resource that need to be coordinated to reach a
  consistent state is considered as a <emphasis>distributed transaction.</emphasis>
				</para><para>A transaction can be specified by what is known as transaction demarcation.
  Transaction demarcation enables work done by distributed components to be
  bound by a global transaction. It is a way of marking groups of operations to
  constitute a transaction. </para><para>The most common approach to demarcation is to mark the thread executing the
  operations for transaction processing. This is called as programmatic
  demarcation. The transaction so established can be suspended by unmarking the
  thread, and be resumed later by explicitly propagating the transaction context
  from the point of suspension to the point of resumption. </para><para>The transaction demarcation ends after a commit or a rollback request to
  the transaction manager. The commit request directs all the participating
  resources managers to record the effects of the operations of the transaction
  permanently. The rollback request makes the resource managers undo the effects
  of all operations on the transaction. </para></section><section><title>Transaction Context and Propagation </title><para>Since multiple application components and resources participate in a
  transaction, it is necessary for the transaction manager to establish and
  maintain the state of the transaction as it occurs. This is usually done in
  the form of transaction context. </para><para>Transaction context is an association between the transactional operations
  on the resources, and the components invoking the operations. During the
  course of a transaction, all the threads participating in the transaction
  share the transaction context. Thus the transaction context logically envelops
  all the operations performed on transactional resources during a transaction.
  The transaction context is usually maintained transparently by the underlying
  transaction manager. </para></section><section><title>Resource Enlistment</title><para>Resource enlistment is the process by which resource managers inform the
  transaction manager of their participation in a transaction. This process
  enables the transaction manager to keep track of all the resources
  participating in a transaction. The transaction manager uses this information
  to coordinate transactional work performed by the resource managers and to
  drive two-phase and recovery protocol. At the end of a transaction (after a
  commit or rollback) the transaction manager delists the resources. </para></section><section><title>Two-Phase Commit</title><para>This protocol between the transaction manager and all the resources
  enlisted for a transaction ensures that either all the resource managers
  commit the transaction or they all abort. In this protocol, when the
  application requests for committing the transaction, the transaction manager
  issues a prepare request to all the resource managers involved. Each of these
  resources may in turn send a reply indicating whether it is ready for commit
  or not. Only The transaction manager issue a commit request to all the
  resource managers, only when all the resource managers are ready for a commit.
  Otherwise, the transaction manager issues a rollback request and the
  transaction will be rolled back. </para></section><section><title>Recovery and Logging</title><para>
	Basically, the Recovery is the mechanism which preserves the transaction atomicity in presence of failures.
	The basic technique for implementing transactions in presence of failures is based on the use of logs. That  is, a transaction system has to record enough information to ensure that
      it can be able to return to a previous state in case of failure or to  ensure that changes committed by a transaction are properly stored.
    </para><para>
      In addition to be able to store appropriate information, all participants within a distributed transaction must log similar information which allow
      them to take a same decision either to set data in their final state or in  their initial state. </para><para>		Two  techniques are in general  used to ensure transaction's atomicity. A  first technique  focuses on manipulated data, such the  Do/Undo/Redo protocol
	 (considered as a recovery mechanism in a centralized system), which allow a participant to set its data in their final values or to
      retrieve them in their initial values. A second technique relies on a distributed protocol named the two phases commit,
      ensuring that all participants involved within a distributed transaction  set their data either in their final values or in their initial values.
      In other words all participants must commit or all must rollback. </para><imagedata fileref="images/recovery_logs.PNG.png" format="PNG"/><para>
          In addition to failures we refer as centralized such system crashes,
          communication failures due for instance to network outages or message loss have to be considered during
          the recovery process of a distributed transaction.
							</para><para>
          In order to provide an efficient and optimized mechanism to deal with
          failure, modern transactional systems typically adopt a “presume
          abort” strategy, which simplifies the transaction management.
          						</para><para>
          The presumed abort strategy can be stated as «when in doubt, abort».
          With this strategy, when the recovery mechanism has no information
          about the transaction, it presumes that the transaction has been
          aborted. </para>

          A particularity of the presumed-abort assumption allows a coordinator
          to not log anything before the commit decision and the participants do
          not to log anything before they prepare. Then, any failure which
          occurs before the 2pc starts lead to abort the transaction.
          Furthermore, from a coordinator point of view any communication
          failure detected by a timeout or exception raised on sending prepare
          is considered as a negative vote which leads to abort the transaction.


          So, within a distributed transaction a coordinator or a participant
          may fail in two ways: either it crashes or it times out for a message
          it was expecting. When a coordinator or a participant crashes and
          then restarts, it uses information on stable storage to determine the
          way to perform the recovery. As we will see it the presumed-abort
          strategy enable an optimized behavior for the recovery.
				</section><section><title>Heuristic Decision</title>

          In extremely rare cases, a resource manager may choose not to wait for
          the outcome from the transaction manager. This might occur if the
          communications path was lost and was not likely to be restored for a
          very long time. Typically this
          happens as a result of human intervention and not as an arbitrary
          action of a resource manager.

          In order to release locks and make this transactions data available to
          new transactions, the resource manager makes a <emphasis>heuristic decision</emphasis>,
          i.e. it guesses the proper transaction outcome. When it does so, it
          must remember its guess until contact with the transaction manager is
          ultimately re-established.

					</section></section><section><title>Standards</title>
					      Saying that a distributed transaction can involve several distributed
      participants, means that these participant must be integrated within a
      global transaction manager which has the responsibility to ensure that all
      participants take a common decision to commit or rollback the distributed
      transaction. The key of such integration is the existence of a common
      transactional interface which is understood by all participants,
      transaction manager and resource managers such databases.
					<para>
      The importance of common interfaces between participants, as well as the
      complexity of their implementation, becomes obvious in an open systems
      environment. For this aim various distributed transaction processing
      standards have been developed by international standards organizations.
      Among these organizations, We list three of them which are mainly
      considered in the &PARENT_PRODUCT; product: </para>
				<itemizedlist><listitem>
							 The X/Open model and its successful XA interface
						</listitem><listitem>
							     The OMG with its CORBA infrastructure and the Object
        Transaction Service and finally
						</listitem><listitem>
							        The Java Community Process leaded by Sun with its 
        JTA/JTS specification
					</listitem></itemizedlist>
					      Basically these standards have proposed logical models, which divide
      transaction processing into several functions:
					<itemizedlist><listitem>
							 those assigned to the application which ties resources together in application- specific operations
							</listitem><listitem>
							those assigned to the  Resource manager which access physically to data stores
						</listitem><listitem>
							functions performed by the Transaction Manager which manages  transactions, and finally
						</listitem><listitem>
							Communication Resource Managers which allow to exchange information with other transactional domains.
						</listitem></itemizedlist>
				<imagedata fileref="images/standards.PNG.png" format="PNG"/>


	</section>

    <section><title>Overview of the OMG Object Transaction Service</title>

	Object Transaction Service (OTS) is a distributed transaction processing
service specified by the Object Management Group (OMG). This specification
extends the CORBA model and defines a set of interfaces to perform transaction
processing across multiple CORBA objects.
<para>OTS is based on the Open Group's DTP model and is designed so that
it can be implemented using a common kernel for both the OTS and Open Group
APIs. In addition to the functions defined by DTP, OTS contains enhancements
specifically designed to support the object environment. Nested transactions
and explicit propagation are two examples.</para>
				<para>The CORBA model also makes some of the functions in DTP unnecessary
so these have been consciously omitted. Static registration and the communications
resource manager are unnecessary in the CORBA environment.</para>
				<para>A key feature of OTS is its ability to share a common transaction with
XA compliant resource managers. This permits the incremental addition of
objects into an environment of existing procedural applications.</para>
				<para><imagedata fileref="images/OTS.PNG.png" format="PNG"/></para>
				<para>Figure 1 - OTS Architecture</para>
				<para>The OTS architecture, shown in Figure 1, consists of the following components:</para>
				<itemizedlist><listitem><emphasis>Transaction Client:</emphasis> A program or object that invokes operations
on transactional objects.</listitem><listitem><emphasis>Transactional Object</emphasis>: A CORBA object that encapsulates or refers
to persistent data, and whose behavior depends on whether or not its operations
are invoked during a transaction.</listitem><listitem><emphasis>Recoverable Object</emphasis>: A transactional object that directly maintains
persistent data, and participates in transaction protocols.</listitem><listitem><emphasis>Transactional Server</emphasis>: A collection of one or more transactional
objects.</listitem><listitem><emphasis>Recoverable Server:</emphasis> A collection of objects, of which at least one
of which is recoverable.</listitem><listitem><emphasis>Resource Object</emphasis>: A resource object is an object in the transaction
service that is registered for participation in the two-phase commit and
recovery protocol.</listitem></itemizedlist>
In addition to the usual transactional semantics, the CORBA OTS provides
for the following features:
<itemizedlist><listitem><emphasis>Nested Transactions</emphasis>: This allows an application to create a transaction
that is embedded in an existing transaction. In this model, multiple subtransactions
can be embedded recursively in a transaction. Subtransactions can be committed
or rolled back without committing or rolling back the parent transaction.
However, the results of a commit operation are contingent upon the commitment
of all the transaction's ancestors. The main advantage of this model is
that transactional operations can be controlled at a finer granularity.
The application will have an opportunity to correct or compensate for failures
at the subtransaction level, without actually attempting to commit the
complete parent transaction.</listitem><listitem><emphasis>Application Synchronization</emphasis>: Using the OTS synchronization protocol,
certain objects can be registered with the transaction service for notification
before the start of and the completion of the two-phase commit process.
This enables such application objects to synchronize transient state and
data stored in persistent storage.</listitem></itemizedlist>
				</section><section><title>Application programming models</title>
A client application program may use direct or indirect context management to
manage a transaction. With indirect context management, an application uses the
pseudo object called Current, provided by the Transaction Service , to associate
the transaction context with the application thread of control. In direct context
management, an application manipulates the Control object and the other objects
associated with the transaction. <para>
An object may require transactions to be either explicitly or implicitly
propagated to its operations.</para>
				<itemizedlist><listitem>
Explicit propagation means that an application propagates a transaction
context by passing objects defined by the Transaction Service as explicit
parameters. This should typically be the PropagationContext structure.</listitem><listitem>
Implicit propagation means that requests are implicitly associated with
the client's transaction; they share the client's transaction context.
It is transmitted implicitly to the objects, without direct client intervention.
Implicit propagation depends on indirect context management, since it propagates
the transaction context associated with the Current pseudo object. An object
that supports implicit propagation would not typically expect to receive
any Transaction Service object as an explicit parameter.</listitem></itemizedlist>
A client may use one or both forms of context management, and may communicate
with objects that use either method of transaction propagation. (Details
of how to enable implicit propagation were described in Section Chapter
0 and Section 0). This results in four ways in which client applications
may communicate with transactional objects:
<itemizedlist><listitem>
Direct Context Management/Explicit Propagation: the client application
directly accesses the Control object, and the other objects which describe
the state of the transaction. To propagate the transaction to an object,
the client must include the appropriate Transaction Service object as an
explicit parameter of an operation; typically this should be the PropagationContext
structure.</listitem><listitem>
Indirect Context Management/Implicit Propagation: the client application
uses operations on the Current pseudo object to create and control its
transactions. When it issues requests on transactional objects, the transaction
context associated with the current thread is implicitly propagated to
the object.</listitem><listitem>
Indirect Context Management/Explicit Propagation: for an implicit model
application to use explicit propagation, it can get access to the Control
using the get_control operation on the Current pseudo object. It can then
use a Transaction Service object as an explicit parameter to a transactional
object; for efficiency reasons this should be the PropagationContext structure,
obtained by calling get_txcontext on the appropriate Coordinator reference.
This is explicit propagation.</listitem><listitem>
Direct Context Management/Implicit Propagation: a client that accesses
the Transaction Service objects directly can use the resume pseudo object
operation to set the implicit transaction context associated with its thread.
This allows the client to invoke operations of an object that requires
implicit propagation of the transaction context.</listitem></itemizedlist>
				</section><section><title>Examples</title><itemizedlist><listitem>Indirect and Implicit
    <para>In the code fragments below, a transaction originator uses indirect context
      management and implicit transaction propagation; txn_crt is an example of
      an object supporting the Current interface. The client uses the begin operation
      to start the transaction whichbecomes implicitly associated with the originator's
      thread of control.</para>

<programlisting role="JAVA" language="Java">...
txn_crt.begin();
// should test the exceptions that might be raised
...
// the client issues requests, some of which involve
// transactional objects;
BankAccount.makeDeposit(deposit);
...
txn_crt.commit(false)
</programlisting>

						<para> The program commits the transaction associated with the client thread.
      The report_heuristics argument is set to false so no report will be made
      by the Transaction Service about possible heuristic decisions.</para>
					</listitem><listitem>Direct and Explicit
    <para>In the following example, a transaction originator uses direct context
      management and explicit transaction propagation. The client uses a factory
      object supporting the CosTransactions::TransactionFactory interface to create
      a new transaction and uses the returned Control object to retrieve the Ter
      mi nat or and Coordinator objects.</para>

<programlisting role="JAVA" language="Java">...
CosTransactions::Control ctrl;
CosTransactions::Terminator ter;
CosTransactions::Coordinator coo;
coo = TFactory.create(0);
ter = ctrl.get_terminator();
...
transactional_object.do_operation(arg, c);
...
t.commit(false);
</programlisting>

						<para> The client issues requests, some of which involve transactional objects,
      in this case explicit propagation of the context is used. The Control object
      reference is passed as an explicit parameter of the request; it is declared
      in the OMG IDL of the interface. The transaction originator uses the Terminator
      object to commit the transaction; the report_heuristics argument is set
      to false: so no report will be made by the Transaction Service about possible
      heuristic decisions.</para>
					</listitem></itemizedlist><para>The main difference between direct and indirect context management is the effect
  on the invoking thread's transaction context. If using indirect (i.e., invoking
  operations through the Current pseudo object), then the thread's transaction
  context will be modified automatically by the OTS, e.g., if begin is called
  then the thread's notion of the current transaction will be modified to the
  newly created transaction; when that is terminated, the transaction previously
  associated with the thread (if any) will be restored as the thread's context
  (assuming subtransactions are supported by the OTS implementation). However,
  if using direct management, no changes to the threads transaction context are
  performed by the OTS: the application programmer assumes responsibility for
  this. </para></section></section>
    <section><title>
OTS Interfaces</title>
Figure 2 describes the principal interfaces in the CORBA OTS specification,
with their interaction, while the Table 1 below provides more details for
each interface.
<para><imagedata fileref="images/OTS_Interfaces.PNG.png" format="PNG"/></para>
				<para>Figure 2 - OTS interfaces and their interactions</para>
				<para>Table 1 - OTS Interfaces and their role.</para><table BORDER="" WIDTH="100%"><tr BGCOLOR="#66FFFF"><td align="center"><emphasis>Interface</emphasis></td><td align="center"><emphasis>Role and operations</emphasis></td></tr><tr><td>Current</td><td><itemizedlist><listitem>
Transaction demarcation (<emphasis>begin, commit, rollback, rollback_only, set_time_out</emphasis>)</listitem><listitem>
Status of the transaction (<emphasis>get_status</emphasis>)</listitem><listitem>
Name of the transaction (g<emphasis>et_transaction_name</emphasis>)</listitem><listitem>
Transaction context (<emphasis>get_control</emphasis>)</listitem></itemizedlist></td></tr><tr><td>TransactionFactory</td><td>Explicit transaction creation
<itemizedlist><listitem>
create a transaction with its associated cooridinator (<emphasis>create</emphasis>)</listitem><listitem>
create an interposed coordinator as a subrodinator in the transaction tree
(<emphasis>recreate</emphasis>)</listitem></itemizedlist>
						</td></tr><tr><td>Control</td><td>Explicit transaction context management
<itemizedlist><listitem>
access to the transaction coordinator (<emphasis>get_coordinator</emphasis>)</listitem><listitem>
access to the transactions terminator (<emphasis>get_terminator</emphasis>)</listitem></itemizedlist>
						</td></tr><tr><td>Terminator</td><td>Commit (commit) or rollback (rollback) a transaction in a direct transaction
management mode</td></tr><tr><td>Coordinator</td><td><itemizedlist><listitem>
Status of the transaction (<emphasis>get_status, get_parent_status, get_top_level_status</emphasis>)</listitem><listitem>
Transaction information (<emphasis>is_same_transaction, is_related_transaction,
is_ancestor_transaction, is_descendant_transaction, is_top_level_transaction,
hash_transaciton, hash_top_level_transaction, get_transaction_name, get_txcontext</emphasis>)</listitem><listitem>
Resource enlistment (<emphasis>register_resource, register_subtrans_aware</emphasis>)</listitem><listitem>
Registration of synchronization objects (<emphasis>register_synchronization</emphasis>)</listitem><listitem>
Set the transaction for rollback (<emphasis>rollback_only</emphasis>)</listitem><listitem>
Create subtransactions (<emphasis>create_subtransaction</emphasis>)</listitem></itemizedlist></td></tr><tr><td>RecoveryCoordinator</td><td>Allows to coordinate recovery in case of failure (<emphasis>replay_completion</emphasis>)</td></tr><tr><td>Resource</td><td>Participation in two-phase commit and recovery protocol (<emphasis>prepare,
rollback, commit, commit_one_phase, forget</emphasis>)</td></tr><tr><td>Synchronization</td><td>Application synchronization before beginning and after completion of
two-phase commit (<emphasis>before_completion, after_completion</emphasis>)</td></tr><tr><td>SubtransactionAwareResource</td><td>Commit or rollback a subtransaction (<emphasis>commit_subtransaction, rollback_subtransaction)</emphasis>
						</td></tr><tr><td>TransactionalObject</td><td>A marker interface to be implemented by all transactional objects (no
operation defined)</td></tr></table>


	</section>
    <section>
        <title>Managing Transactions in Java EE</title>
        <section><title> JTA/JTS Architecture</title>
The Java transaction initiative consists of two specifications: Java Transaction Service (JTS) and Java Transaction API (JTA).
<para>JTS specifies the implementation of a Java transaction manager. This
transaction manager supports the JTA, using which application servers can
be built to support transactional Java applications. Internally the JTS
implements the Java mapping of the OMG OTS specifications.</para>
				<para>The JTA specifies an architecture for building transactional
application servers and defines a set of interfaces for various components
of this architecture. The components are: the application, resource managers,
and the application server, as shown in the slide.</para>
				<para>The JTS thus provides a new architecture for transactional application
servers and applications, while complying to the OMG OTS 1.1 interfaces
internally. This allows the JTA compliant applications to interoperate
with other OTS 1.1 complaint applications through the standard IIOP.</para>
				<para>
As shown in the Figure 1, in the Java transaction model, the Java application
components can conduct transactional operations on JTA compliant resources via
the JTS. The JTS acts as a layer over the OTS. The applications can therefore
initiate global transactions to include other OTS transaction managers, or participate
in global transactions initiated by other OTS compliant transaction managers.</para>
				<para><imagedata fileref="images/j2ee_1.PNG.png" format="PNG"/></para>
				<blockquote>Figure 1 - The JTA/JTS transaction model</blockquote>
				<para>The Java Transaction Service is architected around an application server and
  a transaction manager. The architecture is shown in Figure 2. </para>
				<para><imagedata fileref="images/j2ee_2.PNG.png" format="PNG"/></para>
				<blockquote>Figure 2 - The JTA/JTS Architecture</blockquote>
				<para>The JTS architecture consists of the following components:</para>
				<itemizedlist><listitem><emphasis>Transaction Manager</emphasis>: The transaction manager is the core component
of this architecture and is provided by an implementation of the JTS. It
provides interfaces to create transactions (including transaction demarcation
and propagation of transaction context), allows enlistment and delistment
of resources, provides interfaces for registering components for application
synchronization, implements the synchronization protocol, and initiates
and directs the two phase commit and recovery protocol with the resource
managers.</listitem><listitem><emphasis>Application Server</emphasis>: One of the key features of the JTS architecture
is that it allows an application server to be built on top of the transaction
service and the resources. Application developers can develop and deploy
application components onto the application server for initiating and managing
transactions. The application server can therefore abstract all transactional
semantics from the application programs.</listitem><listitem><emphasis>Application Components</emphasis>: These are the clients for the transactional
resources and implement business transactions. These are deployed on the
application server. Depending on the architecture of the application server,
these components can directly or indirectly create transactions and operate
on the transactional resources. For example, an Enterprise JavaBean (EJB)
server allows declarative transaction demarcation, in which case, the EJB
components need not directly implement the transactions. However, a Java
implementation of a CORBA OTS, requires the CORBA object to demarcate transactions
explicitly.</listitem><listitem><emphasis>Resource Manager</emphasis>: A resource manager is an X/Open XA compliant component
that manages a persistent and stable storage system, and participates in
the two phase commit and recovery protocol with the transaction manager.
The application manager also provides interfaces for the application server
and the application components to operate on the data managed by it.</listitem><listitem><emphasis>Communication Resource Manager</emphasis>: This allows the transaction manager
to participate in transactions initiated by other transaction managers.
However, the JTS specification does not specify any protocol for this communication
and assumes that an implementation of the communication resource manager
supports the CORBA OTS and GIOP specifications.</listitem></itemizedlist>
				</section>
        <section><title>Java Transaction API</title>
The JTA specification may be classified into three categories of interface
as shown in Figure 3. The Java Transaction API consists of three elements:
a high-level application transaction demarcation interface, a high-level
transaction manager interface intended for application server, and a standard
Java mapping of the X/Open XA protocol intended for transactional resource
manager.
<para><imagedata fileref="images/j2ee_3_API.PNG.png" format="PNG"/></para>
				<blockquote>Figure 3 - JTA Interfaces </blockquote>
<section><title> Transaction Manager Interfaces</title><itemizedlist><listitem> javax.transaction.Status: Defines the following flags for the status of
    a transaction:</listitem></itemizedlist><table width="89%" border="1"><tr bgcolor="#0099CC"><td width="34%"><emphasis>Flag</emphasis></td><td width="66%"><emphasis>Purpose </emphasis></td></tr><tr><td>STATUS_ACTIVE</td><td>Transaction is active (started but not prepared)</td></tr><tr><td>STATUS_COMMITTED</td><td>Transaction is committed</td></tr><tr><td>STATUS_COMMITTING</td><td>Transaction is in the process of committing.</td></tr><tr><td>STATUS_MARKED_ROLLBACK</td><td>Transaction is marked for rollback.</td></tr><tr><td>STATUS_NO_TRANSACTION</td><td>There is no transaction associated with the current Transaction, UserTransaction
      or TransactionManager objects.</td></tr><tr><td>STATUS_PREPARED</td><td>Voting phase of the two phase commit is over and the transaction is prepared.</td></tr><tr><td>STATUS_PREPARING</td><td>Transaction is in the process of preparing.</td></tr><tr><td>STATUS_ROLLEDBACK</td><td>Outcome of the transaction has been determined as rollback. It is likely
      that heuristics exists.</td></tr><tr><td>STATUS_ROLLING_BACK</td><td>Transaction is in the process of rolling back.</td></tr><tr><td>STATUS_UNKNOWN</td><td>A transaction exists but its current status can not be determined. This
      is a transient condition</td></tr></table><blockquote><para>Table 1: Transaction Status Flags</para></blockquote><para>The javax.transaction.Transaction, javax.transaction.TransactionManager, and javax.transaction.UserTransaction
interfaces provide a getStatus method that returns one of the above status flags.</para><itemizedlist><listitem>javax.transaction.Transaction:
An object of this type is created for each global transaction. This interface
provides methods for transaction completion(commit and rollback), resource
enlistment (enlistResource) and delistment (delistResource), registration
of synchronization objects (registerSynchronization), and query of status
of the transaction (getStatus).</listitem><listitem>javax.transaction.TransactionManager:
This interface is implemented by the JTS and allows an application server
to communicate with the transaction manager to demarcate transactions (begin,
commit, rollback), suspending and resuming transactions (suspend and resume),
set the transaction for rollback (setRollbackOnly), get the associated
Transaction object (getTransaction), set the transaction timeout interval
(setTransactionTimeout) and query the status of the transaction (getStatus).</listitem><listitem>javax.transaction.UserTransaction:
. This interface provides methods to begin and end transactions (begin,
commit, and rollback), set the transaction for rollback (setRollbackOnly),
set the transaction timeout interval (setTransactionTimeout), and get the
status of the transaction (getStatus). Nested transactions are not supported,
and begin throws the NotSupportedException when the calling thread is already
associated with a transaction. UserTransaction automatically associates
newly created transactions with the invoking thread.</listitem><listitem>javax.transaction.xa.Xid: This
interface is a Java mapping of the X/Open transaction identifier xid structure.
The transaction manager uses an object of this type to associate a resource
manager with a transaction.</listitem></itemizedlist></section><section><title>Resource Manager Interfaces</title><itemizedlist><listitem>javax.transaction.xa.XAResource:
This is a Java mapping of the X/Open XA interface, and is implemented by
resource managers operating with the JTS. This interface provides methods
to start (start) and end (end) work on behalf of a specified transaction,
to prepare a transaction with the current resource (prepare), to end transactions
with the current resource (commit, forget, recover, and rollback), to compare
the current resource manager with another resource manager (isSameRM),
and to get and set the transaction timeout (getTransactionTimeout, setTransactionTimeout).</listitem></itemizedlist></section><section><title>Application Interfaces</title>
The only interface that an application object could implement is the Synchronization
interface. The application components may have to implement whatever other
interfaces are mandated by a given application server.
<itemizedlist><listitem>javax.transaction.Synchronization:
An object intended to participate in a synchronization protocol with the
transaction manager should implement this interface. This mechanism is
based on the Observer pattern. This interface has two methods - beforeCompletion
and afterCompletion to be called before starting and after completing,
respectively, the two phase commit operation.</listitem></itemizedlist>
</section></section>
        <section><title>Java Transaction API - Usage</title>
This section describes the usage of the JTA for implementing various transaction
semantics. The purpose of this section is to provide conceptual guidelines
only.
<section><title>Transaction Demarcation</title>
The JTA specifies two approaches with which new global transactions can
be initiated and demarcated.
<itemizedlist><listitem>
Application Program Demarcation: The javax.transaction.UserTransaction
interface provides methods for application components to begin and end
transactions programmatically. The underlying application server should
provide a mechanism to obtain a reference to this object. The JTA specification
requires that the application servers use the JNDI for storing references
to UserTransaction objects and for lookup.</listitem><para>The application component can then use this object to begin, commit
and rollback transactions. In this approach, association between the calling
thread and the transaction, and transaction context propagation are handled
transparently by the transaction manager.</para><para>Usage:</para><programlisting role="JAVA" language="Java">
// Get a UserTransaction object
// Begin a transaction
userTransaction.begin();
// Transactional operations ...
// End the transaction
userTransaction.commit();
</programlisting><listitem> Application Server Controlled Demarcation In this approach, the javax.transaction.TransactionManager
    interface controls transaction demarcation on behalf of the application being
    managed. The transaction manager also maintains the transaction context and
    its association with the calling threads implicitly.</listitem><para>Usage</para><programlisting role="JAVA" language="Java">
// Begin a transaction
Transaction t = TransactionManager.begin();
// Transactional operations ...
// End the transaction
TransactionManager.commit();
</programlisting></itemizedlist>
</section><section><title>Resource Enlistment and Delistment</title>
Transactional resources such as database connections are typically managed by
the application server in conjunction with some resource adapter and optionally
with connection pooling optimisation. In order for an external transaction manager
to co-ordinate transactional work performed by the resource managers, the application
server must enlist and de-list the resources used in the transaction. These resources
(participants) are enlisted with the transaction so that they can be informed
when the transaction terminates, e.g., are driven through the two-phase commit
protocol. <para>
The JTA is much more closely integrated with the XA concept of resources
than the arbitrary objects. For each resource in-use by the application,
the application server invokes the enlistResource method with an XAResource
object which identifies the resource in use.</para>
				<para>The enlistment request results in the transaction manager informing
the resource manager to start associating the transaction with the work
performed through the corresponding resource. The transaction manager is
responsible for passing the appropriate flag in its XAResource.start method
call to the resource manager.</para>
				<para>The delistResource method is used to disassociate the specified resource
from the transaction context in the target object. The application server
invokes the method with the two parameters: the XAResource object that
represents the resource, and a flag to indicate whether the operation is
due to the transaction being suspended (TMSUSPEND), a portion of the work
has failed (TMFAIL), or a normal resource release by the application (TMSUCCESS).</para>
				<para>The de-list request results in the transaction manager informing the
resource manager to end the association of the transaction with the target
XAResource. The flag value allows the application server to indicate whether
it intends to come back to the same resource whereby the resource states
must be kept intact. The transaction manager passes the appropriate flag
value in its XAResource.end method call to the underlying resource manager.</para>
				<para>
The application server can enlist and delist resource managers with the transaction
manager using the javax.transaction.Transaction
interface</para>
Usage
  <para>Resource enlistment is in general done by the application server when an application
    requests it for a connection to a transactional resource.</para>
<programlisting role="JAVA" language="Java">
// ... an implementation of the application server
// Get a reference to the underlying TransactionManager object.
...
// Get the current Transaction object from the TransactionManager.
transaction = transactionManager.getTransaction();
// Get an XAResource object from a transactional resource.
...
// Create a Transaction object.
...
// Enlist the resource
transaction.enlistResource(xaResource);...
// Return the connection to the application.
...
</programlisting>
<para> Resource delistment is done similarly after the application closes connections  to transactional resources.</para>

</section><section><title>
Application Synchronization with a Transaction</title>
Using the JTS synchronization protocol, certain objects can be registered
with the transaction manager for notification before the start of and the
completion of the two-phase commit process. This enables such application
objects to synchronize transient state and data stored in persistent storage.
<para>The javax.transaction.Transaction
interface provides the <emphasis>registerSynchronization</emphasis> method to register
javax.transaction.Synchronization
objects with the transaction manager. The transaction manager then uses
the synchronization protocol and calls the beforeCompletion and afterCompletion
methods before and after the two phase commit process.</para>
				<itemizedlist><listitem>
The <emphasis>beforeCompletion</emphasis> method is called prior to the start of the
two-phase transaction complete process. This call is executed in the same
transaction context of the caller who initiates the TransactionManager.commit
or the call is executed with no transaction context if Transaction.commit
is used.</listitem><listitem>
The <emphasis>afterCompletion</emphasis> method is called after the transaction has completed.
The status of the transaction is supplied in the parameter. This method
is executed without a transaction context.</listitem></itemizedlist>
				</section><section><title>Further Reading</title><itemizedlist><listitem>JDBC and Transactions</listitem><listitem>Enterprise Java Beans and Transactions</listitem></itemizedlist></section>
   </section>
    </section>
    <section>
        <title>Managing Transactions in EJB</title>
        <section>
            <title>An Application Server Model - The Enterprise Java Beans</title>
            <section><title>EJB Overview</title>
Enterprise Java Beans (EJB) is a technology specification from Sun Microsystems
Inc. that specifies a framework for building component-based distributed
applications. As an application server framework, the EJB servers address
transaction processing, resource pooling, security, threading, persistence,
remote access, life cycle etc.
<para>The EJB framework specifies construction, deployment and invocation
of components called as enterprise beans. The EJB specification classifies
enterprise beans into two categories: entity beans and session beans. While
entity beans abstract persistent domain data, session beans provide for
session specific application logic. Both types of beans are maintained
by EJB compliant servers in what are called as containers. A container
provides the run time environment for an enterprise bean. Figure 4 shows
a simplified architecture of transaction management in EJB compliant application
servers.</para>
				<para><imagedata fileref="images/j2ee_5_ejb_model.PNG.png" format="PNG"/></para>
				<para>
Figure 4 - EJB and Transactions</para>
				<para>An enterprise bean is specified by two interfaces: the home interface and the
  remote interface. The home interface specifies how a bean can created or found.
  With the help of this interface, a client or another bean can obtain a reference
  to a bean residing in a container on an EJB server. The remote interface specifies
  application specific methods that are relevant to entity or session beans.<para>
  Clients obtain references to home interfaces of enterprise beans via the Java
  Naming and Directory Interface (JNDI) mechanism. An EJB server should provide
  a JNDI implementation for any naming and directory server. Using this reference
  to the home interface, a client can obtain a reference to the remote interface.
  The client can then access methods specified in the remote interface. The EJB
  specification specifies the Java Remote Method Invocation (RMI) as the application
  level protocol for remote method invocation. However, an implementation can
  use IIOP as the wire-level protocol.</para>
					<para>
  In Figure 5, the client first obtains a reference to the home interface, and
  then a reference to an instance of Bean A via the home interface. The same procedure
  is applicable for instance of Bean A to obtain a reference and invoke methods
  on an instance of Bean B.</para>
				</para>
</section>
            <section><title>EJB Transaction Model</title>
The EJB framework does not specify any specific transaction service (such
as the JTS) or protocol for transaction management. However, the specification
requires that the javax.transaction.UserTransaction interface of the JTS
be exposed to enterprise beans. This interface is required for programmatic
transaction demarcation as discussed in the next section.
<para>
The EJB framework allows both programmatic and declarative demarcation of transactions.
Declarative demarcation is needed for all enterprise beans deployed on the EJB.
In addition, EJB clients can also initiative and end transactions programmatically.</para>
				<para>
The container performs automatic demarcation depending on the transaction
attributes specified at the time of deploying an enterprise bean in a container.
The following attributes determine how transactions are created.</para>
				<itemizedlist><listitem><emphasis>NotSupported</emphasis>: The container invokes the bean without a global transaction
context.</listitem><listitem><emphasis>Required</emphasis>: The container invokes the bean within a global transaction
context. If the invoking thread already has a transaction context associated,
the container invokes the bean in the same context. Otherwise, the container
creates a new transaction and invokes the bean within the transaction context.</listitem><listitem><emphasis>Supports</emphasis>: The bean is transaction-ready. If the client invokes the
bean within a transaction, the bean is also invoked within the same transaction.
Otherwise, the bean is invoked without a transaction context.</listitem><listitem><emphasis>RequiresNew</emphasis>: The container invokes the bean within a new transaction
irrespective of whether the client is associated with a transaction or
not.</listitem><listitem><emphasis>Mandatory</emphasis>: The container must invoke the bean within a transaction.
The caller should always start a transaction before invoking any method
on the bean.</listitem></itemizedlist>
</section>
            <section><title>Transaction Demarcation</title>
The EJB framework supports three types of transaction demarcation.
<itemizedlist><listitem><emphasis>Declarative Demarcation</emphasis>: This is also called as <emphasis>container managed
demarcation</emphasis>. The container demarcates transactions on behalf of the
bean. The Required or RequiresNew attribute is specified in a deployment
descriptor at the time of deploying the bean on an EJB server. The bean
can use the javax.ejb.EJBContext.setRollbackOnly() method to mark the transaction
for rollback.</listitem><listitem><emphasis>Bean Managed Demarcation</emphasis>: This is similar to the client-managed
demarcation.</listitem><listitem><emphasis>Client Managed Demarcation</emphasis>: Java clients can use the javax.transaction.UserTransaction
interface to demarcate transactions programmatically.</listitem></itemizedlist>
</section>
            <section><title>Resource Enlistment</title>
Resource enlistment is automatic with EJB. The EJB containers automatically
enlists connections to EJB-aware resource managers whenever a bean obtains
a connection.

</section>
            <section><title>Application Synchronization</title>
The EJB specification provides the javax.ejb.SessionSynchronization interface
for application synchronization. When implemented by a bean, the container
calls the afterBegin, beforeCompletion and afterCompletion methods for
application synchronization during the two-phase commit process.



	</section>
        </section>
    </section>
    <section>
        <title>JDBC and Transactions</title>
        <para> Java Data Base Connectivity, provide Java programs with a way to connect to
  and use relational databases. The JDBC API lets you invoke SQL commands from
  Java programming language methods. In simplest terms, JDBC allows to do three
  things</para>
        <itemizedlist>
            <listitem>Establish a connection with a database </listitem>
            <listitem>Send SQL statements </listitem>
            <listitem>Process the results </listitem>
        </itemizedlist>
        <para>The following code fragment gives a simple example of these three steps:</para>
        <programlisting role="JAVA" language="Java">
Connection con = DriverManager.getConnection(
  "jdbc:myDriver:wombat", "myLogin", "myPassword");
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery("SELECT a, b, c FROM Table1");
while (rs.next()) {
  int x = rs.getInt("a");
  String s = rs.getString("b");
  float f = rs.getFloat("c");
}
</programlisting>
        <para>Before the version 2.0 of JDBC, only local transactions controlled by the transaction
  manager of the DBMS is possible. To code a JDBC transaction, you invoke the
  commit and rollback methods of the java.sql.Connection interface. The beginning
  of a transaction is implicit. A transaction begins with the first SQL statement
  that follows the most recent commit, rollback, or connect statement. (This rule
  is generally true, but may vary with DBMS vendor.). The following example illustrates
  how transactions are managed by the JDBC API.</para>
        <programlisting role="JAVA" language="Java">
public void withdraw (double amount) {
  try {
    //A connection opened with JDBC is an AUTO COMMIT mode meaning
    // that the commitment is automatically performed when the connection
    // is closed
    //setAutoCommit to false disable this feature
    connection.setAutoCommit(false);
    //perform an SQL update to Withdraw money from account
    connection.commit();
  } catch (Exception ex) {
      try {
         connection.rollback();
          throw new Exception("Transaction failed: " +  ex.getMessage());
      } catch (Exception sqx) {
           throw new Exception(...}
      }
  }
}</programlisting>
        <para>From the version 2.0, a JDBC driver can be involved within a distributed transaction
  since it supports the XAResource interface that allows to participate to the
  2PC protocol. An application that need to include more than one database can
  create a JTA transaction. To demarcate a JTA transaction, the application program
  invokes the begin, commit, and rollback methods of the javax.transaction.UserTransaction
  interface. The following code, that can be applied to a bean-managed transaction,
  demonstrates the UserTransaction methods. The begin and commit invocations delimit
  the updates to the database. If the updates fail, the code invokes the rollback
  method and throws an Exception. </para>
        <programlisting role="JAVA" language="Java">
public void transfer(double amount) {
  UserTransaction ut = context.getUserTransaction();

  try {
     ut.begin();
     // Perform SQL command to debit account 1
     // Perform SQL command to debit account 2
     ut.commit();
   } catch (Exception ex) {
        try {
          ut.rollback();
        } catch (Exception ex1) {
             throw new Exception ("Rollback failed: " + ex1.getMessage());
        }
        throw new Exception ("Transaction failed: " + ex.getMessage());
   }
}
</programlisting>
    </section>
    <section>
        <title>Configuring the &PARENT_PRODUCT;</title>
        <para>This trail provides information on the way to configure environmental variables
  needed to define the behaviour of transactional applications managed with &PARENT_PRODUCT;.
  Basically, the behaviour of the &PARENT_PRODUCT; product is configurable through property
  attributes. Although these property attributes may be specified as command line
  arguments, it is more convenient to organise and initialise them through properties
  files. </para>
        <section>
            <title>Properties File</title>
            <para> The properties file named jbossts-properties.xml
    and located under the &lt;ats_installation_directory&gt;/etc
   directory is organised as a collection of property names. </para>
            <blockquote>
                <programlisting role="JAVA" language="Java">
&lt;property&gt;
  name="a_name"
  value="a_value"
&lt;/property&gt;
</programlisting>
            </blockquote>
            <para>Some properties must be specified by the developer while others do not need
  to be defined and can be used with their default values. Basically the properties
  file that does not provide default values to all its properties is the jbossts-properties.xml.</para>
            <para>The following table describes some properties in the jbossts-properties.xml, where:</para>
            <itemizedlist>
                <listitem><emphasis>Name</emphasis> : indicates the name of the property</listitem>
                <listitem><emphasis>Description</emphasis>: explain the aim of the property</listitem>
                <listitem><emphasis>Possible Value</emphasis>: indicates possible value the property can have</listitem>
                <listitem><emphasis>Default</emphasis><emphasis>Value</emphasis>: shows the default value, if any,
    assigned to the property</listitem>
            </itemizedlist>
            <table BORDER="" WIDTH="100%">
                <tr ALIGN="CENTER" VALIGN="CENTER" BGCOLOR="#8BD5FC">
                    <td width="38%">
                        <emphasis>Name</emphasis>
                    </td>
                    <td width="25%">
                        <emphasis>Description</emphasis>
                    </td>
                    <td width="10%">
                        <emphasis>Possible Value</emphasis>
                    </td>
                    <td width="27%">
                        <emphasis>Default Value</emphasis>
                    </td>
                </tr>
                <tr>
                    <td>com.arjuna.ats.arjuna.objectstore.localOSRoot</td>
                    <td>By default, all object states will be stored within the "defaultStore"
      subdirectory of the object store root. However, this subdirectory can be
      changed by setting the localOSRoot property variable accordingly</td>
                    <td>Directory name</td>
                    <td>defaultStore</td>
                </tr>
                <tr>
                    <td>com.arjuna.ats.arjuna.objectstore.objectStoreDir</td>
                    <td>Specify the location of the ObjectStore</td>
                    <td>Directory name</td>
                    <td>PutObjectStoreDirHere</td>
                </tr>
                <tr>
                    <td>com.arjuna.ats.arjuna.common.varDir</td>
                    <td>&PARENT_PRODUCT; needs to be able to write temporary files to a well known location
      during execution. By default this location is var. However, by setting the
      varDir property variable this can be overridden.</td>
                    <td>Directory name</td>
                    <td>var/tmp</td>
                </tr>
            </table>
        </section>
        <section><title>ObjectStore management</title>
The &PARENT_PRODUCT; layer requires an object store for transaction management logs. Within
the transaction service installation, object store is updated regularly whenever
transactions are created, or when Transactional Objects for Java is used. In a
failure free environment, the only object states which should reside within the
object store are those representing objects created with the Transactional Objects
for Java API. However, if failures occur, transaction logs may remain in the object
store until crash recovery facilities have resolved the transactions they represent.
As such it is very important that the contents of the object store are not deleted
without due care and attention, as this will make it impossible to resolve in
doubt transactions. In addition, if multiple users share the same object store
it is important that they realise this and do not simply delete the contents of
the object store assuming it is an exclusive resource.
<para> The location of the ObjectStore is specified in via the properrty com.arjuna.ats.arjuna.objectstore.objectStoreDir
  that can be passed with the java flag "-D". For convenience this property
  is defined in the properties file jbossts-properties.xml, and its value is set
  during the &PARENT_PRODUCT; installation. At any time, the location of the ObjectStore
  may be changed.</para>
</section>
        <section><title>Configuring Output</title><para>Sometimes it is desirable, mainly in case of debugging, to have some form of
  output during execution to trace internal actions performed. &PARENT_PRODUCT; uses the
  logging tracing mechanism provided by the Arjuna Common Logging Framework (CLF)
  version 2.4, which provides a high level interface that hides differences that
  exist between logging APIs such Jakarta log4j, JDK 1.4 logging API or dotnet
  logging API.</para><para>With the CLF applications make logging calls on commonLogger objects. These
  commonLogger objects pass log messages to Handler for publication. Both commonLoggers
  and Handlers may use logging Levels to decide if they are interested in a particular
  log message. Each log message has an associated log Level, that gives the importance
  and urgency of a log message. The set of possible Log Levels are DEBUG, INFO,
  WARN, ERROR and FATAL. Defined Levels are ordered according to their integer
  values as follows: DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL. </para><para> The CLF provides an extension to filter logging messages according to finer
  granularity an application may define. That is, when a log message is provided
  to the commonLogger with the DEBUG level, additional conditions can be specified
  to determine if the log message is enabled or not. </para><emphasis>Note</emphasis>: These conditions are applied if and only the DEBUG level is enabled
  and the log request performed by the application specifies debugging granularity.
  <para>
  When enabled, Debugging is filtered conditionally on three variables: </para><itemizedlist><listitem> Debugging level: this is where the log request with the DEBUG Level is
    generated from, e.g., constructors or basic methods.</listitem><listitem> Visibility level: the visibility of the constructor, method, etc. that
    generates the debugging.</listitem><listitem> Facility code: for instance the package or sub-module within which debugging
    is generated, e.g., the object store.</listitem></itemizedlist><para>According to these variables the Common Logging Framework defines three interfaces.
  A particular product may implement its own classes according to its own finer
  granularity. &PARENT_PRODUCT; uses the default Debugging level and the default Visibility
  level provided by CLF, but it defines its own Facility Code. &PARENT_PRODUCT; uses
  the default level assigned to its commonLoggers objects (DEBUG). However, it
  uses the finer debugging features to disable or enable debug messages. Finer
  values used by the &PARENT_PRODUCT; are defined below:
</para><itemizedlist><listitem>Debugging level – &PARENT_PRODUCT; uses the default values defined in the class
    com.arjuna.common.util.logging.CommonDebugLevel </listitem></itemizedlist><table width="83%" border="1"><tr bgcolor="#8BD5FC"><td width="33%"><emphasis>Debug Level</emphasis></td><td width="24%"><emphasis>Value</emphasis></td><td width="43%"><emphasis>Description</emphasis></td></tr><tr><td>NO_DEBUGGING</td><td>0x0000</td><td>A commonLogger object assigned with this values discard all debug requests</td></tr><tr><td>CONSTRUCTORS</td><td> 0x0001</td><td>Diagnostics from constructors</td></tr><tr><td>DESTRUCTORS</td><td>0x0002</td><td>Diagnostics from finalizers.</td></tr><tr><td>CONSTRUCT_AND_DESTRUCT</td><td>CONSTRUCTORS | DESTRUCTORS</td><td>Diagnostics from constructors and finalizers</td></tr><tr><td>FUNCTIONS</td><td>0x010</td><td>Diagnostics from functions</td></tr><tr><td>OPERATORS</td><td>0x020</td><td>Diagnostics from operators, such as equals</td></tr><tr><td>FUNCS_AND_OPS</td><td>FUNCTIONS | OPERATORS</td><td>Diagnostics from functions and operations.</td></tr><tr><td>ALL_NON_TRIVIAL</td><td>CONSTRUCT_AND_DESTRUCT | FUNCTIONS
      | OPERATORS</td><td>Diagnostics from all non-trivial operations</td></tr><tr><td>TRIVIAL_FUNCS</td><td>0x0100</td><td>Diagnostics from trivial functions.</td></tr><tr><td>TRIVIAL_OPERATORS:</td><td>0x0200</td><td>Diagnostics from trivial operations, and operators.</td></tr><tr><td> ALL_TRIVIAL</td><td>TRIVIAL_FUNCS | TRIVIAL_OPERATORS</td><td>Diagnostics from all trivial operations</td></tr><tr><td>FULL_DEBUGGING</td><td>0xffff</td><td>Full diagnostics.</td></tr></table><itemizedlist><listitem>Visibility level – &PARENT_PRODUCT; uses the default values defined in the class
    com.arjuna.common.util.logging.CommonVisibilityLevel </listitem></itemizedlist><table width="83%" border="1"><tr bgcolor="#8BD5FC"><td width="33%"><emphasis>Debug Level</emphasis></td><td width="24%"><emphasis>Value</emphasis></td><td width="43%"><emphasis>Description</emphasis></td></tr><tr><td>VIS_NONE</td><td>0x0000</td><td>No Diagnostic</td></tr><tr><td>VIS_PRIVATE</td><td>0x0001</td><td>only from private methods.</td></tr><tr><td>VIS_PROTECTED</td><td>0x0002</td><td>only from protected methods.</td></tr><tr><td>VIS_PUBLIC</td><td>0x0004</td><td>only from public methods.</td></tr><tr><td>VIS_PACKAGE</td><td>0x0008</td><td>only from package methods.</td></tr><tr><td>VIS_ALL</td><td>0xffff</td><td>Full Diagnostic</td></tr></table><itemizedlist><listitem>Facility Code – &PARENT_PRODUCT; uses the following values </listitem></itemizedlist><table width="83%" border="1"><tr bgcolor="#8BD5FC"><td><emphasis>Facility Code Level </emphasis></td><td><emphasis>Value</emphasis></td><td><emphasis>Description</emphasis></td></tr><tr><td>FAC_ATOMIC_ACTION</td><td>0x00000001</td><td>atomic action core module</td></tr><tr><td>FAC_BUFFER_MAN</td><td>0x00000004</td><td>state management (buffer) classes</td></tr><tr><td>FAC_ABSTRACT_REC</td><td>0x00000008</td><td>abstract records</td></tr><tr><td>FAC_OBJECT_STORE</td><td>0x00000010</td><td>object store implementations</td></tr><tr><td> FAC_STATE_MAN</td><td>0x00000020</td><td>state management and StateManager)</td></tr><tr><td>FAC_SHMEM</td><td>0x00000040 </td><td>shared memory implementation classes</td></tr><tr><td>FAC_GENERAL</td><td>0x00000080</td><td>general classes</td></tr><tr><td>FAC_CRASH_RECOVERY</td><td>0x00000800</td><td>detailed trace of crash recovery module and classes</td></tr><tr><td>FAC_THREADING</td><td>0x00002000</td><td>threading classes</td></tr><tr><td>FAC_JDBC</td><td>0x00008000</td><td>JDBC 1.0 and 2.0 support</td></tr><tr><td>FAC_RECOVERY_NORMAL</td><td>0x00040000</td><td>normal output for crash recovery manager</td></tr></table><para>To ensure appropriate output, it is necessary to set some of the finer debug
  properties explicitly as follows:</para><programlisting role="JAVA" language="Java"> &lt;properties&gt;
   &lt;!-- CLF 2.4 properties --&gt;
   &lt;property
     name="com.arjuna.common.util.logging.DebugLevel"
     value="0x00000000"/&gt;
   &lt;property
     name="com.arjuna.common.util.logging.FacilityLevel"
     value="0xffffffff"/&gt;
   &lt;property
     name="com.arjuna.common.util.logging.VisibilityLevel"
     value="0xffffffff"/&gt;
   &lt;property
     name="com.arjuna.common.util.logger"
     value="log4j"/&gt;
 &lt;/properties&gt;</programlisting><para>By default, debugging messages are not enabled since the DebugLevel is set
  to NO_DEBUGGING (0x00000000).
  You can enable debugging by providing one of the appropriate value listed above
  - for instance with you wish to see all internal actions performed by the RecoveryManager
  to recover transactions from a failure set the DebugLevel to FULL_DEBUGGING
  (0xffffffff) and the FacilityCode
  Level FAC_CRASH_RECOVERY. </para><para><emphasis>Note</emphasis>: To enable finger debug messages, the logging level should
  be set to the DEBUG level as described below.</para><para>From the program point of view a same API is used whatever the underlying logging
  mechanism, but from a configuration point of view is that the user is totally
  responsible for the configuration of the underlying logging system. Hence, the
  properties of the underlying log system are configured in a manner specific
  to that log system, e.g., a log4j.properties file in the case that log4j logging
  is used. To set the logging level to the DEBUG value, the log4j.properties file
  can be edited to set that value. </para><para>The property com.arjuna.common.util.logger
  allows to select the underlying logging system. Possible value are listed in
  the following table.</para><table width="93%" border="1"><tr bgcolor="#8BD5FC"><td width="14%"><emphasis>Property Value</emphasis></td><td width="86%"><emphasis>Description</emphasis></td></tr><tr><td>log4j</td><td>Log4j logging (log4j classes must be available in the classpath); configuration
      through the log4j.properties file, which is picked up from the CLASSPATH
      or given through a System property: log4j.configuration
						</td></tr><tr><td>jdk14</td><td>JDK 1.4 logging API (only supported on JVMs of version 1.4 or higher).
      Configuration is done through a file logging.properties in the jre/lib directory.</td></tr><tr><td>simple</td><td>Selects the simple JDK 1.1 compatible console-based logger provided by
      Jakarta Commons Logging</td></tr><tr><td>csf</td><td>Selects CSF-based logging (CSF embeddor must be available)</td></tr><tr><td>jakarta</td><td>Uses the default log system selection algorithm of the Jakarta Commons
      Logging framework</td></tr><tr><td>dotnet</td><td>Selects a .net logging implementation
        <para>
      Since a dotnet logger is not currently implemented, this is currently identical
      to simple. Simple is a purely
      JDK1.1 console-based log implementation.        </para></td></tr><tr><td>avalon</td><td>Uses the Avalon Logkit implementation</td></tr><tr><td>noop</td><td>Disables all logging </td></tr></table></section>
    </section>
    <section>
        <title>ORB Portability</title>
        <section>
            <title>Introduction</title>
            <para>Many ORBs currently in use support different versions of CORBA and/or the Java
  language mapping.<para>
  &PARENT_PRODUCT; only supports the new Portable Object Adapter
  (POA) architecture described in the CORBA 2.3 specification as a replacement
  for the Basic Object Adapter (BOA). Unlike the BOA, which was weakly specified
  and led to a number of different (and often conflicting) implementations, the
  POA was deliberately designed to reduce the differences between ORB implementations,
  and thus minimise the amount of re-coding that would need to be done when porting
  applications from one ORB to another. However, there is still scope for slight
  differences between ORB implementations, notably in the area of threading. Note,
  instead of talking about the POA, this manual will consider the Object Adapter</para>
  (OA).</para>
            <para>Because &PARENT_PRODUCT; must be able to run on a number of different
  ORBs, we have developed an ORB portability interface which allows entire applications
  to be moved between ORBs with little or no modifications. This portability interface
  is available to the application programmer in the form of several Java classes.
</para>
        </section>
        <section>
            <title>The ORB Portability API</title>
        </section>
        <section>
            <title>Using the ORB </title>
            <para>The ORB class provided in the package com.arjuna.orbportability.ORB shown below
  provides a uniform way of using the ORB. There are methods for obtaining a reference
  to the ORB, and for placing the application into a mode where it listens for
  incoming connections. There are also methods for registering application specific
  classes to be invoked before or after ORB initialisation. </para>
            <programlisting role="JAVA" language="Java">
public class ORB
{
   public static ORB getInstance(String uniqueId);
   // given the various parameters,this method initialises the ORB and
   // retains a reference to it within the ORB class.
   public synchronized void initORB () throws SystemException;
   public synchronized void initORB (Applet a, Properties p)
        throws SystemException;
   public synchronized void initORB (String[] s, Properties p)
        throws SystemException;

  //The orb method returns a reference to the ORB.
  //After shutdown is called this reference may be null.
   public synchronized org.omg.CORBA.ORB orb ();
   public synchronized boolean setOrb (org.omg.CORBA.ORB theORB);
   // If supported, this method cleanly shuts down the ORB.
   // Any pre- and post- ORB shutdown classes which
   //have been registered will also be called.
   public synchronized void shutdown ();

  public synchronized boolean addAttribute (Attribute p);
  public synchronized void addPreShutdown (PreShutdown c);
  public synchronized void addPostShutdown (PostShutdown c);

  public synchronized void destroy () throws SystemException;
  //these methods place the ORB into a listening mode,
  //where it waits for incoming invocations.
   public void run ();
   public void run (String name);
};
</programlisting>
            <para>Note, some of the methods are not supported on all ORBs, and in this situation,
  a suitable exception will be thrown. The ORB class is a factory class which
  has no public constructor. To create an instance of an ORB you must call the
  getInstance method passing a unique name as a parameter. If this unique name
  has not been passed in a previous call to getInstance you will be returned a
  new ORB instance. Two invocations of getInstance made with the same unique name,
  within the same JVM, will return the same ORB instance. </para>
        </section>
        <section>
            <title>Using the Object Adapater (OA)</title>
            <para>The OA classes shown below provide a uniform way of using Object Adapters (OA).
  There are methods for obtaining a reference to the OA. There are also methods
  for registering application specific classes to be invoked before or after OA
  initialisation. Note, some of the methods are not supported on all ORBs, and
  in this situation, a suitable exception will be thrown. The OA class is an abstract
  class and provides the basic interface to an Object Adapter. It has two sub-classes
  RootOA and ChildOA, these classes expose the interfaces specific to the root
  Object Adapter and a child Object Adapter respectively. From the RootOA you
  can obtain a reference to the RootOA for a given ORB by using the static method
  getRootOA. To create a ChildOA instance use the createPOA method on the RootOA.</para>
            <para>As described below, the OA class and its sub-classes provide most operations
  provided by the POA as specified in the POA specification. </para>
            <programlisting role="JAVA" language="Java">
public abstract class OA
{
  public synchronized static RootOA getRootOA(ORB associatedORB);
  public synchronized void initPOA () throws SystemException;
  public synchronized void initPOA (String[] args) throws SystemException;
  public synchronized void initOA () throws SystemException;
  public synchronized void initOA (String[] args) throws SystemException;
  public synchronized ChildOA createPOA (String adapterName,
      PolicyList policies) throws AdapterAlreadyExists, InvalidPolicy;
  public synchronized org.omg.PortableServer.POA rootPoa ();
  public synchronized boolean setPoa (org.omg.PortableServer.POA thePOA);
  public synchronized org.omg.PortableServer.POA poa (String adapterName);
  public synchronized boolean setPoa (String adapterName,
     org.omg.PortableServer.POA thePOA);
  ...
};

public class RootOA extends OA
{
  public synchronized void destroy() throws SystemException;
  public org.omg.CORBA.Object corbaReference (Servant obj);
  public boolean objectIsReady (Servant obj, byte[] id);
  public boolean objectIsReady (Servant obj);
  public boolean shutdownObject (org.omg.CORBA.Object obj);
  public boolean shutdownObject (Servant obj);
};

public class ChildOA extends OA
{
  public synchronized boolean setRootPoa (POA thePOA);
  public synchronized void destroy() throws SystemException;
  public org.omg.CORBA.Object corbaReference (Servant obj);
  public boolean objectIsReady (Servant obj, byte[] id)
      throws SystemException;
  public boolean objectIsReady (Servant obj) throws SystemException;
  public boolean shutdownObject (org.omg.CORBA.Object obj);
  public boolean shutdownObject (Servant obj);
};
</programlisting>
        </section>
        <section>
            <title>Example</title>
            <para>The following example illustrates how to use the ORB Portability API to create
</para>
            <programlisting role="JAVA" language="Java">
import com.arjuna.orbportability.ORB;
import com.arjuna.orbportability.OA;

public static void main(String[] args)
{
    try
    {
     // Create an ORB instance
     ORB orb = ORB.getInstance("orb_test");
     OA oa = OA.getRootOA( orb );  // Get the root POA
     orb.initORB(args, null); // Initialize the ORB
     oa.initOA(args);  // Initialize the OA
     // Do Work
     oa.destroy(); // destroy the OA
     orb.shutdown();  // Shutdown the ORB
    }
    catch(Exception e) {}
};
</programlisting>
        </section>
        <section>
            <title>Specifying the ORB to use</title>
            <para> If using such a JDK (from its version 1.2.2) in conjunction with another ORB
  it is necessary to tell the JVM which ORB to use. This happens by specifying
  the org.omg.CORBA.ORBClass and
  org.omg.CORBA.ORBSingletonClass properties.
  If used, ORB Portability classes will ensure that these properties are automatically
  set when required, i.e., during ORB initialisation. </para>
            <para>The ORB portability library attempts to detect which ORB is in use, it does
  this by looking for the ORB implementation class for each ORB it supports. This
  means that if there are classes for more than one ORB in the classpath the wrong
  ORB can be detected. Therefore it is best to only have one ORB in your classpath.
  If it is necessary to have multiple ORBs in the classpath then the property
  com.arjuna.orbportability.orbImplementation
  must be set to the value specified in the table below.</para>
            <table width="75%" border="1">
                <tr bgcolor="#8BD5FC">
                    <td width="22%">
                        <emphasis>ORB</emphasis>
                    </td>
                    <td width="78%">
                        <emphasis>Property Value</emphasis>
                    </td>
                </tr>
                <tr>
                    <td>JacORB v2.0</td>
                    <td>com.arjuna.orbportability.internal.orbspecific.jacorb.orb.implementations.jacorb_2_0</td>
                </tr>
            </table>
            <para>For additional details on the features provided by the ORB Portability API
  refer to the documentation provided by the &PARENT_PRODUCT; distribution.</para>
        </section>
        <section>
            <title>&PARENT_PRODUCT; Failure Recovery</title>
            <para>The failure recovery subsystem of &PARENT_PRODUCT; will ensure that results of
a transaction are applied consistently to all resources affected by the
transaction, even if any of the application processes or the machine hosting
them crash or lose network connectivity. In the case of machine (system)
crash or network failure, the recovery will not take place until the system
or network are restored, but the original application does not need to
be restarted recovery responsibility is delegated to the Recovery Manager
process (see below). Recovery after failure requires that information about
the transaction and the resources involved survives the failure and is
accessible afterward: this information is held in the ActionStore, which
is part of the ObjectStore. If the ObjectStore is destroyed or modified,
recovery may not be possible.
<para>Until the recovery procedures are complete, resources affected by a
transaction that was in progress at the time of the failure may be inaccessible.
For database resources, this may be reported as tables or rows held by
"in-doubt transactions". </para>
				</para>
        </section>
        <section><title>The Recovery Manager</title>
The Recovery Manager is a daemon process responsible for performing crash
recovery. Only one Recovery Manager runs per node. The Object Store provides
persistent data storage for transactions to log data. During normal transaction
processing each transaction will log persistent data needed for the commit
phase to the Object Store. On successfully committing a transaction this
data is removed, however if the transaction fails then this data remains
within the Object Store.
<para>The Recovery Manager functions by:</para>
				<itemizedlist><listitem>
Periodically scanning the Object Store for transactions that may have failed.
Failed transactions are indicated by the presence of log data after a period
of time that the transaction would have normally been expected to finish.</listitem><listitem>
Checking with the application process which originated the transaction
whether the transaction is still in progress or not.</listitem><listitem>
Recovering the transaction by re-activating the transaction and then replaying
phase two of the commit protocol.</listitem></itemizedlist>
To start the Recovery Manager issue the following command:

<programlisting role="JAVA" language="Java">
java com.arjuna.ats.arjuna.recovery.RecoveryManager
</programlisting>

If the -test flag is used with the Recovery Manager then it will display a "Ready" message when initialised, i.e.,

<programlisting role="JAVA" language="Java">
java com.arjuna.ats.arjuna.recovery.RecoveryManager -test
</programlisting>

On initialization the Recovery Manager first loads in configuration information
via a properties file. This configuration includes a number of recovery
activators and recovery modules, which are then dynamically loaded.
<para>Each recovery activator, which implements the
com.arjuna.ats.arjuna.recovery.RecoveryActivator
interface, is used to instantiate a recovery class related to the underlying
communication protocol. Indeed, since the version 3.0 of &PARENT_PRODUCT;, the
Recovery Manager is not specifically tied to an Object Request Broker or
ORB, which is to specify a recovery instance able to manage the OTS recovery
protocol the new interface RecoveryActivator is provided to identify specific
transaction protocol. For instance, when used with OTS, the RecoveryActivitor
has the responsibility to create a RecoveryCoordinator object able to respond
to the replay_completion operation.</para>
				<para>
All RecoveryActivator instances inherit the same interface. They are loaded via
the following recovery extension property:
</para>
				<programlisting role="JAVA" language="Java">
&lt;property
  name="com.arjuna.ats.arjuna.recovery.recoveryActivator_&lt;number&gt;"
  value="RecoveryClass"/&gt;
</programlisting>
				<para>For instance the RecoveryActivator provided in the distribution of JTS/OTS,   which shall not be commented, is as follow : </para>
				<programlisting role="JAVA" language="Java">
&lt;property
  name="com.arjuna.ats.arjuna.recovery.recoveryActivator_1"
  value="com.arjuna.ats.internal.jts.
     orbspecific.recovery.RecoveryEnablement"/&gt;
</programlisting>
Each recovery module, which implements the com.arjuna.ats.arjuna.recovery.RecoveryModule
interface, is used to recover a different type of transaction/resource,
however each recovery module inherits the same basic behaviour.
<para>Recovery consists of two separate passes/phases separated by two timeout
periods. The first pass examines the object store for potentially failed
transactions; the second pass performs crash recovery on failed transactions.
The timeout between the first and second pass is known as the backoff period.
The timeout between the end of the second pass and the start of the first
pass is the recovery period. The recovery period is larger than the backoff
period.</para>
				<para>The Recovery Manager invokes the first pass upon each recovery module,
applies the backoff period timeout, invokes the second pass upon each recovery
module and finally applies the recovery period timeout before restarting
the first pass again.</para>
				<para>The recovery modules are loaded via the following recovery extension property:</para>
				<programlisting role="JAVA" language="Java">
com.arjuna.ats.arjuna.recovery.recoveryExtension&lt;number&gt;=&lt;RecoveryClass&gt;
</programlisting>
The default RecoveryExtension settings are:

<programlisting role="JAVA" language="Java">
&lt;property name="com.arjuna.ats.arjuna.recovery.recoveryExtension1"
  value="com.arjuna.ats.internal.
     arjuna.recovery.AtomicActionRecoveryModule"/&gt;
&lt;property name="com.arjuna.ats.arjuna.recovery.recoveryExtension2"
  value="com.arjuna.ats.internal.
     txoj.recovery.TORecoveryModule"/&gt;
&lt;property name="com.arjuna.ats.arjuna.recovery.recoveryExtension3"
  value="com.arjuna.ats.internal.
     jts.recovery.transactions.TopLevelTransactionRecoveryModule"/&gt;
&lt;property  name="com.arjuna.ats.arjuna.recovery.recoveryExtension4"
  value="com.arjuna.ats.internal.
     jts.recovery.transactions.ServerTransactionRecoveryModule"/&gt;
</programlisting>
</section>
        <section>
            <title>Configuring the Recovery Manager</title>
        </section>
        <section><title>Periodic Recovery</title>
The backoff period and recovery period are set using the following properties:

<programlisting role="JAVA" language="Java">
com.arjuna.ats.arjuna.recovery.recoveryBackoffPeriod (default 10 secs)
com.arjuna.ats.arjuna.recovery.periodicRecovery (default 120 secs)
</programlisting>
				</section>
        <section><title>Expired entry removal</title>
The operation of the recovery subsystem will cause some entries to be made
in the ObjectStore that will not be removed in normal progress. The RecoveryManager
has a facility for scanning for these and removing items that are very
old. Scans and removals are performed by implementations of the com.arjuna.ats.arjuna.recovery.ExpiryScanner.
Implementations of this interface are loaded by giving the class name as
the value of a property whose name begins with ExperyScanner.
<para>The RecoveryManager calls the scan() method on each loaded ExpiryScanner
implementation at an interval determined by the property com.arjuna.ats.arjuna.recovery.expiryScanInterval.
This value is given in hours default is 12. An EXPIRY_SCAN_INTERVAL value
of zero will suppress any expiry scanning. If the value as supplied is
positive, the first scan is performed when RecoveryManager starts; if the
value is negative, the first scan is delayed until after the first interval
(using the absolute value)</para>
				<para>The default ExpiryScanner is:</para>
				<programlisting role="JAVA" language="Java">
&lt;property
  name="com.arjuna.ats.arjuna.recovery.
        expiryScannerTransactionStatusManager"
  value="com.arjuna.ats.internal.arjuna.recovery.
       ExpiredTransactionStatusManagerScanner"/&gt;
 </programlisting>
				<para>The following table summarize properties used by the Recovery Manager. These
  properties are defined by default the properties file named RecoveryManager-properties.xml.
</para>
				<table BORDER="" WIDTH="100%"><tr ALIGN="CENTER" BGCOLOR="#66FFFF"><td width="38%"><emphasis>Name</emphasis></td><td width="34%"><emphasis>Description</emphasis></td><td width="9%"><emphasis>Possible Value</emphasis></td><td width="19%"><emphasis>Default Value</emphasis></td></tr><tr><td>com.arjuna.ats.arjuna.recovery.periodicRecoveryPeriod</td><td>Interval in seconds between initiating the periodic recovery modules</td><td>Value in seconds</td><td>120</td></tr><tr><td>com.arjuna.ats.arjuna.recovery.recoveryBackoffPeriod</td><td>Interval in seconds between first and second pass of periodic recovery</td><td>Value in seconds</td><td>10</td></tr><tr><td>com.arjuna.ats.arjuna.recovery.recoveryExtensionX</td><td>Indicates a periodic recovery module to use. X is the occurence number
      of the recovery module among a set of recovery modules. These modules are
      invoked in sort-order of names</td><td>The class name of the periodic recovery module </td><td>&PARENT_PRODUCT; provides a set classes given in the RecoveryManager-properties.xml file</td></tr><tr><td>com.arjuna.ats.arjuna.recovery.recoveryActivator_X</td><td>Indicates a recovery activator to use. X is the occurence number of the
      recovery activator among a set of recovery activators. </td><td>The class name of the periodic recovery activator</td><td>&PARENT_PRODUCT; provide one class that manages the recovery protocol specified
      by the OTS specification </td></tr><tr><td>com.arjuna.ats.arjuna.recovery.expiryScannerXXX</td><td>Expiry scanners to use (order of invocation is random). Names must begin
      with "com.arjuna.ats.arjuna.recovery.expiryScanner"</td><td>Class name</td><td>&PARENT_PRODUCT; provides one class given in the RecoveryManager-properties.xml file</td></tr><tr><td>com.arjuna.ats.arjuna.recovery.expiryScanInterval</td><td>Interval, in hours, between running the expiry scanners. This can be
      quite long. The absolute value determines the interval - if the value is
      negative, the scan will NOT be run until after one interval has elapsed.
      If positive the first scan will be immediately
      after startup. Zero will prevent any scanning. </td><td>Value in hours</td><td>12 </td></tr><tr><td>com.arjuna.ats.arjuna.recovery.transactionStatusManagerExpiryTime</td><td>Age, in hours, for removal of transaction status manager item. This should
      be longer than any ts-using process will remain running. Zero = Never removed.
    </td><td>Value in Hours</td><td>12 </td></tr><tr><td>com.arjuna.ats.arjuna.recovery.transactionStatusManagerPort</td><td>Use this to fix the port on which the TransactionStatusManager listens</td><td>Port number (short) </td><td>use a free port</td></tr></table>


	</section>
    </section>
    <section>
        <title>Installation Content</title>
        <section><title>Verifying Installation</title>
When installed, the binary release of &PARENT_PRODUCT;, JTS version, should have the following structure.
<itemizedlist><listitem>/bin: this directory contains commands
    to run the OTS transaction manager server (if required) and the Recovery Manager,
    and scripts to configure environment variables needed to execute &PARENT_PRODUCT;.</listitem><listitem>/docs: this directory contains
    documentation on the way to installing, administering and programming ArjunaCore,
    &PARENT_PRODUCT; JTA and &PARENT_PRODUCT; JTS.</listitem><listitem>/etc: this directory contains appropriate
    properties files that can be used to configure the behaviour of the &PARENT_PRODUCT;.</listitem><listitem>/htdocs: this directory describes
    all APIs defined by &PARENT_PRODUCT;
					</listitem><listitem>/idl: this directory contains the
    CORBA idl files that may be registered with your interface repository prior
    to running any applications.
					</listitem><listitem>/jacorb: This directory contains the jacorb distribution.
					</listitem><listitem>/lib: this directory contains the
    jar files that contains packages defined by the &PARENT_PRODUCT;. These jar files
    shall be added in the CLASSPATH
					</listitem><listitem>/services: this directory contains the
    appropriates scripts, jar and configuration files allowing to start and stop standalone Transaction Service and Recovery Manager
					</listitem><listitem>/trail_map: contains examples
    applications</listitem></itemizedlist>
</section>
        <section>
            <title>Testing your installation</title>
            <para>To ensure that your &PARENT_PRODUCT; installation is fully operational, we will run the simple demo.</para>
            <para>Please follow these steps before running the transactional applications</para>
            <itemizedlist>
                <listitem>Ensure you have the Ant build system installed. Ant is a Java build tool,
    similar to make. It is available for free from http://ant.apache.org/ The
    sample application requires version 1.5.1 or later. </listitem>
                <listitem>The PATH and CLASSPATH environment variables need to be set appropriately
    to use &PARENT_PRODUCT;. To make this easier, we provide a shell
    script setup_env.sh (and for
    Windows a batch file setup_env.bat)
    in the directory &lt;jbossts_install_root&gt;/bin/
					</listitem>
                <listitem>From a command prompt, cd to the directory containing the build.xml file
    (&lt;jbossts_install_root&gt;/trail_map)
    and type 'ant'. This will compile a set of sources files located under &lt;jbossts_install_root&gt;/trail_map/src
    then create an application .jar file named <emphasis>jbossts-demo.jar</emphasis>. under
    the directory &lt;jbossts_install_root&gt;/trail_map/lib
					</listitem>
                <listitem>Add the generated jar file to the CLASSPATH environment variable.</listitem>
                <listitem>Ensure that the jacorb is added in your CLASSPATH. Use only the patched version that ships with &PARENT_PRODUCT;.
					<para><emphasis>Ensure that &PARENT_PRODUCT; jar files appear before jacorb jar files. </emphasis></para></listitem>
            </itemizedlist>
            <itemizedlist>
                <listitem> Start the server.  src/com/arjuna/demo/simple/HelloServer.java"&gt;(HelloServer.java) (<emphasis>Note: The source code for the trailmap is fully documented and can often contain very useful tips and information that may not be reflected elsewhere in the trailmap</emphasis>)</listitem>
            </itemizedlist>
            <blockquote>
                <para>
                    java com.arjuna.demo.simple.HelloServer
                </para>
            </blockquote>
            <itemizedlist>
                <listitem>Open another command prompt, go to the same /trail_map directory and start
    the client src/com/arjuna/demo/simple/HelloClient.java"&gt;(HelloClient.java) . Be sure that the environment variable CLASSPATH is set with the
    same value as explained above. </listitem>
            </itemizedlist>
            <blockquote>
                <para>
                    java com.arjuna.demo.simple.HelloClient
                </para>
            </blockquote>
            <para>In the client window you should see the following lines:</para>
            <programlisting role="JAVA" language="Java">
     Creating a transaction !
     Call the Hello Server !
     Commit transaction
     Done</programlisting>
            <para>In the server, which must be stopped by hand, you should see:</para>
            <programlisting role="JAVA" language="Java">
     Hello - called within a scope of a transaction</programlisting>
        </section>
        <section><title>Setting properties</title>
&PARENT_PRODUCT; has been designed to be highly configurable at runtime through the use of various
property attributes. Although these attributes can be provided at runtime on the
command line, it is possible (and may be more convenient) to specify them through the
properties  file jbossts-properties.xml located under the /etc directory of the &PARENT_PRODUCT; distribution.
				<para>More details on the way to configure the behavior of &PARENT_PRODUCT; can be found in the section on configuration.
</para>
	</section>
    </section>
    <section>
        <title>Specifying the ORB to use</title>
        <para>JDK releases from 1.2.2 onwards include a minimum ORB implementation from Sun.
  If using such a JDK in conjunction with another ORB it is necessary to tell
  the JVM which ORB to use. This happens by specifying the <emphasis>org.omg.CORBA.ORBClass
  </emphasis>  and org.omg.CORBA.ORBSingletonClass properties. In earlier versions of the &PARENT_PRODUCT;
  it was necessary to specify these properties explicitly, either on the command
  line of in the properties file. However, it is no longer a requirement to do
  this, as the ORB Portability classes
  will ensure that these properties are automatically set when required. Of course
  it is still possible to specify these values explicitly (and necessary if not
  using the ORB initialization methods)</para>
    </section>
    <section>
        <title>Overview of the Distributed Transaction Processing</title>
        <para>
					Transaction management is one of the most crucial
					requirements for enterprise application development.
					Most of the large enterprise applications in the
					domains of finance, banking and electronic commerce
					rely on transaction processing for delivering their
					business functionality.
				</para>
        <para>
					Enterprise applications often require concurrent
					access to distributed data shared amongst multiple
					components, to perform operations on data. Such
					applications should maintain integrity of data (as
					defined by the business rules of the application)
					under the following circumstances:
				</para>
        <itemizedlist>
            <listitem>
						distributed access to a single resource of data,
						and
					</listitem>
            <listitem>
						access to distributed resources from a single
						application component.
					</listitem>
        </itemizedlist>
        <para>
					In such cases, it may be required that a group of
					operations on (distributed) resources be treated as
					one unit of work. In a unit of work, all the
					participating operations should either succeed or
					fail and recover together. This problem is more
					complicated when
				</para>
        <itemizedlist>
            <listitem>
						a unit of work is implemented across a group of
						distributed components operating on data from
						multiple resources, and/or
					</listitem>
            <listitem>
						the participating operations are executed
						sequentially or in parallel threads requiring
						coordination and/or synchronization.
					</listitem>
        </itemizedlist>
        <para>
					In either case, it is required that success or
					failure of a unit of work be maintained by the
					application. In case of a failure, all the resources
					should bring back the state of the data to the
					previous state (
					<emphasis>i.e.,</emphasis>
					the state prior to the commencement of the unit of
					work).
				</para>
        <para>
					From the programmer's perspective a transaction is a
					scoping mechanism for a collection of actions which
					must complete as a unit. It provides a simplified
					model for exception handling since only two outcomes
					are possible:
				</para>
        <itemizedlist>
            <listitem>
						success - meaning that all actions involved
						within a transaction are completed
					</listitem>
            <listitem>failure - no actions complete</listitem>
        </itemizedlist>
        <imagedata fileref="images/trans_succes_failure.PNG.png" format="PNG"/>
    </section>
    <section><title>Example</title><para>
					To illustrate the reliability expected by the
					application let’s consider the funds transfer
					example which is familiar to all of us.
				</para>
				The Money transfer involves two operations: Deposit and
				Withdrawal
				<para>
					The complexity of implementation doesn't matter;
					money moves from one place to another. For instance,
					involved accounts may be either located in a same
					relational table within a database or located on
					different databases.
				</para>
				<para>
					A Simple transfer consists on moving money from
					savings to checking while a Complex transfer can be
					performed at the end- of- day according to a
					reconciliation between international banks
				</para>
				<imagedata fileref="images/example_transfer.PNG.png" format="PNG"/>
				<section><title>What is a Transaction?</title><para>
						The concept of a transaction, and a transaction
						manager (or a transaction processing service)
						simplifies construction of such enterprise level
						distributed applications while maintaining
						integrity of data in a unit of work.
					</para><para>
					A transaction is a unit of work that has the
					following properties:
				</para><itemizedlist><listitem><emphasis>Atomicity</emphasis>
						– either the whole transaction completes or
						nothing completes - partial completion is not
						permitted.
					</listitem><listitem><emphasis>Consistency</emphasis>
						– a transaction transforms the system from one
						consistent state to another. In other words, On
						completion of a successful transaction, the data
						should be in a consistent state. For example, in
						the case of relational databases, a consistent
						transaction should preserve all the integrity
						constraints defined on the data.
					</listitem><listitem><emphasis>Isolation:</emphasis>
						Each transaction should appear to execute
						independently of other transactions that may be
						executing concurrently in the same environment.
						The effect of executing a set of transactions
						serially should be the same as that of running
						them concurrently. This requires two things:
						<itemizedlist><listitem>
								During the course of a transaction,
								intermediate (possibly inconsistent)
								state of the data should not be exposed
								to all other transactions.
							</listitem><listitem>
								Two concurrent transactions should not
								be able to operate on the same data.
								Database management systems usually
								implement this feature using locking.
							</listitem></itemizedlist>
					</listitem><listitem><emphasis>Durability:</emphasis>
						The effects of a completed transaction should
						always be persistent.
					</listitem></itemizedlist><para>
					These properties, called as
					<emphasis>ACID</emphasis>
					properties, guarantee that a transaction is never
					incomplete, the data is never inconsistent,
					concurrent transactions are independent, and the
					effects of a transaction are persistent.
				</para></section>
				<section><title>Transactional Concepts</title><section><title>Transaction Components</title><para>
					A collection of actions is said to be transactional
					if they possess the ACID properties. These
					properties are assumed to be ensured, in the
					presence of failures; if actions involved within the
					transaction are performed by a Transactional System.
					A transaction system includes a set of components
					where each of them has a particular role. Main
					components are described below.
				</para><imagedata fileref="images/transaction_components.PNG.png" format="PNG"/></section><section><title>Application Programs</title><para>
						Application Programs are clients for the
						transactional resources. These are the programs
						with which the application developer implements
						business transactions. With the help of the
						transaction manager, these components create
						global transactions and operate on the
						transactional resources with in the scope of
						these transactions. These components are not
						responsible for implementing mechanisms for
						preserving ACID properties of transactions.
						However, as part of the application logic, these
						components generally make a decision whether to
						commit or rollback transactions.
					</para><para>
						Application responsibilities could be summarized
						as follow:
					</para><itemizedlist><listitem>Create and demarcate transactions</listitem><listitem>Operate on data via resource managers</listitem></itemizedlist></section><section><title>Resource Managers</title><para>
						A resource manager is in general a component
						that manages persistent and stable data storage
						system, and participates in the two phase commit
						and recovery protocols with the transaction
						manager.
					</para><para>
						A resource manager is typically a driver that
						provides two sets of interfaces: one set for the
						application components to get connections and
						operating, and the other set for participating
						in two phase commit and recovery protocols
						coordinated by a transaction manager. This
						component may also, directly or indirectly,
						register resources with the transaction manager
						so that the transaction manager can keep track
						of all the resources participating in a
						transaction. This process is called as resource
						enlistment.
					</para><para>
						Resource Manager responsibilities could be
						summarized as follow
					</para><itemizedlist><listitem>
							Enlist resources with the transaction
							manager
						</listitem><listitem>
							Participate in two-phase commit and recovery
							protocol
						</listitem></itemizedlist></section><section><title>Transaction Manager</title><para>
						The transaction manager is the core component of
						a transaction processing environment. Its main
						responsibilities are to create transactions when
						requested by application components, allow
						resource enlistment and delistment, and to
						manage the two-phase commit or recovery protocol
						with the resource managers.
					</para><para>
						A typical transactional application begins a
						transaction by issuing a request to a
						transaction manager to initiate a transaction.
						In response, the transaction manager starts a
						transaction and associates it with the calling
						thread. The transaction manager also establishes
						a transaction context. All application
						components and/or threads participating in the
						transaction share the transaction context. The
						thread that initially issued the request for
						beginning the transaction, or, if the
						transaction manager allows, any other thread may
						eventually terminate the transaction by issuing
						a commit or rollback request.
					</para><para>
						Before a transaction is terminated, any number
						of components and/or threads may perform
						transactional operations on any number of
						transactional resources known to the transaction
						manager. If allowed by the transaction manager,
						a transaction may be suspended or resumed before
						finally completing the transaction.
					</para><para>
						Once the application issues the commit request,
						the transaction manager prepares all the
						resources for a commit operation, and based on
						whether all resources are ready for a commit or
						not, issues a commit or rollback request to all
						the resources.
					</para><para>
						Resource Manager responsibilities could be
						summarized as follow:
					</para><itemizedlist><listitem>
							Establish and maintain transaction context
						</listitem><listitem>
							Maintain association between a transaction
							and the participating resources.
						</listitem><listitem>
							Initiate and conduct two-phase commit and
							recovery protocol with the resource
							managers.
						</listitem><listitem>
							Make synchronization calls to the
							application components before beginning and
							after end of the two-phase commit and
							recovery process
						</listitem></itemizedlist></section><section><title>Local vs. Distributed Transaction</title><para>
					A transaction that involves only one transactional
					resource, such a database, is considered as
					<emphasis>local transaction</emphasis>
					, while a transaction that involves more than one
					transactional resource that need to be coordinated
					to reach a consistent state is considered as a
					<emphasis>distributed transaction.</emphasis>
				</para><para>
					A transaction can be specified by what is known as
					transaction demarcation. Transaction demarcation
					enables work done by distributed components to be
					bound by a global transaction. It is a way of
					marking groups of operations to constitute a
					transaction.
				</para><para>
					The most common approach to demarcation is to mark
					the thread executing the operations for transaction
					processing. This is called as programmatic
					demarcation. The transaction so established can be
					suspended by unmarking the thread, and be resumed
					later by explicitly propagating the transaction
					context from the point of suspension to the point of
					resumption.
				</para><para>
					The transaction demarcation ends after a commit or a
					rollback request to the transaction manager. The
					commit request directs all the participating
					resources managers to record the effects of the
					operations of the transaction permanently. The
					rollback request makes the resource managers undo
					the effects of all operations on the transaction.
				</para></section><section><title>Transaction Context and Propagation</title><para>
					Since multiple application components and resources
					participate in a transaction, it is necessary for
					the transaction manager to establish and maintain
					the state of the transaction as it occurs. This is
					usually done in the form of transaction context.
				</para><para>
					Transaction context is an association between the
					transactional operations on the resources, and the
					components invoking the operations. During the
					course of a transaction, all the threads
					participating in the transaction share the
					transaction context. Thus the transaction context
					logically envelops all the operations performed on
					transactional resources during a transaction. The
					transaction context is usually maintained
					transparently by the underlying transaction manager.
				</para></section><section><title>Resource Enlistment</title><para>
					Resource enlistment is the process by which resource
					managers inform the transaction manager of their
					participation in a transaction. This process enables
					the transaction manager to keep track of all the
					resources participating in a transaction. The
					transaction manager uses this information to
					coordinate transactional work performed by the
					resource managers and to drive two-phase and
					recovery protocol. At the end of a transaction
					(after a commit or rollback) the transaction manager
					delists the resources.
				</para></section><section><title>
					Two-Phase Commit
				</title><para>
					This protocol between the transaction manager and
					all the resources enlisted for a transaction ensures
					that either all the resource managers commit the
					transaction or they all abort. In this protocol,
					when the application requests for committing the
					transaction, the transaction manager issues a
					prepare request to all the resource managers
					involved. Each of these resources may in turn send a
					reply indicating whether it is ready for commit or
					not. Only The transaction manager issue a commit
					request to all the resource managers, only when all
					the resource managers are ready for a commit.
					Otherwise, the transaction manager issues a rollback
					request and the transaction will be rolled back.
				</para></section><section><title>
					Recovery and Logging
				</title><para>
					Basically, the Recovery is the mechanism which
					preserves the transaction atomicity in presence of
					failures. The basic technique for implementing
					transactions in presence of failures is based on the
					use of logs. That is, a transaction system has to
					record enough information to ensure that it can be
					able to return to a previous state in case of
					failure or to ensure that changes committed by a
					transaction are properly stored.</para><para>
						In addition to be able to store appropriate
						information, all participants within a
						distributed transaction must log similar
						information which allow them to take a same
						decision either to set data in their final state
						or in their initial state.
					</para><para>
						Two techniques are in general used to ensure
						transaction's atomicity. A first technique
						focuses on manipulated data, such the
						Do/Undo/Redo protocol (considered as a recovery
						mechanism in a centralized system), which allow
						a participant to set its data in their final
						values or to retrieve them in their initial
						values. A second technique relies on a
						distributed protocol named the two phases
						commit, ensuring that all participants involved
						within a distributed transaction set their data
						either in their final values or in their initial
						values. In other words all participants must
						commit or all must rollback.
					</para><imagedata fileref="images/recovery_logs.PNG.png" format="PNG"/><para>
						In addition to failures we refer as centralized
						such system crashes, communication failures due
						for instance to network outages or message loss have to be
						considered during the recovery process of a
						distributed transaction.
					</para><para>
						In order to provide an efficient and optimized
						mechanism to deal with failure, modern
						transactional systems typically adopt a “presume
						abort” strategy, which simplifies the
						transaction management.
					</para><para>
						The presumed abort strategy can be stated as
						«when in doubt, abort». With this strategy, when
						the recovery mechanism has no information about
						the transaction, it presumes that the
						transaction has been aborted.
					</para>
					A particularity of the presumed-abort assumption
					allows a coordinator to not log anything before the
					commit decision and the participants do not to log
					anything before they prepare. Then, any failure
					which occurs before the 2pc starts lead to abort the
					transaction. Furthermore, from a coordinator point
					of view any communication failure detected by a
					timeout or exception raised on sending prepare is
					considered as a negative vote which leads to abort
					the transaction. So, within a distributed
					transaction a coordinator or a participant may fail
					in two ways: either it crashes or it times out for a
					message it was expecting. When a coordinator or a
					participant crashes and then restarts, it uses
					information on stable storage to determine the way
					to perform the recovery. As we will see it the
					presumed-abort strategy enable an optimized behavior
					for the recovery.

				</section><section><title>Heuristic Decision</title>
				In extremely rare cases, a resource manager may choose
				not to wait for the outcome from the transaction
				manager. This might occur if the communications path was
				lost and was not likely to be restored for a very long
				time. Typically this happens as a result of human
				intervention and not as an arbitrary action of a
				resource manager. In order to release locks and make
				this transactions data available to new transactions,
				the resource manager makes a
				<emphasis>heuristic decision</emphasis>
				, i.e. it guesses the proper transaction outcome. When
				it does so, it must remember its guess until contact
				with the transaction manager is ultimately
				re-established.
</section><section><title>Standards</title>
				Saying that a distributed transaction can involve
				several distributed participants, means that these
				participant must be integrated within a global
				transaction manager which has the responsibility to
				ensure that all participants take a common decision to
				commit or rollback the distributed transaction. The key
				of such integration is the existence of a common
				transactional interface which is understood by all
				participants, transaction manager and resource managers
				such databases.
				<para>
					The importance of common interfaces between
					participants, as well as the complexity of their
					implementation, becomes obvious in an open systems
					environment. For this aim various distributed
					transaction processing standards have been developed
					by international standards organizations. Among
					these organizations, We list three of them which are
					mainly considered in the &PARENT_PRODUCT;
					product:
				</para>
				<itemizedlist><listitem>
						The
							X/Open model
						and its successful XA interface
					</listitem><listitem>
						The OMG with its CORBA infrastructure and the
							Object Transaction Service
						and finally
					</listitem><listitem>
						The Java Community Process leaded by Sun with
						its
							JTA/JTS specification
					</listitem></itemizedlist>
				Basically these standards have proposed logical models,
				which divide transaction processing into several
				functions:
				<itemizedlist><listitem>
						those assigned to the application which ties
						resources together in application- specific
						operations
					</listitem><listitem>
						those assigned to the Resource manager which
						access physically to data stores
					</listitem><listitem>
						functions performed by the Transaction Manager
						which manages transactions, and finally
					</listitem><listitem>
						Communication Resource Managers which allow to
						exchange information with other transactional
						domains.
					</listitem></itemizedlist>
				<imagedata fileref="images/standards.PNG.png" format="PNG"/>

	</section></section>
	</section>
    <section>
        <title>&PARENT_PRODUCT; Overview</title>
        <para>
					&PARENT_PRODUCT; assures
					complete, accurate business transactions for any
					Java based applications, including those written for
					the Java EE and EJB frameworks.
				</para>
        <para>
					&PARENT_PRODUCT; is a 100% Java implementation of a
					distributed transaction management system based on
					the Sun Microsystems Java EE Java Transaction Service
					(JTS) standard. Our implementation of the JTS
					utilizes the Object Management Group's (OMG) Object
					Transaction Service (OTS) model for transaction
					interoperability as recommended in the Java EE and EJB
					standards. Although any JTS-compliant product will
					allow Java objects to participate in transactions,
					one of the key features of &PARENT_PRODUCT; is it's 100% Java
					implementation. This allows &PARENT_PRODUCT; to support fully
					distributed transactions that can be coordinated by
					distributed parties.
        </para>
        <para>
						&PARENT_PRODUCT; runs can be run both as an embedded
						distributed service of an application server
						(e.g. &APPSERVER;), affording the user all the
						added benefits of the application server
						environment such as real-time load balancing,
						unlimited linear scalability and unmatched fault
						tolerance that allows you to deliver an
						always-on solution to your customers. It is also
						available as a free-standing Java Transaction
						Service.
					</para>
        <para>
						In addition to providing full compliance with
						the latest version of the JTS specification, &PARENT_PRODUCT;
						leads the market in providing many advanced
						features such as fully distributed transactions
						and ORB portability with POA support.
					</para>
        <para>
						&PARENT_PRODUCT; works on a number of operating systems including
                        Red Hat linux, Sun Solaris and Microsoft Windows XP.
                        It requires a Java 5 or later environment.
					</para>
        <para>
						The Java Transaction API support for &PARENT_PRODUCT; comes
						in two flavours:
					</para>
        <itemizedlist>
            <listitem>
							a purely local implementation, that does not
							require an ORB, but obviously requires all
							coordinated resources to reside within the
							same JVM.
						</listitem>
            <listitem>a fully distributed implementation.</listitem>
        </itemizedlist>
        <section>
            <title>Key features</title>
            <itemizedlist>
                <listitem>
							full compliant with the JTA 1.1
							specification:
							<itemizedlist><listitem>
									Purely local (ORB-less) JTA offers
									the fastest JTA performance
								</listitem><listitem>JDBC 3 support</listitem><listitem>XA compliance</listitem><listitem>
									JDBC drivers for database access
									with full transaction support
								</listitem><listitem>
									Automatic crash recovery for
									XAResources
								</listitem></itemizedlist>
						</listitem>
                <listitem>
							compliance with the JTS specification and
							OTS 1.2 specification from the OMG
							<itemizedlist><listitem>Distributed JTA implementation</listitem><listitem>
									support for distributed transactions
									(utilizing two-phase commit)
								</listitem><listitem>POA ORB support</listitem><listitem>interposition</listitem><listitem>transaction heuristics</listitem><listitem>
									distributed transaction manager
									(co-located with the transaction
									initiator) or transaction manager
									server
								</listitem><listitem>
									checked/unchecked transaction
									behaviour
								</listitem><listitem>
									supports both flat and nested
									transaction models, with
									nested-aware resources and resource
									adapters
								</listitem><listitem>
									independent concurrency control
									system with support for
									type-specific concurrency control
								</listitem><listitem>
									support for CosTransaction::Current
								</listitem><listitem>
									direct and indirect transaction
									management
								</listitem><listitem>synchronization interface</listitem><listitem>
									explicit and implicit transaction
									context propagation
								</listitem><listitem>automatic crash recovery</listitem><listitem>multi-thread aware</listitem></itemizedlist>
						</listitem>
                <listitem>transactional objects (TO) for Java</listitem>
                <listitem>
							ORB independence via the ORB portability
							layer
						</listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>The Sample Application</title>
        <section>
            <title>The Banking Application</title>
            <para>The sample application consists of a banking application that involves a bank    able to manage accounts on behalf of clients. Clients can obtain information    on accounts and perform operations such credit, withdraw and transfer money    from one account to an other.</para>
            <para>
                <emphasis>
                    <imagedata fileref="images/banking_application_1.PNG.png" format="PNG"/>
                </emphasis>
            </para>
            <para>Figure 1 - The Banking Applications</para>
            <itemizedlist>
                <listitem>The client application:</listitem>
            </itemizedlist>
            <itemizedlist>
                <listitem>Initializes the banking object. </listitem>
                <listitem> Choose an operation to be performed on the banking object. Possible operations      are:      <itemizedlist><listitem>Create Account: this operation asks the bank to create a new account credit it with  							the first amount provided in the request.         The creation consists:          <itemizedlist><listitem>to create an Account Object, then</listitem></itemizedlist> 							</listitem><listitem>Get Balance: this operation invokes the bank to obtain the balance of          an account.          <itemizedlist><listitem>the account is first returned by the bank, then</listitem><listitem>the account is asked to return its balance</listitem></itemizedlist> 							</listitem><listitem>Withdraw: this operation is invoked to withdraw money from an account.          If the final balance is negative the withdraw is refused and the associated          transaction aborted</listitem><listitem>Credit: this operation is performed to credit an account</listitem><listitem>Transfer: This operation is used to transfer money from an account to          another. If the transfer leads to get a negative balance of the debited          account, the transfer is refused and the associated transaction is aborted.</listitem><listitem>Exit: This operation terminates the client</listitem></itemizedlist> 					</listitem>
                <listitem>Waits for a response. </listitem>
            </itemizedlist>
            <itemizedlist>
                <listitem>The Bank Object</listitem>
            </itemizedlist>
            <itemizedlist>
                <listitem>Creates Account Objects using name</listitem>
                <listitem>Maintains the list of created Accounts</listitem>
                <listitem>Returns, when asked, the Account Object requested by the client. If the      Account doesn't exist an exception is returned to the client.</listitem>
            </itemizedlist>
            <itemizedlist>
                <listitem>An Account Object</listitem>
            </itemizedlist>
            <itemizedlist>
                <listitem>Performs operations requested by the client      <itemizedlist><listitem>credit,</listitem><listitem>withdraw (debit), and </listitem><listitem>return the current balance.</listitem></itemizedlist> 					</listitem>
            </itemizedlist>
            <para>Each operation provided to the client leads to the creation of a transaction;    therefore in order to commit or rollback changes made on an account, a resource is    associated with the account to participate to the transaction    commitment protocol. According to the final transaction decision, the resource    is able to set the Account either to its initial state (in case of rollback)    or to the final state (in case of commit). From the transactional view, Figure    2 depicts of transactional components.</para>
            <para>
                <imagedata fileref="images/banking_application_2.PNG.png" format="PNG"/>
            </para>
            <para>Figure 2 - The Banking Application and the transactional Component</para>
        </section>
        <section>
            <title>Deploying and Testing The Banking Application</title>
            <para>
					Assuming that the &PARENT_PRODUCT; product has
					been installed, this trail provides a set of
					examples that show how to build transactional
					applications. Two types of transactional
					applications are presented, those using the JTA
					interface and those accessing to the JTS (OTS)
					interfaces.
				</para>
            <para>
					Please follow these steps before running the
					transactional applications
				</para>
            <itemizedlist>
                <listitem>
						Ensure you have the Ant build system installed.
						Ant is a Java build tool, similar to make. It is
						available for free from http://ant.apache.org/
						The sample application requires version 1.5.1 or
						later.
					</listitem>
                <listitem>
						The PATH and CLASSPATH environment variables
						need to be set appropriately to use &PARENT_PRODUCT;. To make this easier, we
						provide a shell script setup_env.sh (and for
						Windows a batch file setup_env.bat) in the
						directory
						
							&lt;jbossts_install_root&gt;/bin/
						
					</listitem>
                <listitem>
						From a command prompt, cd to the directory
						containing the build.xml file
						(&lt;jbossts_install_root&gt;/trail_map) and
						type 'ant', unless already done in the
							installation section
						. This will compile a set of sources files
						located under
						&lt;jbossts_install_root&gt;/trail_map/src then
						create an application .jar file named
						<emphasis>jbossts-demo.jar</emphasis>
						. under the directory
						&lt;jbossts_install_root&gt;/trail_map/lib
					</listitem>
                <listitem>
						Add the generated jar file to the CLASSPATH
						environment variable.
					</listitem>
                <listitem>
						The demo application is provided in several
						ways, accessing persistent data or not. When
						JDBC is used as a mean to access a database,
						Oracle 9i is used. For this aim the appropriate
						Oracle libraries (classes12.zip) should be add
						in the CLASSPATH environment variable.
					</listitem>
            </itemizedlist>
            <section><title>Local transaction with JTA</title>
					To configure &PARENT_PRODUCT; for such transaction, edit the
					jbossts-properties.xml file and set the following
					properties to the appropriate values:

					<programlisting role="JAVA" language="Java">
		&lt;property
		name="com.arjuna.ats.jta.jtaTMImplementation"
		value="com.arjuna.ats.internal.jta.transaction.
		arjunacore.TransactionManagerImple"/&gt;
		&lt;property
		name="com.arjuna.ats.jta.jtaUTImplementation"
		value="com.arjuna.ats.internal.jta.transaction.
		arjunacore.UserTransactionImple"/&gt;
					</programlisting>
					</section>
            <section><title>Distributed transaction with JTA</title>
					While for a distributed transactions case, &PARENT_PRODUCT; need
					to be configured as follow:
					<programlisting role="JAVA" language="Java">
		&lt;property
		name="com.arjuna.ats.jta.jtaTMImplementation"
		value="com.arjuna.ats.internal.jta.transaction.
		jts.TransactionManagerImple"/&gt; &lt;property
		name="com.arjuna.ats.jta.jtaUTImplementation"
		value="com.arjuna.ats.internal.jta.transaction.
		jts.UserTransactionImple"/&gt;
					</programlisting>

                <para>
					Using JTA to create a distributed transaction need
					the creation of an ORB instance as done by a JTS
					application (see JTS versions of the banking
					application), the difference is in the interface
					used to demarcate and control transactions.

				</para>
        </section>
            <section>
                <title>
					The application programming interfaces used by the
					Banking Application
				</title>
                <para>
					To illustrate the programming interfaces
					possibilities enabled by &PARENT_PRODUCT;, the banking
					application is provided in several versions: a
					version that uses the JTA API and a second that uses
					JTS/OTS interfaces.
				</para>
                <para>
					This trail focuses to understanding concepts related
					to the creation of transactions and the behavior of
					the commitment protocol, while the next trail
					illustrates the similar application with persistent
					data.
				</para>
                <itemizedlist>
                    <listitem>
							Testing the Banking application with JTA
                    </listitem>
                    <listitem>
							Testing the Banking application with JTS
                    </listitem>
                </itemizedlist>
                <section>
                    <title>Running The Banking application with JTA</title>
                    <section>
                        <title>Configuring &PARENT_PRODUCT;</title>
                        <para>Program Applications that create transactions using te JTA interface may invoke as well local services as remote
services. When a remote invocation need to be performed, the current transactional context need to be propagated
to the remote service in order to involve it to the transaction in progress.&PARENT_PRODUCT; allows the
possibility to provide such feature using the facilities provided by JTS and ORB. More precisely &PARENT_PRODUCT; need to be configured
to determine in which type of transaction, local or distributed, the JTA interface is used.
</para>
                    </section>
                    <section><title>Executing the JTA sample</title>
The Banking sample using JTA creates local transactions, ensure that JTA is configured for local transactions as explained above.
<para>To launch the JTA version of the Banking application,
  which creates only local transactions, execute the following java program: </para>
<blockquote><programlisting role="JAVA" language="Java">
java com.arjuna.demo.jta.localbank.BankClient
</programlisting></blockquote>
<para>Once one of the program given above is launched the following lines are displayed:</para>
<blockquote><programlisting role="JAVA" language="Java">
-------------------------------------------------
  Bank client
-------------------------------------------------
Select an option :
   0. Quit
   1. Create a new account.
   2. Get an account information.
   3. Make a transfer.
   4. Credit an account.
   5. Withdraw from an account

Your choice :
</programlisting></blockquote>
<para>After introducing your choice, the appropriate operation is performed by the
  Bank object, to get the requested account, and by the account to execute the
  credit or withdraw or to return the current balance. Let's consider the following
  execution. </para>
<para>Enter the number 1 as your choice, then give the name "Foo" as the
  account name and "1000" as an initial value of the account to create.
  You should get the following lines:</para>
<blockquote><programlisting role="JAVA" language="Java">Your choice : 1
- Create a new account -
------------------------
Name : Foo
Initial balance : 1000
Beginning a User transaction to create account
XA_START[]
Attempt to commit the account creation transaction
XA_END[]
XA_COMMIT (ONE_PHASE)[]
</programlisting></blockquote>
				<itemizedlist><listitem>The line XA_START indicates that the AccountResource object that implements
    the XAResource interface and enlisted to participate in the account creation
    transaction, receives the indication from the Transaction Manager that the
    transaction has started.</listitem><listitem>The line XA_END indicates that the calling thread in which the AccountRessource
    object is associated shall be ended to enable the transaction completion as
    recommended by the X/Open specification.</listitem><listitem>Since only one AccountResource then only one XAResource is involved in the
    account creation transaction, the two phases needed to get a consensus in
    the 2PC protocol are not mandatory. The one phase commit optimization, indicated
    by the "XA_COMMIT (ONE_PHASE)", is applied. </listitem></itemizedlist>
				<para>In the same way create a second account with the name "Bar" and the
  initial balance set to 500. </para>
				<para>As a choice now, enter "3" to make a transfer (300) from "Foo"
  to "Bar". </para>
<blockquote><programlisting role="JAVA" language="Java">Your choice : 3
- Make a transfer -
-------------------
Take money from : Foo
Put money to : Bar
Transfert amount : 300
Beginning a User transaction to get balance
XA_START[]
XA_START[]
XA_END[]
XA_PREPARE[]
XA_END[]
XA_PREPARE[]
XA_COMMIT[]
XA_COMMIT[]
</programlisting></blockquote>
				<itemizedlist><listitem>Now two AccountResource objects, then two XAResource objects are enlisted
    with the transaction. The displayed lines show that the two phases, prepare
    and commit, are applied. </listitem></itemizedlist>
				<para>Any attempt to manipulate an account that it doesn't exist leads to throw the
  NotExistingAccount exception and to rollback the transaction in progress. For
  instance, let's withdraw money from an account FooBar not previously created.</para>
<blockquote><programlisting role="JAVA" language="Java">Your choice : 5
- Withdraw from an Account -
----------------------------
Give the Account name : FooBar
Amount to withdraw : 200
Beginning a User transaction to
withdraw from an account
The requested account does not exist!
ERROR - javax.transaction.RollbackException
</programlisting></blockquote>


	</section>
                    <section>
                        <title>Building The Banking Application with JTA</title>
                        <para>From an architectural point of view of JTA, the bank client is considered as
 an application program able to manage transactions via the javax.transaction.UserTransaction interface. The following portion of code illustrates how a JTA transaction is
 started and terminated when the client asks to transfer money from one account  to another. This also describes what are &PARENT_PRODUCT; packages that need to be used
  in order to obtain appropriate objects instances (such UserTransaction).</para>
                        <para>Note: The code below is a simplified view of the BankClient.java program. Only the transfer operation is illustrated; other operations manage transactions in the same way.
 (see for details the src/com/arjuna/demo/jta/localbank/BankClient.java)</para>
                        <programlisting role="JAVA" language="Java">
package com.arjuna.demo.jta.localbank;
public class BankClient
{
   private Bank _bank;
   // This operation is used to make a transfer
   //from an account to another account
   private void makeTransfer()
   {
     System.out.print("Take money from : ");
     String name_supplier = input();

     System.out.print("Put money to : ");
     String name_consumer = input();

     System.out.print("Transfer amount : ");
     String amount = input();

     float famount = 0;
     try
      {
        famount = new Float( amount ).floatValue();
      }
     catch ( java.lang.Exception ex )
      {
        System.out.println("Invalid float number, abort operation...");
        return;
      }

     try
      {
       //the following instruction asks a specific &PARENT_PRODUCT;
       //class to obtain a UserTransaction instance
       <emphasis>javax.transaction.UserTransaction userTran =
                     com.arjuna.ats.jta.UserTransaction.userTransaction()</emphasis>;
       System.out.println("Beginning a User transaction to get balance");
       <emphasis>userTran.begin()</emphasis>;

       Account supplier = _bank.get_account( name_supplier );
       Account consumer = _bank.get_account( name_consumer );
       supplier.debit( famount );
       consumer.credit( famount );

       <emphasis>userTran.commit( )</emphasis>;
      }
     catch (Exception e)
      {
       System.err.println("ERROR - "+e);
      }
   }
   ......
}
</programlisting>
                        <para>The Bank object has mainly two operations: creating an account, which is added in the account list,
and returning an Account object. No transactional instruction  is performed by the Bank object</para>
                        <programlisting role="JAVA" language="Java">
package com.arjuna.demo.jta.localbank;
public class Bank {
   private java.util.Hashtable _accounts;

   public Bank()
   {
     _accounts = new java.util.Hashtable();
   }

   public Account create_account( String name )
   {
     Account acc = new Account(name);
     _accounts.put( name, acc );
      return acc;
   }

   public Account get_account(String name)
   throws NotExistingAccount
   {
     Account acc = ( Account ) _accounts.get( name );
     if ( acc == null )
       throw new NotExistingAccount("The Account requested does not exist");
     return acc;
   }
}
</programlisting>
                        <para>The Account object provides mainly three methods balance,
  credit and withdraw.
  However, in order to provide the transactional behaviour, rather than to modify
  the current account directly (according to credit or withdraw) this task is
  delegated to an AccountResource object that is able, according to the transaction
  outcome, to set the account value either to its initial state or its final state.</para>
                        <para>The AccountResource object is in fact an object that implements the javax.transactions.XAResource,
  then able to participate to the transaction commitment. For this aim, the Account
  object has to register or enlist the AccountResource object as a participant
  after having obtaining the reference of the javax.transaction.Transaction object
  via the javax.transaction.TransactionManager object</para>
                        <programlisting role="JAVA" language="Java">
package com.arjuna.demo.jta.localbank;

public class Account
{
   float _balance;
   AccountResource accRes = null;

   public Account(String name)
   {
     _name = name;
     _balance = 0;
   }

   public float balance()
   {
     return getXAResource().balance();;
   }

   public void credit( float value )
   {
     getXAResource().credit( value );
   }

   public void debit( float value )
   {
     getXAResource().debit( value );
   }

   public AccountResource getXAResource()
   {

     try
     {
       <emphasis>javax.transaction.TransactionManager transactionManager =
         com.arjuna.ats.jta.TransactionManager.transactionManager();
       javax.transaction.Transaction currentTrans =
          transactionManager.getTransaction();</emphasis>

       if (accRes == null) {
         <emphasis>currentTrans.enlistResource(
            </emphasis>accRes = new AccountResource(this, _name)<emphasis> );</emphasis>
       }

       currentTrans.delistResource( accRes, XAResource.TMSUCCESS );

     }
     catch (Exception e)
     {
       System.err.println("ERROR - "+e);
     }
     return accRes;
   }
   ...
}
</programlisting>
                        <para>The AccountResource class that implements the javax.transaxtion.XAResource
  interface provides similar methods as the Account class (credit, withdraw and
  balance) but also all methods specified by the javax.transaxtion.XAResource.
  The following portion of code describes how the methods prepare,
  commit and rollback
  are implemented.</para>
                        <programlisting role="JAVA" language="Java">
public class AccountResource <emphasis>implements XAResource</emphasis>
{
   public AccountResource(Account account, String name )
   {
     _name = name;
     _account = account;
     _initial_balance = account._balance;
     _current_balance = _initial_balance;
   }

   public float balance()
   {
     return _current_balance;
   }

   public void credit( float value )
   {
     _current_balance += value;
   }

   public void debit( float value )
   {
     _current_balance -= value;
   }

   <emphasis>public void commit(Xid id, boolean onePhase) throws XAException</emphasis>
   {
     //The value of the associated Account object is modified
     _account._balance = _current_balance;
   }

   <emphasis>public int prepare(Xid xid) throws XAException</emphasis>
   {
     if ( _initial_balance == _current_balance ) //account not modified
        return (XA_RDONLY);
     if ( _current_balance &lt; 0 )
        throw new XAException(XAException.XA_RBINTEGRITY);
        //If the integrity of the account is corrupted then vote rollback
     return (XA_OK); //return OK
   }
   </programlisting>
                        <programlisting role="JAVA" language="Java"><emphasis>public void rollback(Xid xid) throws XAException</emphasis>
   {
     //Nothing is done
   }
   </programlisting>
                        <programlisting role="JAVA" language="Java">   private float _initial_balance;
   private float _current_balance;
   private Account _account;

   }
 }</programlisting>
                    </section>
                    <section>
                        <title>Sample Application Source Code</title>
                        <para>Full source code for the banking application with JTA is included to provide
  you with a starting point for experimentation. </para>
                        <itemizedlist>
                            <listitem>
                                src/com/arjuna/demo/jta/localbank/BankClient.java
                            </listitem>
                            <listitem>
                                src/com/arjuna/demo/jta/localbank/Bank.java"&gt;Bank.java
                            </listitem>
                            <listitem>
                                src/com/arjuna/demo/jta/localbank/Account.java"&gt;Account.java
                            </listitem>
                            <listitem>
                                src/com/arjuna/demo/jta/localbank/AccountResource.java
                            </listitem>
                            <listitem>
                                src/com/arjuna/demo/jta/localbank/NotExistingAccount.java"&gt;NotExistingAccount.java
                            </listitem>
                        </itemizedlist>
                    </section>
                </section>
            </section>
            <section>
                <title>Running The Banking application with JTS</title>
                <para>The JTS version of the Banking application means that the Object Request Broker
  will be used. The &PARENT_PRODUCT; distribution is provided to work with the bundled JacORB version</para>
                <para>To describe the possibilities provided by &PARENT_PRODUCT; to build a transactional
  application according to the programming models defined by the OTS specification,
  the Banking Application is programmed in different ways. </para>
                <itemizedlist>
                    <listitem>Local transactions: The Bank Client and the Bank server are collocated in
    the same process.</listitem>
                    <listitem>Distributed Transactions: The Bank Client and the Bank Server and located
    on different process. To participate within a client's transaction, Account
    Objects needed to access the transactional context. We describe the two of
    context propagation.
    <itemizedlist><listitem>implicit context propagation, and</listitem><listitem>explicit context propagation. </listitem></itemizedlist>
  </listitem>
                </itemizedlist>
                <para>
                    JTS Local Transactions&gt;
                </para>
                <para>
                    JTS Distributed Transactions
                </para>
                <section>
                    <title>Running The Banking application with JTS</title>
                    <para>The JTS version of the Banking application means that the Object Request Broker
  will be used. The &PARENT_PRODUCT; distribution is provided to work with the bundled JacORB version</para>
                    <para><emphasis>Note</emphasis>: Ensure that the jacorb jar files are added in your CLASSPATH</para>
                    <para>To launch the JTS version of the Banking application,
  execute the following java program</para>
                    <blockquote>
                        <programlisting role="JAVA" language="Java">java com.arjuna.demo.jts.localbank.BankClient</programlisting>
                    </blockquote>
                    <para>Once one of the program given above is launched the following lines are displayed:</para>
                    <blockquote>
                        <programlisting role="JAVA" language="Java">
-------------------------------------------------
   Bank client
-------------------------------------------------
Select an option :
   0. Quit
   1. Create a new account.
   2. Get an account information.
   3. Make a transfer.
   4. Credit an account.
   5. Withdraw from an account

Your choice :
</programlisting>
                    </blockquote>
                    <para>After introducing your choice, the appropriate operation is performed by the
  Bank object, to get the requested account, and by the account to execute the
  credit or withdraw or to return the current balance. Let's consider the following
  execution. </para>
                    <para>Enter the number 1 as your choice, then give the name "Foo" as the
  account name and "1000" as an initial value of the account to create.
  You should get the following lines:</para>
                    <blockquote>
                        <programlisting role="JAVA" language="Java">
Your choice : 1
- Create a new account -
------------------------
Name : Foo
Initial balance : 1000
Beginning a User transaction to create account
[ Connected to 192.168.0.2:4799 from local port 4924 ]
Attempt to commit the account creation transaction
/[ Resource for Foo : Commit one phase ]
</programlisting>
                    </blockquote>
                    <itemizedlist>
                        <listitem>Since only one AccountResource then only one CosTransaction.Resource is
    involved in the account creation transaction, the two phases needed to get
    a consensus in the 2PC protocol are not mandatory. The one phase commit optimisation,
    indicated by the "Commit one phase", is applied. </listitem>
                    </itemizedlist>
                    <para>In the same way create a second account with the name "Bar" and the
  initial balance set to 500. </para>
                    <para>As a choice now, enter "3" to make a transfer (300) from "Foo"
  to "Bar". </para>
                    <blockquote>
                        <programlisting role="JAVA" language="Java">
Your choice : 3
- Make a transfer -
-------------------

Take money from : Foo
Put money to : Bar
Transfer amount : 300
Beginning a User transaction to Transfer money
[ Resource for Foo : Prepare ]
[ Resource for Bar : Prepare ]
[ Resource for Foo : Commit ]
[ Resource for Bar : Commit ]
</programlisting>
                    </blockquote>
                    <itemizedlist>
                        <listitem>Now two AccountResource objects, then two CosTransactions.Resource objects
    are enlisted with the transaction. The displayed lines show that the two phases,
    prepare and commit, are applied. </listitem>
                    </itemizedlist>
                    <para>Any attempt to manipulate an account that it doesn't exist leads to throw the
  NotExistingAccount exception and to rollback the transaction in progress. For
  instance, let's withdraw money from an account FooBar not previously created.</para>
                    <blockquote>
                        <programlisting role="JAVA" language="Java">
Your choice : 5
- Withdraw from an Account -
----------------------------
Give the Account name : FooBar
Amount to withdraw : 200
Beginning a User transaction to withdraw from an account
The requested account does not exist!
ERROR - org.omg.CORBA.TRANSACTION_ROLLEDBACK:
minor code: 50001  completed: No
</programlisting>
                    </blockquote>
                    <section>
                        <title>Using a stand-alone Transaction Server</title>
                        <para>By default &PARENT_PRODUCT; does not use a separate transaction manager server: transaction
  managers are co-located with each application process to improve performance
  and improve application fault-tolerance. When running applications which require
  a separate transaction manager, you must set the com.arjuna.ats.jts.transactionManager
  property variable, in the "(jbossts_install_dir)/etc/jbossts-properties.xml file, to YES. </para>
                        <para>In a separate window, the stand-alone Transaction Server is launched as follow:</para>
                        <blockquote>
                            <programlisting role="JAVA" language="Java">java com.arjuna.ats.jts.TransactionServer [-test]</programlisting>
                        </blockquote>
                        <para>The option -test allows to see the message "Ready" when the Transaction Server is started.</para>
                        <para>The Banking application presented above gives the same output.</para>
                    </section>
                    <section>
                        <title>Running The Banking application with JTS</title>
                        <para>The JTS version of the Banking application means that the Object Request Broker
  will be used. The &PARENT_PRODUCT; distribution is provided to work with the bundled JacORB version</para>
                        <para><emphasis>Note</emphasis>: Ensure that the jacorb jar files are added in your CLASSPATH</para>
                        <itemizedlist>
                            <listitem>In a separate window launch the Recovery Manager, as follow.</listitem>
                        </itemizedlist>
                        <blockquote>
                            <programlisting role="JAVA" language="Java">java com.arjuna.ats.arjuna.recovery.RecoveryManager</programlisting>
                        </blockquote>
                        <itemizedlist>
                            <listitem>
                                <emphasis>Testing the distributed transaction with <emphasis>Implicit Propagation Context</emphasis></emphasis>
                            </listitem>
                        </itemizedlist>
                        <itemizedlist>
                            <listitem>Start the Server</listitem>
                        </itemizedlist>
                        <blockquote>
                            java com.arjuna.demo.jts.remotebank.BankServer
                        </blockquote>
                        <itemizedlist>
                            <listitem>In a separate window, start the client</listitem>
                        </itemizedlist>
                        <blockquote>
                            java com.arjuna.demo.jts.remotebank.BankClient
                        </blockquote>
                        <itemizedlist>
                            <listitem>
                                <emphasis>Testing the distributed transaction with <emphasis>Explicit Propagation Context</emphasis></emphasis>
                            </listitem>
                        </itemizedlist>
                        <itemizedlist>
                            <listitem>Start the Server</listitem>
                        </itemizedlist>
                        <blockquote>
                            java com.arjuna.demo.jts.explicitremotebank.BankServer
                        </blockquote>
                        <itemizedlist>
                            <listitem>In a separate window, start the client</listitem>
                        </itemizedlist>
                        <blockquote>
                            java com.arjuna.demo.jts.explicitremotebank.BankClient
                        </blockquote>
                        <para>In both cases (implicit and explicit), the Bank Server, which can be stopped by hand, displays the following lines:</para>
                        <blockquote>
                            The bank server is now ready...
                        </blockquote>
                        <para>In both cases (implicit and Explicit), the Bank Client window displays the  following lines:</para>
                        <blockquote>
                            
                            -------------------------------------------------
					   Bank client
					-------------------------------------------------
					
					Select an option :
					   0. Quit
					   1. Create a new account.
					   2. Get an account information.
					   3. Make a transfer.
					   4. Credit an account.
					   5. Withdraw from an account
					
					Your choice :
                        </blockquote>
                        <para>After entering your choice, the appropriate operation is performed by the
  remote Bank object, to get the requested account, and by the account to execute
  the credit or withdraw or to return the current balance. Let's consider the following execution. </para>
                        <para>Enter the number 1 as your choice, then give the name "Foo" as the
  account name and "1000" as an initial value of the account to create.
  You should get in the server window a result that terminates with the following line</para>
                        <blockquote>
                            [ Resource for Foo : Commit one phase ]
                        </blockquote>
                        <itemizedlist>
                            <listitem>Since only one AccountResource then only one CosTransaction.Resource is
    involved in the account creation transaction, the two phases needed to get
    a consensus in the 2PC protocol are not mandatory. The one phase commit optimisation,
    indicated by the "Commit one phase", is applied. </listitem>
                        </itemizedlist>
                        <para>In the same way create a second account with the name "Bar" and the initial balance set to 500. </para>
                        <para>As a choice now, enter in the client window "3" to make a transfer
  (300) from "Foo" to "Bar". </para>
                        <blockquote>
                            
                    Your choice : 3
					- Make a transfer -
					-------------------
					
					Take money from : Foo
					Put money to : Bar
					Transfer amount : 300
                        </blockquote>
                        <para> In the Server window you should see a result with the following lines</para>
                        <blockquote>
                            
                    [ Resource for Foo : Prepare ]
					[ Resource for Bar : Prepare ]
					[ Resource for Foo : Commit ]
					[ Resource for Bar : Commit ]
                        </blockquote>
                        <itemizedlist>
                            <listitem>Now two AccountResource objects, then two CosTransactions.Resource objects are enlisted with the transaction. The
					displayed lines show that the two phases, prepare and commit, are applied. </listitem>
                        </itemizedlist>
                        <para>Any attempt to manipulate an account that it doesn't exist leads to throw the NotExistingAccount exception and to rollback
				the transaction in progress. For instance, let's withdraw money from an account FooBar not previously created.</para>
                        <blockquote>
                            
                    Your choice : 5
					- Withdraw from an Account -
					----------------------------
					Amount to withdraw : 200
					Beginning a User transaction to withdraw from an account
					The requested account does not exist!
					ERROR - org.omg.CORBA.TRANSACTION_ROLLEDBACK:
					   minor code: 50001  completed: No
                        </blockquote>
                    </section>
                    <section>
                        <title>Using a stand-alone Transaction Server</title>
                        <para>By default &PARENT_PRODUCT; does not use a separate transaction manager server: transaction
  managers are co-located with each application process to improve performance
  and improve application fault-tolerance. When running applications which require
  a separate transaction manager, you must set the com.arjuna.ats.jts.transactionManager
  property variable, in the jbossts-properties.xml file, to YES. </para>
                        <para>In a separate window, the stand-alone Transaction Server is launched as follow:</para>
                        <blockquote>
                            java com.arjuna.ats.jts.TransactionServer [-test]
                        </blockquote>
                        <para>The option -test allows to see the message "Ready" when the Transaction Server is started.</para>
                        <para>The Banking application presented above gives the same output.</para>
                    </section>
                    <section>
                        <title>Running the example on several machines</title>
                        <para>
				It is possible to run the &PARENT_PRODUCT; Transaction Service and recovery manager processes on a different machine and have clients access these
				centralized services in a hub-and-spoke style architecture.</para>
                        <para>
				All that must be done is to provide the clients with enough information to contact the transaction service (such as the ORB's NameService).
				However, configuring the ORB is beyond the remit of this trailmap and so we shall opt for a simpler mechanism wherby the transaction services
				IOR is shared by access to a common file.</para>
                        <para>
				This trailmap stage assumes that the transaction service has been appropriately installed and configured (the
				setenv.[bat|sh] script has been ran) onto two hosts (for the purpose of explanation we shall
				refer to these hosts as host1 and host2).</para>
                        <itemizedlist>
                            <listitem>Start the transaction service and recovery manager on host1</listitem>
                            <itemizedlist>
                                <listitem>Start the recovery manager in one command prompt terminal</listitem>
                            </itemizedlist>
                            <blockquote>
                                java com.arjuna.ats.arjuna.recovery.RecoveryManager [-test]
                            </blockquote>
                            <itemizedlist>
                                <listitem>Start the transaction service in a second command prompt terminal</listitem>
                            </itemizedlist>
                            <blockquote>
                                java com.arjuna.ats.jts.TransactionServer [-test]
                            </blockquote>
                        </itemizedlist>
                        <itemizedlist>
                            <listitem>Share the transaction service IOR on host1 with host2</listitem>
                            <para>
					Open a command prompt on host2 and copy the CosServices.cfg file
					from the &lt;narayana-jts_install_root&gt;/etc directory on host1.</para>
                            <para>
					For example, using the popular scp package, open a shell prompt and issue the following command:</para>
                            <blockquote>
                                scp <emphasis>user</emphasis>@<emphasis>host1</emphasis>:&lt;ats_root&gt;/etc/CosServices.cfg &lt;host2_ats_root&gt;/etc/
                            </blockquote>
                        </itemizedlist>
                        <itemizedlist>
                            <listitem>Start the Bank Server and Bank Client applications on host2</listitem>
                            <para>
                                <emphasis>NOTE:</emphasis>
                                <emphasis>See the section above entitled "Using a stand-alone Transaction Server" for more information on how to configure these application to use a remote transaction service.</emphasis>
                            </para>
                            <itemizedlist>
                                <listitem>
                                    <emphasis>Testing the distributed transaction with <emphasis>Implicit Propagation Context</emphasis></emphasis>
                                </listitem>
                            </itemizedlist>
                            <itemizedlist>
                                <listitem>Start the Server</listitem>
                            </itemizedlist>
                            <programlisting role="JAVA" language="Java">   java com.arjuna.demo.jts.remotebank.BankServer</programlisting>
                            <itemizedlist>
                                <listitem>In a separate window, start the client</listitem>
                            </itemizedlist>
                            <programlisting role="JAVA" language="Java">   java com.arjuna.demo.jts.remotebank.BankClient</programlisting>
                            <itemizedlist>
                                <listitem>
                                    <emphasis>Testing the distributed transaction with <emphasis>Explicit Propagation Context</emphasis></emphasis>
                                </listitem>
                            </itemizedlist>
                            <itemizedlist>
                                <listitem>Start the Server</listitem>
                            </itemizedlist>
                            <programlisting role="JAVA" language="Java">   java com.arjuna.demo.jts.explicitremotebank.BankServer</programlisting>
                            <itemizedlist>
                                <listitem>In a separate window, start the client</listitem>
                            </itemizedlist>
                            <programlisting role="JAVA" language="Java">   java com.arjuna.demo.jts.explicitremotebank.BankClient</programlisting>
                        </itemizedlist>
                    </section>
                    <section>
                        <title>How the Banking Application is build using JTS interfaces</title>
                        <para>From an architectural point of view of JTS, the bank client is considered as
  an application program able to manage transactions either in a direct or indirect
  management mode, respectively with the interfaces org.omg.CosTransactions.TransactionFactory
  and org.omg.CosTransactions.Terminator or with the org.omg.CosTransactions.Current
  interface. Transactions created by the client in the Banking application are
  done in the indirect mode. </para>
                        <para> The following portion of code illustrates how a JTS transaction is started
  and terminated when the client asks to transfer money from one account to another.
  This also describes what are &PARENT_PRODUCT; packages that need to be used in order
  to obtain appropriate objects instances (such Current).</para>
                        <para>Note: The code below is a simplified view of the BankClient.java program. Only
  the transfer operation is illustrated; other operations manage transactions
  in the same way. (see for details the ../src/com/arjuna/demo/jts/localbank/BankClient.java)</para>
                        <blockquote>
                            <programlisting role="JAVA" language="Java">package com.arjuna.demo.jta.localbank;
<emphasis>import com.arjuna.ats.jts.OTSManager;
import com.arjuna.ats.internal.jts.ORBManager;</emphasis>
					</programlisting>
                            <programlisting role="JAVA" language="Java">public class BankClient
{
   private Bank _bank; //Initialised on BankClient initializations
   ....
   // This operation is used to make a transfer from an account to another account
   private void makeTransfer()
   {
     System.out.print("Take money from : ");
     String name_supplier = input();

     System.out.print("Put money to : ");
     String name_consumer = input();

     System.out.print("Transfert amount : ");
     String amount = input();

     float famount = 0;
     try
      {
        famount = new Float( amount ).floatValue();
      }
     catch ( java.lang.Exception ex )
      {
        System.out.println("Invalid float number, abort operation...");
        return;
      }

     try
      {
       //the following instruction asks a specific &PARENT_PRODUCT; class to obtain a Current instance
       <emphasis>Current current = OTSManager.get_current(); </emphasis>
       System.out.println("Beginning a User transaction to get balance");
       <emphasis>current.begin()</emphasis>;

       Account supplier = _bank.get_account( name_supplier );
       Account consumer = _bank.get_account( name_consumer );
       supplier.debit( famount );
       consumer.credit( famount );

       <emphasis>current.commit( )</emphasis>;
      }
     catch (Exception e)
      {
       System.err.println("ERROR - "+e);
      }
   }</programlisting>
                            <para>Since JTS is used invocations against an ORB are needed, such ORB and Object
    Adapter instantiation and initialisation. To ensure a better portability,
    the ORB Portability API provides a set of
    methods that can be used as described below. </para>
                            <programlisting role="JAVA" language="Java">public static void main( String [] args )
{  
    try {
     myORB = ORB.getInstance("test");// Create an ORB instance
     myOA = OA.getRootOA(myORB); //Obtain the Root POA
     myORB.initORB(args, null); //Initialise the ORB
     myOA.initOA(); //Initialise the POA

     // The ORBManager is a class provided by &PARENT_PRODUCT; to facilitate the association
     // of the ORB/POA with the transaction service
     ORBManager.setORB(myORB);
     ORBManager.setPOA(myOA);
     ....
   }
   catch(Exception e)
   {
     e.printStackTrace(System.err);
   }
}
</programlisting>
                        </blockquote>
                        <para>The Bank object has mainly two operations: creating an account, which is added
  in the account list, and returning an Account object. No transactional instruction
  is performed by the Bank object</para>
                        <blockquote>
                            <programlisting role="JAVA" language="Java">package com.arjuna.demo.jta.localbank;
public class Bank {
   private java.util.Hashtable _accounts;

   public Bank()
   {
     _accounts = new java.util.Hashtable();
   }

   public Account create_account( String name )
   {
     Account acc = new Account(name);
     _accounts.put( name, acc );
      return acc;
   }

   public Account get_account(String name)
   throws NotExistingAccount
   {
     Account acc = ( Account ) _accounts.get( name );
     if ( acc == null )
       throw new NotExistingAccount("The Account requested does not exist");
     return acc;
   }
}</programlisting>
                        </blockquote>
                        <para>The Account object provides mainly three methods balance,
  credit and withdraw.
  However, in order to provide the transactional behaviour, rather than to modify
  the current account directly (according to credit or withdraw) this task is
  delegated to an AccountResource object that is able, according to the transaction
  outcome, to set the account value either to its initial state or its final state.</para>
                        <para>  The AccountResource object is in fact an object that implements the org.omg.CosTransactions.Resource,
  then able to participate to the transaction commitment. For this aim, the Account
  object has to register the AccountResource object as a participant, after having
  obtaining the reference of the org.omg.CosTransactions.Coordinator object ,
  itself obtained via the org.omg.CosTransactions.Control object</para>
                        <blockquote>
                            <programlisting role="JAVA" language="Java">package com.arjuna.demo.jta.localbank;


public class Account
{
   float _balance;
   AccountResource accRes = null;

   public Account(String name )
   {
     _name = name;
     _balance = 0;
   }

   public float balance()
   {
     return getResource().balance();;
   }

   public void credit( float value )
   {
     getResource().credit( value );
   }

   public void debit( float value )
   {
     getResource().debit( value );
   }


   public AccountResource getResource()
    {
    try {
    if (accRes == null) {
         accRes = new AccountResource(this, _name) ;
         <emphasis>Resource ref = org.omg.CosTransactions.ResourceHelper.narrow(ORBManager.getPOA().corbaReference(accRes));</emphasis>
         // Note above the possibilities provided by the ORBManager to access the POA then to obtain
         // the CORBA reference of the created AccountResource object

         <emphasis>RecoveryCoordinator recoverycoordinator = OTSManager.get_current().get_control().
                                               get_coordinator().register_resource(ref);</emphasis>
						
        }
      }
      catch (Exception e)
      {
        System.err.println("ERROR - "+e);
      }

      return accRes;
   }
   ...
}</programlisting>
                        </blockquote>
                        <para>To be considered as a org.omg.CosTransactions.Resource, the AccountResource
  class shall extends the class org.omg.CosTransactions.ResourcePOA generated
  by the CORBA IDL compiler. The AccountRessource provides similar methods as
  the Account class (credit, withdraw and balance) with the appropriate methods
  to participate to the 2PC protocol. The following portion of code describes
  how the methods prepare, commit
  and rollback are implemented.</para>
                        <blockquote>
                            <programlisting role="JAVA" language="Java">public class AccountResource extends org.omg.CosTransactions.ResourcePOA
{
   public AccountResource(Account account, String name )
   {
     _name = name;
     _account = account;
     _initial_balance = account._balance;
     _current_balance = _initial_balance;
   }

   public float balance()
   {
     return _current_balance;
   }

   public void credit( float value )
   {
     _current_balance += value;
   }

   public void debit( float value )
   {
     _current_balance -= value;
   }

   public org.omg.CosTransactions.Vote prepare()
	   throws org.omg.CosTransactions.HeuristicMixed, org.omg.CosTransactions.HeuristicHazard
    {
	  if ( _initial_balance == _current_balance )
       return org.omg.CosTransactions.Vote.VoteReadOnly;
     if ( _current_balance &lt; 0 )
       return org.omg.CosTransactions.Vote.VoteRollback;
     return org.omg.CosTransactions.Vote.VoteCommit;
    }

   public void rollback()
     throws org.omg.CosTransactions.HeuristicCommit, org.omg.CosTransactions.HeuristicMixed,
                            org.omg.CosTransactions.HeuristicHazard
   {
     //Nothing to do
   }

   public void commit()
     throws org.omg.CosTransactions.NotPrepared, org.omg.CosTransactions.HeuristicRollback,
                      org.omg.CosTransactions.HeuristicMixed, org.omg.CosTransactions.HeuristicHazard
   {
      _account._balance = _current_balance;
   }

   public void commit_one_phase()
     throws org.omg.CosTransactions.HeuristicHazard
   {
     _account._balance = _current_balance;
   }

   .....</programlisting>
                            <programlisting role="JAVA" language="Java">   private float _initial_balance;
   private float _current_balance;
   private Account _account;

   }
 </programlisting>
                        </blockquote>
                    </section>
                    <section>
                        <title>Sample Application Source Code</title>
                        <para>Full source code for the banking application is included to provide you with
  a starting point for experimentation. </para>
                        <itemizedlist>
                            <listitem>JTS Version
    <itemizedlist><listitem>src/com/arjuna/demo/jts/localbank/BankClient.java</listitem><listitem>src/com/arjuna/demo/jts/localbank/Bank.java"&gt;Bank.java</listitem><listitem>src/com/arjuna/demo/jts/localbank/Account.java"&gt;Account.java</listitem><listitem>src/com/arjuna/demo/jts/localbank/AccountResource.java</listitem><listitem>src/com/arjuna/demo/jts/localbank/NotExistingAccount.java"&gt;NotExistingAccount.java</listitem></itemizedlist>
					</listitem>
                        </itemizedlist>
                    </section>
                    <section>
                        <title>How the Banking Application is build using JTS interfaces</title>
                        <para>The bank client is an application program able to manage transactions either in a direct or indirect
  management mode, respectively with the interfaces org.omg.CosTransactions.TransactionFactory
  and org.omg.CosTransactions.Terminator or with the org.omg.CosTransactions.Current
  interface. Transactions created by the client in the Banking application are
  done in the indirect mode. </para>
                        <para>Invoking a remote object within a CORBA environment means that the remote object
  implements a CORBA interface defined in a CORBA idl file. The following Bank.idl
  describes the interfaces then the possible kind of distributed CORBA objects
  involved in the banking application. There is no any interface that inherits
  the CosTransactions::TransactionalObject interface, which means that for any
  remote invocations the transactional context is normally not propagated. However,
  since the Account object may have to register Resource objects that participate
  to transaction completion, a context is needed. In the following Bank.idl file
  operations defined in the Account interface have explicitly in their signature
  the CosTransactions::Control argument meaning that it passed explicitly by the
  caller - in this case the Bank Client program.</para>
                        <programlisting role="JAVA" language="Java">
module arjuna {
   module demo {
     module jts {
      module explicitremotebank {

        interface Account :
        {
          float balance(<emphasis>in CosTransactions::Control ctrl</emphasis>);
          void credit( <emphasis>in CosTransactions::Control ctrl</emphasis>, in float value );
          void debit( <emphasis>in CosTransactions::Control ctrl</emphasis>, in float value );
        };

        exception NotExistingAccount
        { };

        interface Bank
        {
          Account create_account( in string name );
          Account get_account( in string name )
            raises( NotExistingAccount );
        };
       };
      };
     };
   };
   </programlisting>
                        <para>The following portion of code illustrates how a JTS transaction is started
  and terminated when the client asks to transfer money from one account to another.
  This also describes what are &PARENT_PRODUCT; packages that need to be used in order
  to obtain appropriate objects instances (such Current).</para>
                        <para>Note: The code below is a simplified view of the BankClient.java program. Only
  the transfer operation is illustrated; other operations manage transactions
  in the same way. (see for details the src/com/arjuna/demo/jts/explicitremotebank/BankClient.java)</para>
                        <programlisting role="JAVA" language="Java">package com.arjuna.demo.jta.remotebank;
<emphasis>import com.arjuna.ats.jts.OTSManager;</emphasis>
public class BankClient
{
   private Bank _bank;
   ....
   // This operation is used to make a transfer
   //from an account to another account
   private void makeTransfer()
   {
     //get the name of the supplier(name_supplier) and
     // the consumer(name_consumer)
     // get the amount to transfer (famount)
     ...
     try
      {
       //the following instruction asks a specific
       //&PARENT_PRODUCT; class to obtain a Current instance
       <emphasis>Current current = OTSManager.get_current(); </emphasis>
       System.out.println("Beginning a User transaction to get balance");
       <emphasis>current.begin()</emphasis>;

       Account supplier = _bank.get_account( name_supplier );
       Account consumer = _bank.get_account( name_consumer );
       supplier.debit( <emphasis>current.get_control()</emphasis>, famount );
       <emphasis>//The Control is explicitly propagated</emphasis>
       consumer.credit( <emphasis>current.get_control()</emphasis>, famount );
       <emphasis>current.commit( )</emphasis>;
      }
     catch (Exception e)
      {
       ...
      }
   }</programlisting>
                        <para>Since JTS is used invocations against an ORB are needed, such ORB and Object
    Adapter instantiation and initialisation. To ensure a better portability,
    the  ORB Portability API provides a set of
    methods that can be used as described below. </para>
                        <programlisting role="JAVA" language="Java">public static void main( String [] args )
{
  ....
  <emphasis>myORB = ORB.getInstance("test");// Create an ORB instance
  myORB.initORB(args, null); //Initialise the ORB
  </emphasis>
  org.omg.CORBA.Object obj = null;
  try
  {
     //Read the reference string from a file then convert to Object
     ....
      obj = myORB.orb().string_to_object(stringTarget);
  }
  catch ( java.io.IOException ex )
  {
     ...
  }
  Bank bank = BankHelper.narrow(obj);
   ....
}
</programlisting>
                        <para>The Bank object has mainly two operations: creating an account, which is added
  in the account list, and returning an Account object. No transactional instruction
  is performed by the Bank object. The following lines decribe the implementation
  of the Bank CORBA object</para>
                        <programlisting role="JAVA" language="Java">public class BankImpl extends BankPOA {
     public BankImpl(OA oa)
     {
       _accounts = new java.util.Hashtable();
       _oa = oa;
     }

     public Account create_account( String name )
     {
         AccountImpl acc = new AccountImpl(name);
         _accounts.put( name, acc );
          return com.arjuna.demo.jts.remotebank.AccountHelper.
               narrow(_oa.corbaReference(acc));
     }

     public Account get_account(String name)
          throws NotExistingAccount
     {
      AccountImpl acc = ( AccountImpl ) _accounts.get( name );
      if ( acc == null )
       throw new NotExistingAccount("The Account requested does not exist");
      return com.arjuna.demo.jts.remotebank.AccountHelper.
           narrow(_oa.corbaReference(acc));
     }
     private java.util.Hashtable _accounts;// Accounts created by the Bank
     private OA _oa;
}</programlisting>
                        <para>After having defined an implementation of the Bank object, we should now create
  an instance and make it available for client requests. This is the role of the
  Bank Server that has the responsibility to create the ORB and the Object Adapater
  instances, then the Bank CORBA object that has its object reference stored in
  a file well known by the bank client. The following lines describe how the Bank
  server is implemented.</para>
                        <programlisting role="JAVA" language="Java">public class BankServer
{
      public static void main( String [] args )
      {
       ORB myORB = null;
       RootOA myOA = null;
       try
       {
       <emphasis> myORB = ORB.getInstance("ServerSide");
        myOA = OA.getRootOA(myORB);
        myORB.initORB(args, null);
        myOA.initOA();</emphasis>
        ....
        <emphasis>BankImpl bank = new BankImpl(myOA);</emphasis>

        String reference = <emphasis>myORB.orb().
             object_to_string(myOA.corbaReference(bank))</emphasis>;
        //Store the Object reference in the file
        ...

        System.out.println("The bank server is now ready...");
        <emphasis>myOA.run();</emphasis>
      }
}</programlisting>
                        <para>The Account object provides mainly three methods balance,
  credit and withdraw.
  However, in order to provide the transactional behaviour, rather than to modify
  the current account directly (according to credit or withdraw) this task is
  delegated to an AccountResource object that is able, according to the transaction
  outcome, to set the account value either to its initial state or its final state.</para>
                        <para>  The AccountResource object is in fact an object that implements the org.omg.CosTransactions.Resource,
  then able to participate to the transaction commitment. For this aim, the Account
  object has to register the AccountResource object as a participant, after having
  obtaining the reference of the org.omg.CosTransactions.Coordinator object ,
  itself obtained via the org.omg.CosTransactions.Control object</para>
                        <programlisting role="JAVA" language="Java">
package com.arjuna.demo.jta.remotebank;

import org.omg.CosTransactions.*;
import ....

public class AccountImpl extends AccountPOA
{
   float _balance;
   AccountResource accRes = null;

   public Account(String name )
   {
     _name = name;
     _balance = 0;
   }

   public float balance(Control ctrl)
   {
     return getResource(ctrl).balance();;
   }

   public void credit(Control ctrl, float value )
   {
     getResource(ctrl).credit( value );
   }

   public void debit(Control ctrl, float value )
   {
     getResource(ctrl).debit( value );
   }

   public AccountResource getResource(Control control)
   {
      try
      {
         if (accRes == null) {
            accRes = new AccountResource(this, _name) ;
           <emphasis>
           //The invocation on the ORB illustrates the fact that the same
           //ORB instance created by the Bank Server is returned.
           ref = org.omg.CosTransactions.ResourceHelper.
              narrow(OA.getRootOA(ORB.getInstance("ServerSide")).
              corbaReference(accRes));
           RecoveryCoordinator recoverycoordinator =
              control.get_coordinator().register_resource(ref);</emphasis>
         }
      }
      catch (Exception e){...}
      return accRes;
       }
   ...
}</programlisting>
                        <para>To be considered as a org.omg.CosTransactions.Resource, the AccountResource
  class shall extends the class org.omg.CosTransactions.ResourcePOA generated
  by the CORBA IDL compiler. The AccountRessource provides similar methods as
  the Account class (credit, withdraw and balance) with the appropriate methods
  to participate to the 2PC protocol. The following portion of code describes
  how the methods prepare, commit
  and rollback are implemented.</para>
                        <programlisting role="JAVA" language="Java">public class AccountResource <emphasis>extends org.omg.CosTransactions.ResourcePOA</emphasis>
{
   public AccountResource(Account account, String name )
   {
     _name = name;
     _account = account;
     _initial_balance = account._balance;
     _current_balance = _initial_balance;
   }

   public float balance()
   {
     return _current_balance;
   }

   public void credit( float value )
   {
     _current_balance += value;
   }

   public void debit( float value )
   {
     _current_balance -= value;
   }

   <emphasis>public org.omg.CosTransactions.Vote prepare()</emphasis>
	   throws org.omg.CosTransactions.HeuristicMixed,
	   org.omg.CosTransactions.HeuristicHazard
  {
    if ( _initial_balance == _current_balance )
       return org.omg.CosTransactions.Vote.VoteReadOnly;
    if ( _current_balance &lt; 0 )
       return org.omg.CosTransactions.Vote.VoteRollback;
    return org.omg.CosTransactions.Vote.VoteCommit;
  }

   <emphasis>public void rollback()</emphasis>
     throws org.omg.CosTransactions.HeuristicCommit,
     org.omg.CosTransactions.HeuristicMixed,
     org.omg.CosTransactions.HeuristicHazard
   {
     //Nothing to do
   }

   <emphasis>public void commit()</emphasis>
     throws org.omg.CosTransactions.NotPrepared,
     org.omg.CosTransactions.HeuristicRollback,
     org.omg.CosTransactions.HeuristicMixed,
     org.omg.CosTransactions.HeuristicHazard
   {
      _account._balance = _current_balance;
   }

   public void commit_one_phase()
     throws org.omg.CosTransactions.HeuristicHazard
   {
     _account._balance = _current_balance;
   }

   .....</programlisting>
                        <programlisting role="JAVA" language="Java">   private float _initial_balance;
   private float _current_balance;
   private Account _account;

   }
 </programlisting>
                    </section>
                    <section>
                        <title>Sample Application Source Code</title>
                        <para>Full source code for the banking application is included to provide you with
  a starting point for experimentation. </para>
                        <itemizedlist>
                            <listitem>JTS Version
    <itemizedlist><listitem>src/com/arjuna/demo/jts/explicitremotebank/Bank.idl</listitem><listitem>src/com/arjuna/demo/jts/explicitremotebank/BankClient.java</listitem><listitem>src/com/arjuna/demo/jts/explicitremotebank/BankServer.java</listitem><listitem>src/com/arjuna/demo/jts/explicitremotebank/BankImpl.java</listitem><listitem>src/com/arjuna/demo/jts/explicitremotebank/AccountImpl.java"&gt;AccountImpl.java</listitem><listitem>src/com/arjuna/demo/jts/explicitremotebank/AccountResource.java</listitem></itemizedlist>
					</listitem>
                        </itemizedlist>
                    </section>
                    <section>
                        <title>How the Banking Application is build using JTS interfaces</title>
                        <para>The bank client is an application program able to manage transactions either
  in a direct or indirect management mode, respectively with the interfaces org.omg.CosTransactions.TransactionFactory
  and org.omg.CosTransactions.Terminator or with the org.omg.CosTransactions.Current
  interface. Transactions created by the client in the Banking application are
  done in the indirect mode. </para>
                        <para>Invoking a remote object within a CORBA environment means that the remote object
  implements a CORBA interface defined in a CORBA idl file. The following Bank.idl
  describes the interfaces then the possible kind of distributed CORBA objects
  involved in the banking application. Only the Account interface inherits the
  CosTransactions::TransactionalObject interface, this means that an Account CORBA
  object is expected to invoked within a scope of transaction and the transactional
  context is implicitly propagated.</para>
                        <programlisting role="JAVA" language="Java">
module arjuna {
   module demo {
     module jts {
      module remotebank {

        interface Account : <emphasis>CosTransactions::TransactionalObject</emphasis>
        {
          float balance();
          void credit( in float value );
          void debit( in float value );
        };

        exception NotExistingAccount
        { };

        interface Bank
        {
          Account create_account( in string name );
          Account get_account( in string name )
            raises( NotExistingAccount );
        };
       };
      };
     };
   };</programlisting>
                        <para>The following portion of code illustrates how a JTS transaction is started
  and terminated when the client asks to transfer money from one account to another.
  This also describes what are &PARENT_PRODUCT; packages that need to be used in order
  to obtain appropriate standard JTS API objects instances (such Current).</para>
                        <para>Note: The code below is a simplified view of the BankClient.java program. Only
  the transfer operation is illustrated; other operations manage transactions
  in the same way. (see for details the src/com/arjuna/demo/jts/localbank/BankClient.java)</para>
                        <programlisting role="JAVA" language="Java">
package com.arjuna.demo.jta.remotebank;
<emphasis>import com.arjuna.ats.jts.OTSManager;
</emphasis>
public class BankClient
{
   private Bank _bank;
   ....
   // This operation is used to make a transfer
   // from an account to another account
   private void makeTransfer()
   {
     //get the name of the supplier(name_supplier)
     // and the consumer(name_consumer)
     // get the amount to transfer (famount)
     ...

     try
      {
       //the following instruction asks a
       // specific &PARENT_PRODUCT; class
       // to obtain a Current instance
       <emphasis>Current current = OTSManager.get_current(); </emphasis>
       System.out.println("Beginning a User
              transaction to get balance");
       <emphasis>current.begin()</emphasis>;

       Account supplier = _bank.get_account( name_supplier );
       Account consumer = _bank.get_account( name_consumer );
       supplier.debit( famount );
       consumer.credit( famount );

       <emphasis>current.commit( )</emphasis>;
      }
     catch (Exception e)
      {
       ...
      }
   }</programlisting>
                        <para>Since JTS is used invocations against an ORB are needed, such ORB and Object
    Adapter instantiation and initialisation. To ensure a better portability,
    the ORB Portability API provides a set of
    methods that can be used as described below. </para>
                        <programlisting role="JAVA" language="Java">public static void main( String [] args )
{  ....
<emphasis>  myORB = ORB.getInstance("test");
     myORB.initORB(args, null); //Initialise the ORB

     </emphasis>org.omg.CORBA.Object obj = null;
     try
      {
        //Read the reference string from
        // a file then convert to Object
        ....
        obj = myORB.orb().string_to_object(stringTarget);
      }
     catch ( java.io.IOException ex )
     {
       ...
     }
     Bank bank = BankHelper.narrow(obj);
    ....
}
</programlisting>
                        <para>The Bank object has mainly two operations: creating an account, which is added
  in the account list, and returning an Account object. No transactional instruction
  is performed by the Bank object. The following lines decribe the implementation
  of the Bank CORBA object</para>
                        <programlisting role="JAVA" language="Java">public class BankImpl extends BankPOA {
     public BankImpl(OA oa)
     {
       _accounts = new java.util.Hashtable();
       _oa = oa;
     }

     public Account create_account( String name )
     {
         AccountImpl acc = new AccountImpl(name);
         _accounts.put( name, acc );
          return com.arjuna.demo.jts.remotebank.AccountHelper.
               narrow(_oa.corbaReference(acc));
     }

     public Account get_account(String name)
          throws NotExistingAccount
     {
        AccountImpl acc = ( AccountImpl ) _accounts.get( name );
        if ( acc == null )
          throw new NotExistingAccount("The Account requested
                      does not exist");
        return com.arjuna.demo.jts.remotebank.AccountHelper.
             narrow(_oa.corbaReference(acc));
     }
     private java.util.Hashtable _accounts;
        // Accounts created by the Bank
     private OA _oa;
}</programlisting>
                        <para>After having defined an implementation of the Bank object, we should now create
  an instance and make it available for client requests. This is the role of the
  Bank Server that has the responsibility to create the ORB and the Object Adapater
  instances, then the Bank CORBA object that has its object reference stored in
  a file well known by the bank client. The following lines describe how the Bank
  server is implemented.</para>
                        <programlisting role="JAVA" language="Java">public class BankServer
{
      public static void main( String [] args )
      {
       ORB myORB = null;
       RootOA myOA = null;
       try
       {
       <emphasis> myORB = ORB.getInstance("ServerSide");
        myOA = OA.getRootOA(myORB);
        myORB.initORB(args, null);
        myOA.initOA();</emphasis>
        ....
        <emphasis>BankImpl bank = new BankImpl(myOA);</emphasis>

        String reference = <emphasis>myORB.orb().
               object_to_string(myOA.corbaReference(bank))</emphasis>;
        //Store the Object reference in the file
        ...
        System.out.println("The bank server is now ready...");
        <emphasis>myOA.run();</emphasis>
      }
}</programlisting>
                        <para>The Account object provides mainly three methods balance,
  credit and withdraw.
  However, in order to provide the transactional behaviour, rather than to modify
  the current account directly (according to credit or withdraw) this task is
  delegated to an AccountResource object that is able, according to the transaction
  outcome, to set the account value either to its initial state or its final state.</para>
                        <para>  The AccountResource object is in fact an object that implements the org.omg.CosTransactions.Resource,
  then able to participate to the transaction commitment. For this aim, the Account
  object has to register the AccountResource object as a participant, after having
  obtaining the reference of the org.omg.CosTransactions.Coordinator object ,
  itself obtained via the org.omg.CosTransactions.Control object</para>
                        <programlisting role="JAVA" language="Java">package com.arjuna.demo.jta.remotebank;
import ....

public class AccountImpl extends AccountPOA
{
   float _balance;
   AccountResource accRes = null;

   public Account(String name )
   {
     _name = name;
     _balance = 0;
   }

   public float balance()
   {
     return getResource().balance();;
   }

   public void credit( float value )
   {
     getResource().credit( value );
   }

   public void debit( float value )
   {
     getResource().debit( value );
   }


   public AccountResource getResource()
   {
     try
     {
      if (accRes == null) {
        accRes = new AccountResource(this, _name) ;
        <emphasis>//The invocation on the ORB illustrates the
        // fact that the same ORB instance created
        // by the Bank Server is returned.
        ref = org.omg.CosTransactions.ResourceHelper.
	     narrow(OA.getRootOA(ORB.getInstance("ServerSide")).
	     corbaReference(accRes));
        RecoveryCoordinator recoverycoordinator = OTSManager.get_current().
	     get_control().get_coordinator().register_resource(ref);
       </emphasis>
      }
    }
    catch (Exception e)
    {....}
      return accRes;
   }
   ...
}</programlisting>
                        <para>To be considered as a org.omg.CosTransactions.Resource, the AccountResource
  class shall extends the class org.omg.CosTransactions.ResourcePOA generated
  by the CORBA IDL compiler. The AccountResource provides similar methods as
  the Account class (credit, withdraw and balance) with the appropriate methods
  to participate to the 2PC protocol. The following portion of code describes
  how the methods prepare, commit
  and rollback are implemented.</para>
                        <programlisting role="JAVA" language="Java">
public class AccountResource <emphasis>
      extends org.omg.CosTransactions.ResourcePOA</emphasis>
{
   public AccountResource(Account account, String name )
   {
     _name = name;
     _account = account;
     _initial_balance = account._balance;
     _current_balance = _initial_balance;
   }

   public float balance()
   {
     return _current_balance;
   }

   public void credit( float value )
   {
     _current_balance += value;
   }

   public void debit( float value )
   {
     _current_balance -= value;
   }

   <emphasis>public org.omg.CosTransactions.Vote prepare()</emphasis>
	   throws org.omg.CosTransactions.HeuristicMixed,
	   org.omg.CosTransactions.HeuristicHazard
	   {
	   	  if ( _initial_balance == _current_balance )
	          return org.omg.CosTransactions.Vote.VoteReadOnly;
	        if ( _current_balance &lt; 0 )
                  return org.omg.CosTransactions.Vote.VoteRollback;
              return org.omg.CosTransactions.Vote.VoteCommit;
          }

   <emphasis>public void rollback()</emphasis>
     throws org.omg.CosTransactions.HeuristicCommit,
     org.omg.CosTransactions.HeuristicMixed,
     org.omg.CosTransactions.HeuristicHazard
   {
     //Nothing to do
   }

   <emphasis>public void commit()</emphasis>
     throws org.omg.CosTransactions.NotPrepared,
     org.omg.CosTransactions.HeuristicRollback,
     org.omg.CosTransactions.HeuristicMixed,
     org.omg.CosTransactions.HeuristicHazard
   {
      _account._balance = _current_balance;
   }

   public void commit_one_phase()
     throws org.omg.CosTransactions.HeuristicHazard
   {
     _account._balance = _current_balance;
   }

   ....
   private float _initial_balance;
   private float _current_balance;
   private Account _account;

   }
 </programlisting>
                    </section>
                    <section>
                        <title>Sample Application Source Code</title>
                        <para>Full source code for the banking application is included to provide you with
  a starting point for experimentation. </para>
                        <itemizedlist>
                            <listitem>JTS Version
    <itemizedlist><listitem>src/com/arjuna/demo/jts/remotebank/Bank.idl"&gt;Bank.idl</listitem><listitem>src/com/arjuna/demo/jts/remotebank/BankClient.java</listitem><listitem>src/com/arjuna/demo/jts/remotebank/BankServer.java"&gt;BankServer.java</listitem><listitem>src/com/arjuna/demo/jts/remotebank/BankImpl.java</listitem><listitem>src/com/arjuna/demo/jts/remotebank/AccountImpl.java"&gt;AccountImpl.java</listitem><listitem>src/com/arjuna/demo/jts/remotebank/AccountResource.java</listitem></itemizedlist>
					</listitem>
                        </itemizedlist>
                    </section>
                    <section>
                        <title>How the Banking Application is build using JTS interfaces</title>
                        <para>From an architectural point of view of JTS, the bank client is considered as
  an application program able to manage transactions either in a direct or indirect
  management mode, respectively with the interfaces org.omg.CosTransactions.TransactionFactory
  and org.omg.CosTransactions.Terminator or with the org.omg.CosTransactions.Current
  interface. Transactions created by the client in the Banking application are
  done in the indirect mode. </para>
                        <para> The following portion of code illustrates how a JTS transaction is started
  and terminated when the client asks to transfer money from one account to another.
  This also describes what are &PARENT_PRODUCT; packages that need to be used in order
  to obtain appropriate objects instances (such Current).</para>
                        <para>Note: The code below is a simplified view of the BankClient.java program. Only
  the transfer operation is illustrated; other operations manage transactions
  in the same way. (see for details the src/com/arjuna/demo/jts/localbank/BankClient.java)</para>
                        <blockquote>
                            <programlisting role="JAVA" language="Java">
package com.arjuna.demo.jta.localbank;
<emphasis>import com.arjuna.ats.jts.OTSManager;</emphasis>

public class BankClient
{
   private Bank _bank;
    ....
   // This operation is used to make
   //a transfer from an account to another account
   private void makeTransfer()
   {
     System.out.print("Take money from : ");
     String name_supplier = input();

     System.out.print("Put money to : ");
     String name_consumer = input();

     System.out.print("Transfert amount : ");
     String amount = input();

     float famount = 0;
     try
      {
        famount = new Float( amount ).floatValue();
      }
     catch ( java.lang.Exception ex )
      {
        System.out.println("Invalid float number,
                     abort operation...");
        return;
      }

     try
      {
       //the following instruction asks a specific
       // &PARENT_PRODUCT; class to obtain a Current instance
       <emphasis>Current current = OTSManager.get_current(); </emphasis>
       System.out.println("Beginning a User
                     transaction to get balance");
       <emphasis>current.begin()</emphasis>;

       Account supplier = _bank.get_account( name_supplier );
       Account consumer = _bank.get_account( name_consumer );
       supplier.debit( famount );
       consumer.credit( famount );

       <emphasis>current.commit( )</emphasis>;
      }
     catch (Exception e)
      {
       System.err.println("ERROR - "+e);
      }
   }
   </programlisting>
                            <para>Since JTS is used invocations against an ORB are needed, such ORB and Object
    Adapter instantiation and initialisation. To ensure a better portability,
    the  ORB Portability API provides a set of
    methods that can be used as described below. </para>
                            <programlisting role="JAVA" language="Java">
public static void main( String [] args )
{
  try
   { <emphasis>
    // Create an ORB instance
    myORB = ORB.getInstance("test");
    //Obtain the Root POA
    myOA = OA.getRootOA(myORB);
    //Initialise the ORB
    myORB.initORB(args, null);
    //Initialise the POA
    myOA.initOA();
     ....
     </emphasis>
   }
   catch(Exception e)
   { ....}
}
</programlisting>
                        </blockquote>
                        <para>The Bank object has mainly two operations: creating an account, which is added
  in the account list, and returning an Account object. No transactional instruction
  is performed by the Bank object</para>
                        <programlisting role="JAVA" language="Java">package com.arjuna.demo.jta.localbank;
public class Bank {
   private java.util.Hashtable _accounts;

   public Bank()
   {
     _accounts = new java.util.Hashtable();
   }

   public Account create_account( String name )
   {
     Account acc = new Account(name);
     _accounts.put( name, acc );
      return acc;
   }

   public Account get_account(String name)
   throws NotExistingAccount
   {
     Account acc = ( Account ) _accounts.get( name );
     if ( acc == null )
       throw new NotExistingAccount("The Account
                      requested does not exist");
     return acc;
   }
}
</programlisting>
                        <para>The Account object provides mainly three methods balance,
  credit and withdraw.
  However, in order to provide the transactional behaviour, rather than to modify
  the current account directly (according to credit or withdraw) this task is
  delegated to an AccountResource object that is able, according to the transaction
  outcome, to set the account value either to its initial state or its final state.</para>
                        <para>  The AccountResource object is in fact an object that implements the org.omg.CosTransactions.Resource,
  then able to participate to the transaction commitment. For this aim, the Account
  object has to register the AccountResource object as a participant, after having
  obtaining the reference of the org.omg.CosTransactions.Coordinator object ,
  itself obtained via the org.omg.CosTransactions.Control object</para>
                        <programlisting role="JAVA" language="Java">
package com.arjuna.demo.jta.localbank;

public class Account
{
 float _balance;
 AccountResource accRes = null;

 public Account(String name )
 {
   _name = name;
   _balance = 0;
 }

 public float balance()
 {
   return getResource().balance();;
 }

 public void credit( float value )
 {
   getResource().credit( value );
 }

 public void debit( float value )
 {
   getResource().debit( value );
 }

 public AccountResource getResource()
 {
   try
   {
    if (accRes == null) {
     accRes = new AccountResource(this, _name) ;
     <emphasis>Resource  ref = org.omg.CosTransactions.ResourceHelper.
      narrow(OA.getRootOA(ORB.getInstance("test")).corbaReference(accRes));</emphasis>
     <emphasis>RecoveryCoordinator recoverycoordinator = OTSManager.get_current().
      get_control().get_coordinator().register_resource(ref);</emphasis>
    }
  }
  catch (Exception e)
   {...}
   return accRes;
 }
  ...
}</programlisting>
                        <para>To be considered as a org.omg.CosTransactions.Resource, the AccountResource
  class shall extends the class org.omg.CosTransactions.ResourcePOA generated
  by the CORBA IDL compiler. The AccountRessource provides similar methods as
  the Account class (credit, withdraw and balance) with the appropriate methods
  to participate to the 2PC protocol. The following portion of code describes
  how the methods prepare, commit
  and rollback are implemented.</para>
                        <programlisting role="JAVA" language="Java">
public class AccountResource extends org.omg.CosTransactions.ResourcePOA
{
   public AccountResource(Account account, String name )
   {
     _name = name;
     _account = account;
     _initial_balance = account._balance;
     _current_balance = _initial_balance;
   }

   public float balance()
   {
     return _current_balance;
   }

   public void credit( float value )
   {
     _current_balance += value;
   }

   public void debit( float value )
   {
     _current_balance -= value;
   }

   public org.omg.CosTransactions.Vote prepare()
	   throws org.omg.CosTransactions.HeuristicMixed,
	   org.omg.CosTransactions.HeuristicHazard
    {
	  if ( _initial_balance == _current_balance )
       return org.omg.CosTransactions.Vote.VoteReadOnly;
     if ( _current_balance &lt; 0 )
       return org.omg.CosTransactions.Vote.VoteRollback;
     return org.omg.CosTransactions.Vote.VoteCommit;
    }

   public void rollback()
     throws org.omg.CosTransactions.HeuristicCommit,
     org.omg.CosTransactions.HeuristicMixed,
     org.omg.CosTransactions.HeuristicHazard
   {
     //Nothing to do
   }

   public void commit()
     throws org.omg.CosTransactions.NotPrepared,
     org.omg.CosTransactions.HeuristicRollback,
     org.omg.CosTransactions.HeuristicMixed,
     org.omg.CosTransactions.HeuristicHazard
   {
      _account._balance = _current_balance;
   }

   public void commit_one_phase()
     throws org.omg.CosTransactions.HeuristicHazard
   {
     _account._balance = _current_balance;
   }
   .....
   private float _initial_balance;
   private float _current_balance;
   private Account _account;

   }
 </programlisting>
                    </section>
                    <section>
                        <title>Sample Application Source Code</title>
                        <para>Full source code for the banking application is included to provide you with
  a starting point for experimentation. </para>
                        <itemizedlist>
                            <listitem>JTS Version
    <itemizedlist><listitem>src/com/arjuna/demo/jts/localbank/BankClient.java</listitem><listitem>src/com/arjuna/demo/jts/localbank/Bank.java"&gt;Bank.java</listitem><listitem>src/com/arjuna/demo/jts/localbank/Account.java"&gt;Account.java</listitem><listitem>src/com/arjuna/demo/jts/localbank/AccountResource.java</listitem><listitem>src/com/arjuna/demo/jts/localbank/NotExistingAccount.java"&gt;NotExistingAccount.java</listitem></itemizedlist>
					</listitem>
                        </itemizedlist>
                    </section>
                </section>
            </section>
        </section>
    </section>
    <section>
        <title>Making the Banking Application Persistent</title>
        <para>
					The way the banking application is built and
					deployed in the previous trail does not it make it
					persistent, in such way that any created account can
					be retrieved later after stopping the bank server or
					if the application crashes; moreover, it does not
					allow concurrent access to accounts without leading
					to inconsistent values.
				</para>
        <para>
					Two ways will be presented in this trail on the way
					to build the banking application as a persistent and
					sharable application:
				</para>
        <itemizedlist>
            <listitem>
						Using the &PARENT_PRODUCT; Object For Java
						(TXOJ) mechanisms
						<itemizedlist><listitem>
									Overview of the Transactional Object
									For Java
								</listitem><listitem>
									Deploying the Banking application
									with TXOJ mechanisms
								</listitem></itemizedlist>
					</listitem>
            <listitem>
						Using the JDBC API by considering the banking
						application as a relational database.
						<itemizedlist><listitem>
									Developing applications with JDBC
									and &PARENT_PRODUCT;
								</listitem><listitem>
									The banking application as a
									relational database accessed with
									JDBC
								</listitem></itemizedlist>
					</listitem>
        </itemizedlist>
    </section>
    <section>
        <title>What is Transactional Object For Java</title>
        <para>ArjunaCore exploits object-oriented techniques to present programmers with
  a toolkit of Java classes from which application classes can inherit to obtain
  desired properties, such as persistence and concurrency control. These classes
  form a hierarchy, part of which is shown below.</para>
        <para>
            <imagedata fileref="images/ArjunaCore_Classes.PNG.png" format="PNG"/>
        </para>
        <para>Figure 1 - ArjunaCore class hierarchy.</para>
        <para>Apart from specifying the scopes of transactions, and setting appropriate locks
  within objects, the application programmer does not have any other responsibilities:
  ArjunaCore and Transactional Objects for Java (TXOJ) guarantee that transactional
  objects will be registered with, and be driven by, the appropriate transactions,
  and crash recovery mechanisms are invoked automatically in the event of failures.</para>
        <section>
            <title>Recovery and Persistency</title>
            <para>Making an object persistent and recoverable means that we shall be able to
  store its final state or to retrieve its initial state according to the final
  status of a transaction even in the presence of failures. ArjunaCore provides
  a set of techniques to save to and to retrieve from the Object Store states
  of objects. All objects made persistent with these ArjunaCore mechanisms are
  assigned unique identifiers (instances of the Uid class), when they are created,
  and this is to identify them within the object store. Due to common functionality
  for persistency and recovery required by several applications, objects are stored
  and retrieved from the object store using the same mechanism: the classes OutputObjectState
  and InputObjecState.</para>
            <para>At the root of the class hierarchy, given in Figure 1, is the class StateManager.
  This class is responsible for object activation and deactivation and object
  recovery. The simplified signature of the class is:</para>
            <blockquote>
                <programlisting role="JAVA" language="Java">public abstract class StateManager
{
   public boolean activate ();
   public boolean deactivate (boolean commit);
   public Uid get_uid (); // object’s identifier.

   // methods to be provided by a derived class
   public boolean restore_state (InputObjectState os);
   public boolean save_state (OutputObjectState os);

   protected StateManager ();
   protected StateManager (Uid id);
};</programlisting>
            </blockquote>
            <para> Objects are assumed to be of three possible flavours. They may simply be recoverable,
  in which case StateManager will attempt to generate and maintain appropriate
  recovery information for the object. Such objects have lifetimes that do not
  exceed the application program that creates them. Objects may be recoverable
  and persistent, in which case the lifetime of the object is assumed to be greater
  than that of the creating or accessing application, so that in addition to maintaining
  recovery information StateManager will attempt to automatically load (unload)
  any existing persistent state for the object by calling the activate (deactivate)
  operation at appropriate times. Finally, objects may possess none of these capabilities,
  in which case no recovery information is ever kept nor is object activation/deactivation
  ever automatically attempted.</para>
            <para>According to the its activation or deactivation a transactional object for
  Java move from a passive state to an active state and vice-versa. The fundamental
  life cycle of a persistent object in TXOJ is shown in Figure 2. </para>
            <para>
                <imagedata fileref="images/txoj_lifecycle.PNG.png" format="PNG"/>
            </para>
            <para>Figure 2 - The life cycle of a persistent object.</para>
            <itemizedlist>
                <listitem> The object is initially passive, and is stored in the object store as an
    instance of the class OutputObjectState.</listitem>
                <listitem> When required by an application the object is automatically activated by
    reading it from the store using a read_committed operation and is then converted
    from an InputObjectState instance into a fully-fledged object by the restore_state
    operation of the object.</listitem>
                <listitem> When the application has finished with the object it is deactivated by
    converting it back into an OutputObjectState instance using the save_state
    operation, and is then stored back into the object store as a shadow copy
    using write_uncommitted. This shadow copy can be committed, overwriting the
    previous version, using the commit_state operation. The existence of shadow
    copies is normally hidden from the programmer by the transaction system. Object
    de-activation normally only occurs when the top-level transaction within which
    the object was activated commits.</listitem>
            </itemizedlist>
            <para>While deactivating and activating a transactional object for java, the operations
  save_state and restore_state are respectively invoked. These operations must
  be implemented by the programmer since StateManager cannot detect user level
  state changes. This gives the programmer the ability to decide which parts of
  an object’s state should be made persistent. For example, for a spreadsheet
  it may not be necessary to save all entries if some values can simply be recomputed.
  The save_state implementation for a class Example that has two integer member
  variables called A and B and one String member variable called C could simply
  be:</para>
            <programlisting role="JAVA" language="Java">public boolean save_state(OutputObjectState o)
{
   if (!super.save_state(o))
      return false;
   try
   {
     o.packInt(A);
     o.packInt(B);
     o.packString(C));
   }
   catch (Exception e)
   {
     return false;
   }
   return true;
}</programlisting>
            <para>while, the corresponding restore_state implementation allowing to retrieve
  similar values is:</para>
            <programlisting role="JAVA" language="Java">public boolean restore_state(InputObjectState o)
{
   if (!super.restore_state(o))
      return false;
   try
   {
     A = o.unpackInt();
     B = o.unpackInt();
     S = o.unpackString());
   }
   catch (Exception e)
   {
     return false;
   }
   return true;
}
</programlisting>
            <para>Classes OutputObjectState and InputObjectState provide respectively operations
  to pack and unpack instances of standard Java data types. In other words for
  a standard Java data type, for instance Long or Short, there are corresponding
  methods to pack and unpack, i.e., packLong or packShort and unpackLong or unpackShort.
</para>
            <para><emphasis>Note:</emphasis> it is necessary for all save_state and restore_state
  methods to call super.save_state and super.restore_state. This is to cater for
  improvements in the crash recovery mechanisms.</para>
        </section>
        <section>
            <title>The concurrency controller</title>
            <para> The concurrency controller is implemented by the class LockManager which provides
  sensible default behaviour while allowing the programmer to override it if deemed
  necessary by the particular semantics of the class being programmed. The primary
  programmer interface to the concurrency controller is via the setlock operation.
  By default, the runtime system enforces strict two-phase locking following a
  multiple reader, single writer policy on a per object basis. However, as shown
  in Figure 1, by inheriting from the Lock class it is possible for programmers
  to provide their own lock implementations with different lock conflict rules
  to enable type specific concurrency control.</para>
            <para> Lock acquisition is (of necessity) under programmer control, since just as
  StateManager cannot determine if an operation modifies an object, LockManager
  cannot determine if an operation requires a read or write lock. Lock release,
  however, is under control of the system and requires no further intervention
  by the programmer. This ensures that the two-phase property can be correctly
  maintained.</para>
            <programlisting role="JAVA" language="Java">public abstract class LockManager extends StateManager
{
   public LockResult setlock (Lock toSet, int retry, int timeout);
};</programlisting>
            <para> The LockManager class is primarily responsible for managing requests to set
  a lock on an object or to release a lock as appropriate. However, since it is
  derived from StateManager, it can also control when some of the inherited facilities
  are invoked. For example, LockManager assumes that the setting of a write lock
  implies that the invoking operation must be about to modify the object. This
  may in turn cause recovery information to be saved if the object is recoverable.
  In a similar fashion, successful lock acquisition causes activate to be invoked.</para>
            <para> The code below shows how we may try to obtain a write lock on an object:</para>
            <programlisting role="JAVA" language="Java">public class Example extends LockManager
{
   public boolean foobar ()
   {
     AtomicAction A = new AtomicAction;
     /*
     <emphasis>
     * The ArjunaCore AtomicAction class is here used to create
     * a transaction. Any interface provided by the JTA or
     * JTS interfaces that allow to create transactions can
     * be used in association with the Locking mechanisms
     * described in this trail.</emphasis>
     */
     boolean result = false;

     A.begin();
     if (setlock(new Lock(LockMode.WRITE), 0) == Lock.GRANTED)
     {
       /*
       * Do some work, and TXOJ will
       * guarantee ACID properties.
       */
       // automatically aborts if fails
       if (A.commit() == AtomicAction.COMMITTED)
       {
         result = true;
       }
     }
    else
       A.rollback();

    return result;
   }
}
</programlisting>
        </section>
        <section>
            <title>Further Reading</title>
            <para>More details on Transactional Object For Java can be found in the ArjunaCore
  Programming Guide.</para>
        </section>
        <section>
            <title>Making the Banking Application Persistent with Transactional Object For Java</title>
            <para>The banking application consists of a Bank object that contains a list of Account
  object, which in turn have a String (name) and a float (the value) as member
  variables. It appears clearly that from the persistent point of view, an Account
  Object need to store its name and its current balance or value, while the Bank
  Object need to store the list of accounts that it manages.</para>
            <section>
                <title>Distributed Configuration </title>
                <para>The banking application with Transactional Object for Java (TXOJ) is configured
  to use JTS interfaces as the API to create the transaction, then an ORB to deploy
  it. The &PARENT_PRODUCT; distribution is provided to work with the bundled JacORB version</para>
                <para><emphasis>Note</emphasis>: Ensure that the jacorb jar files are added in your CLASSPATH</para>
            </section>
            <section>
                <title>Delpoy the Application</title>
                <para>- Start the Server</para>
                <blockquote>
                    <programlisting role="JAVA" language="Java">
                        java com.arjuna.demo.jts.txojbank.BankServer
                    </programlisting>
                </blockquote>
                <para>- In a separate window, start the client</para>
                <blockquote>
                    <programlisting role="JAVA" language="Java">
                        java com.arjuna.demo.jts.txojbank.BankClient
                    </programlisting>
                </blockquote>
                <para>As for the demonstrations presented in the previous trails, the same menu is
  presented for the client with a set of operations such creating an account,
  credit/withdraw money to/from an account and making a transfer.</para>
                <para>
                    Building the banking application
  with TXOJ tools
                </para>
            </section>
            <section>
                <title>Building the banking application with TXOJ</title>
            </section>
            <section>
                <title>The Bank IDL</title>
                <para>Since a distributed version has been adopted to present the application with
  Transactional Object for Java, an IDL file named Bank.idl described below is
  needed. The difference with the Bank.idl presented in previous trails is the
  fact that the Bank interface inherits the CosTransactions::TransactionalObject
  interface. Since we consider now that a Bank object need to modify its list
  in a transactional, we consider now a Bank object as a CORBA transactional.</para>
                <programlisting role="JAVA" language="Java">module arjuna {
   module demo {
     module jts {
      module txojbank {

        interface Account : <emphasis>CosTransactions::TransactionalObject</emphasis>
        {
          float balance();
          void credit( in float value );
          void debit( in float value );
        };

        exception NotExistingAccount
        { };

        interface Bank <emphasis>: CosTransactions::TransactionalObject</emphasis>
        {
          Account create_account( in string name );
          Account get_account( in string name )
            raises( NotExistingAccount );
        };
       };
      };
     };
   };</programlisting>
                <itemizedlist>
                    <listitem>The client program
    <para>Basically the client program (src/com/arjuna/demo/jts/txojbank/BankClient.java)
    is equivalent to the one described in the distributed jts version with implicit
    propagation, the difference is on the package name.</para></listitem>
                    <listitem>
                        Implementing the Account Interface
                    </listitem>
                    <listitem>
                        Implementing the Bank Interface
                    </listitem>
                    <listitem>Implementing the Bank Server.</listitem>
                </itemizedlist>
            </section>
            <section>
                <title>Implementing the Account interface</title>
                <para>To take benefit from the persistency and locking mechanism provided by ArjunaCore,
  a user class can inherit from the appropriate class (StateManager for recovery,
  and LockManager for recovery and concurrency control). The AccountImpl class
  that implements the Account interface inherits the LockManager and implements
  the AccountOperations interface generated by the CORBA IDL compiler. Since multiple
  inheritance is not allowed in Java, inheriting the AccountPOA class, as made
  in simple jts remote version, in addition to the LockManager is not possible.
  That we use in this version a CORBA TIE mechanism to associate a servant to
  an CORBA object reference.</para>
                <para>The Java interface definition of the AccountImpl class is given below:</para>
                <programlisting role="JAVA" language="Java">public class AccountImpl <emphasis><emphasis>extends LockManager</emphasis> implements AccountOperations</emphasis>
{
  float _balance;
  String _name;
  public AccountImpl(String name );
  public AccountImpl(Uid uid);
  public void finalize ();
  public float balance();
  public void credit( float value );
  public void debit( float value );
  public boolean save_state (OutputObjectState os, int ObjectType);
  public boolean restore_state (InputObjectState os, int ObjectType);
  public String type();
}</programlisting>
                <itemizedlist>
                    <listitem>Constructors and Destructor
    <para>To use an existing persistent object requires the use of a special constructor
      that is required to take the Uid of the persistent object; the implementation
      of such a constructor is given below:</para>

<programlisting role="JAVA" language="Java">public AccountImpl(Uid uid)
{
  super(uid);
  // Invoking super will lead to invoke the
  //restore_state method of this AccountImpl class
}</programlisting>
<para>There is no particular behaviour applied by the Constructor with the Uid parameter The following constructor is used for a new Account creation.</para>
<programlisting role="JAVA" language="Java">
public AccountImpl(String name )
{
  super(ObjectType.ANDPERSISTENT);
  _name = name;
  _balance = 0;
}
</programlisting>

<para>The destructor of the queue class is only required to call the terminate operation of LockManager.</para>
	</listitem>
                    <programlisting role="JAVA" language="Java">public void finalize ()
{
  super.terminate();
}
</programlisting>
                    <listitem>save_state, restore_state and type
    <para>The implementations of save_state and restore_state are relatively simple
      for this example:</para>

<programlisting role="JAVA" language="Java">public boolean save_state (OutputObjectState os, int ObjectType)
{
   if (!super.save_state(os, ObjectType))
      return false;

   try
   {
      os.packString(_name);
      os.packFloat(_balance);
      return true;
   }
   catch (Exception e)
   {
      return false;
   }
}</programlisting>
<programlisting role="JAVA" language="Java">public boolean restore_state (InputObjectState os, int ObjectType)
{
   if (!super.restore_state(os, ObjectType))
      return false;

   try
   {
     _name = os.unpackString();
     _balance = os.unpackFloat();
      return true;
   }
   catch (Exception e)
   {
      return false;
   }
} </programlisting>

<para>Because the AccountImpl class is derived from the LockManager class, the operation type should be:</para>
	</listitem>
                    <programlisting role="JAVA" language="Java">public String type ()
{
  return "/StateManager/LockManager/BankingAccounts";
}</programlisting>
                    <listitem>account management operations

<programlisting role="JAVA" language="Java">public float balance()
{
  float result = 0;
  if (setlock(new Lock(LockMode.READ), 0) == LockResult.GRANTED)
  {
    result = _balance;
  }
  ...

  return result;
}</programlisting>

						<para> Since the balance operation consists only to get the current balance,
      acquiring a lock in READ mode is enough. This is not the case of the credit
      and debit methods that need to modify the current balance, that is a WRITE
      mode is needed.</para>
<programlisting role="JAVA" language="Java">
public void credit( float value )
{
  if (setlock(new Lock(LockMode.WRITE), 0) == LockResult.GRANTED)
  {
    _balance += value;
  }
  ...
}

public void debit( float value )
{
  if (setlock(new Lock(LockMode.WRITE), 0) == LockResult.GRANTED)
  {
    _balance -= value;
  }
  ...
}</programlisting>
					</listitem>
                </itemizedlist>
            </section>
            <section>
                <title>Sample Application Source Code</title>
                <para>Full source code for the src/com/arjuna/demo/jts/txojbank/AccountImpl.java"&gt;AccountImpl
  class is included to provide you with a starting point for experimentation.</para>
            </section>
            <section>
                <title>Implementing the Bank interface</title>
                <para>To take benefit from the persistency and locking mechanism provided by ArjunaCore,
  a user class can inherit from the appropriate class (StateManager for recovery,
  and LockManager for recovery and concurrency control). The BankImpl class that
  implements the Bank interface inherits the LockManager and implements the BankOperations
  interface generated by the CORBA IDL compiler. Since multiple inheritance is
  not allowed in Java, inheriting the BankPOA class, as made in simple jts remote
  version, in addition to the LockManager is not possible. That we use in this
  version a CORBA TIE mechanism to associate a servant to an CORBA object reference.</para>
                <para>The Java interface definition of the BankImpl class is given below:</para>
                <programlisting role="JAVA" language="Java">public class BankImpl extends LockManager implements BankOperations
{
  public BankImpl(OA oa);
  public BankImpl(Uid uid, OA oa);
  public BankImpl(Uid uid);
  public Account create_account( String name );
  public Account get_account( String name );
  public boolean save_state (OutputObjectState os, int ObjectType);
  public boolean restore_state (InputObjectState os, int ObjectType);
  public String type();

  public static final int ACCOUNT_SIZE = 10;
  // ACCOUNT_SIZE is the maximum number of accounts
  private String [] accounts;
  private int numberOfAccounts;
  private ORB _orb;
  private OA _oa;
  private java.util.Hashtable _accounts; //The list of accounts

}</programlisting>
                <itemizedlist>
                    <listitem>Constructors and Destructor
  <para>To use an existing persistent object requires the use of a special constructor
      that is required to take the Uid of the persistent object; the implementation
      of such a constructor is given below:</para>

<programlisting role="JAVA" language="Java">public BankImpl(Uid uid)
{
  super(uid);
  _accounts = new java.util.Hashtable();
  numberOfAccounts = 0;
  accounts = new String[ACCOUNT_SIZE];
}</programlisting>
<para>The following constructor is invoked during the first creation of the Bank Object.</para>
<programlisting role="JAVA" language="Java">
public BankImpl(OA oa)
{ super(ObjectType.ANDPERSISTENT);
  _accounts = new java.util.Hashtable();
  _oa = oa;
  numberOfAccounts = 0;
  accounts = new String[ACCOUNT_SIZE];
}</programlisting>
<para>The following constructor is invoked on successive BankServer restart.
    A bank already exists and should be recreated. Invoking super or the constructor
    of the inherited class leads to execute the restore_state method, described
    below, of the BankImpl class to rebuild the list of accounts previously
    created, if any.</para>
<programlisting role="JAVA" language="Java">
public BankImpl(Uid uid, OA oa)
{ super(uid);
  _accounts = new java.util.Hashtable();
  _oa = oa;
  numberOfAccounts = 0;
  accounts = new String[ACCOUNT_SIZE];
}
</programlisting>

	<para>The destructor of the queue class is only required to call the terminate operation of LockManager.</para>
		</listitem>
                </itemizedlist>
                <blockquote>
                    <programlisting role="JAVA" language="Java">public void finalize ()
{
  super.terminate();
}
</programlisting>
                </blockquote>
                <itemizedlist>
                    <listitem>account management operations

<programlisting role="JAVA" language="Java">public Account create_account( String name )
{
  AccountImpl acc;
  AccountPOA account = null;
  //Attempt to obtain the lock for change
  if (setlock(new Lock(LockMode.WRITE), 0) == LockResult.GRANTED)
   {
     //Check if the maximum number of accounts is not reached
     if (numberOfAccounts &lt; ACCOUNT_SIZE)
     {
     acc = new AccountImpl(name); //Create a new account
     //Use the TIE mechanism to create a CORBA object
      account = new AccountPOATie(acc);
      //Add the account to the list of accounts that
      //facilitate to retrieve accounts
      _accounts.put( name, acc);
       //The Uid of the created account is put in the array
       accounts[numberOfAccounts] = acc.get_uid().toString();
       numberOfAccounts++;
     }
  }
  return com.arjuna.demo.jts.txojbank.
       AccountHelper.narrow(_oa.corbaReference(account));
}

public Account get_account(String name)
  throws NotExistingAccount
{
  // Only the hashtable list is used to retrieve the account
  AccountImpl acc = ( AccountImpl ) _accounts.get( name );
  AccountPOA account = new AccountPOATie(acc);
  if ( acc == null )
     throw new NotExistingAccount("The Account
        requested does not exist");
  return com.arjuna.demo.jts.txojbank.
    AccountHelper.narrow(_oa.corbaReference(account));
}</programlisting>

			</listitem>
                </itemizedlist>
                <itemizedlist>
                    <listitem>save_state, restore_state and type

<programlisting role="JAVA" language="Java">public boolean save_state (OutputObjectState os, int ObjectType)
{
   if (!super.save_state(os, ObjectType))
     return false;

   try
   {
     os.packInt(numberOfAccounts);
     if (numberOfAccounts &gt; 0)
     {
      // All Uid located in the array will be saved
      for (int i = 0; i &lt; numberOfAccounts; i++)
        os.packString(accounts[i]);
     }
     return true;
   }
   catch (Exception e)
   {
     return false;
   }
}</programlisting>
<programlisting role="JAVA" language="Java">public boolean restore_state (InputObjectState os, int ObjectType)
{
   if (!super.restore_state(os, ObjectType))
   {
     return false;
   }
   try
   {
      numberOfAccounts = os.unpackInt();

      if (numberOfAccounts &gt; 0)
      {
        for (int i = 0; i &lt; numberOfAccounts; i++)
        {
          accounts[i] = os.unpackString();
          //each stored Uid is re-used to recreate
          //a stored account object
          AccountImpl acc = new AccountImpl(new Uid(accounts[i]));
          acc.activate();
          //Once recreated the account object
          //is activated and added to the list.
         _accounts.put( acc.getName(), acc);
        }
      }
      return true;
   }
   catch (Exception e)
   {
      return false;
   }
} </programlisting>
<programlisting role="JAVA" language="Java">public String type ()
{
   return "/StateManager/LockManager/BankServer";
}</programlisting>

					</listitem>
                </itemizedlist>
            </section>
            <section>
                <title>Sample Application Source Code</title>
                <para>Full source code for the src/com/arjuna/demo/jts/txojbank/BankImpl.java"&gt;BankImpl
  class is included to provide you with a starting point for experimentation.</para>
            </section>
            <section>
                <title>Implementing the BankServer</title>
                <para>The role of the BankServer class is mainly to initialise the ORB and the Object
  Adapter and to create the default Bank object responsible to create banking
  accounts. </para>
                <para>Globally the BankServer has the following structure.</para>
                <itemizedlist>
                    <listitem>Initialise the ORB
    <para>This done using the ORB Portability API</para>
  </listitem>
                    <blockquote>
                        <programlisting role="JAVA" language="Java">...
myORB = ORB.getInstance("ServerSide");
myOA = OA.getRootOA(myORB);
myORB.initORB(args, null);
myOA.initOA();
...
</programlisting>
                    </blockquote>
                    <listitem>Create the BankImpl object, an instance that implements the Bank interface.
    Two ways are provided to build such Bank object according to the fact it's
    the first time we create such object or not. This depends on the existence
    or not of the file named "<itemizedlist>
      " that should contain
    the Uid of the BankImpl object.
    <listitem>
    </listitem>
    </itemizedlist>
    <blockquote><programlisting role="JAVA" language="Java">...
java.io.FileInputStream file = new java.io.FileInputStream("UidBankFile");
java.io.InputStreamReader input = new java.io.InputStreamReader(file);
java.io.BufferedReader reader = new java.io.BufferedReader(input);
String stringUid = reader.readLine();
file.close();
_bank = new BankImpl(new Uid(stringUid), myOA);
boolean result =_bank.activate();
...
</programlisting></blockquote>
    <itemizedlist><listitem>If the file does not exist, a new BankImpl object is created, then the
        Uid of the created object is stored in the file named "UidBankFile"</listitem></itemizedlist>
    <blockquote><programlisting role="JAVA" language="Java">...
_bank = new BankImpl(myOA);
java.io.FileOutputStream file = new java.io.FileOutputStream("UidBankFile");
java.io.PrintStream pfile=new java.io.PrintStream(file);
pfile.println(_bank.get_uid().toString());
file.close();
...</programlisting></blockquote>
  </listitem>
                    <listitem>Store the CORBA object reference of the BankImpl object in a file in such
    way the client can retrieve it from that file.</listitem>
                </itemizedlist>
            </section>
            <section>
                <title>Sample Application Source Code</title>
                <para>Full source code for the src/com/arjuna/demo/jts/txojbank/BankServer.java"&gt;BankServer
  class is included to provide you with a starting point for experimentation.</para>
            </section>
        </section>
        <section>
            <title>Developing applications with JDBC and &PARENT_PRODUCT; JTS</title>
            <para>&PARENT_PRODUCT; JTS supports the construction of both local and distributed transactional
  applications which access databases using the JDBC APIs. JDBC supports
  two-phase commit of transactions, and is similar to the XA X/Open standard.
  The JDBC support is found in the com.arjuna.ats.jdbc package.</para>
            <section>
                <title>Transactional Driver</title>
                <para>The &PARENT_PRODUCT; JTS approach to incorporating JDBC connections within transactions
  is to provide transactional JDBC drivers through which all interactions occur.
  These drivers intercept all invocations and ensure that they are registered
  with, and driven by, appropriate transactions. There is a single type of transactional
  driver through which any JDBC driver can be driven; obviously if the database
  is not transactional then ACID properties cannot be guaranteed. This driver
  is com.arjuna.ats.jdbc.TransactionalDriver, which implements the java.sql.Driver
  interface.</para>
                <para>The driver may be directly instantiated and used within an application. For
  example:</para>
                <programlisting role="JAVA" language="Java"> TransactionalDriver arjunaJDBC2Driver = new TransactionalDriver(); </programlisting>
                <para>It can be registered with the JDBC driver manager (java.sql.DriverManager)
  by adding them to the Java system properties. The jdbc.drivers property contains
  a list of driver class names, separated by colons, that are loaded by the JDBC
  driver manager when it is initialised, for instance:</para>
                <programlisting role="JAVA" language="Java">jdbc.drivers=foo.bar.Driver:mydata.sql.Driver:bar.test.myDriver</programlisting>
                <para> On running an application, it is the DriverManager's responsibility to load
  all the drivers found in the system property jdbc.drivers. For example, this
  is where the driver for the Oracle database may be defined. When opening a connection
  to a database it is the DriverManager' s role to choose the most appropriate
  driver from the previously loaded drivers. </para>
                <para> A program can also explicitly load JDBC drivers at any time. For example,
  the my.sql.Driver is loaded with the following statement: </para>
                <programlisting role="JAVA" language="Java">Class.forName("my.sql.Driver"); </programlisting>
                <para>Calling Class.forName() will automatically register the driver with the JDBC
  driver manager. It is also possible to explicitly create an instance of the
  JDBC driver using the registerDriver method of the DriverManager. This is the
  case for instance for the TransactionalDriver that can be registered as follow:</para>
                <programlisting role="JAVA" language="Java">TransactionalDriver arjunaJDBC2Driver = new TransactionalDriver();
DriverManager.registerDriver(arjunaJDBC2Driver);</programlisting>
                <para> When you have loaded a driver, it is available for making a connection with
  a DBMS.</para>
            </section>
            <section>
                <title>Making Connections</title>
                <para>Once a driver is loaded and ready for a connection to be made, instances of
  a Connection class can be created using the getConnection method on the DriverManager,
  as follow:</para>
                <programlisting role="JAVA" language="Java">Connection con = DriverManager.getConnection(url, username, password);</programlisting>
                <para>From its version 2.0, the JDBC API has introduced a new way to obtain instances
  of the Connection class. This is the case of the interfaces DataSource and XADataSource
  that creates transactional connections. When using a JDBC 2.0 driver, &PARENT_PRODUCT;
  will use the appropriate DataSource whenever a connection to the database is
  made. It will then obtain XAResources and register them with the transaction
  via the JTA interfaces. It is these XAResources which the transaction service
  will use when the transaction terminates in order to drive the database to either
  commit or rollback the changes made via the JDBC connection.</para>
                <para> There are two ways in which the &PARENT_PRODUCT; JDBC 2.0 support can obtain XADataSources.
  These will be explained in the following sections. Note, for simplicity we shall
  assume that the JDBC 2.0 driver is instantiated directly by the application.</para>
                <itemizedlist>
                    <listitem>
                        <para>Java Naming and Directory Interface (JNDI)</para>
                        <para> To get the ArjunaJDBC2Driver class to use a JNDI registered XADataSource
      it is first necessary to create the XADataSource instance and store it in
      an appropriate JNDI implementation. Details of how to do this can be found
      in the JDBC 2.0 tutorial available at JavaSoft. An example is show below:</para>
                        <programlisting role="JAVA" language="Java">XADataSource ds = MyXADataSource();
Hashtable env = new Hashtable();
String initialCtx = PropertyManager.
  getProperty("Context.INITIAL_CONTEXT_FACTORY");
env.put(Context.INITIAL_CONTEXT_FACTORY, initialCtx);
initialContext ctx = new InitialContext(env);
ctx.bind("jdbc/foo", ds);</programlisting>
                        <para> Where the Context.INITIAL_CONTEXT_FACTORY property is the JNDI way of
      specifying the type of JNDI implementation to use.</para>
                        <para>      Then the application must pass an appropriate connection URL to the JDBC
      2.0 driver:</para>
                        <programlisting role="JAVA" language="Java">Properties dbProps = new Properties();
dbProps.setProperty(TransactionalDriver.userName, "user");
dbProps.setProperty(TransactionalDriver.password, "password");
TransactionalDriver arjunaJDBC2Driver = new TransactionalDriver();
Connection connection = arjunaJDBC2Driver.
  connect("jdbc:arjuna:jdbc/foo", dbProps);</programlisting>
                        <para> The JNDI URL must be pre-pended with jdbc:arjuna:
      in order for the ArjunaJDBC2Driver to recognise that the DataSource must
      participate within transactions and be driven accordingly. </para>
                    </listitem>
                    <listitem>
                        <para>Dynamic class instantiation</para>
                        <para> Many JDBC implementations provide proprietary implementations of XADataSources
      that provide non-standard extensions to the specification. In order to allow
      the application to remain isolated from the actual JDBC 2.0 implementation
      it is using and yet continue to be able to use these extensions, &PARENT_PRODUCT;
      hides the details of these proprietary implementations using dynamic class
      instantiation. In addition, the use of JNDI is not required when using this
      mechanism because the actual implementation of the XADataSource will be
      directly instantiated, albeit in a manner which will not tie an application
      or driver to a specific implementation. &PARENT_PRODUCT; therefore has several classes
      which are for specific JDBC implementations, and these can be selected
      at runtime by the application setting the dynamicClass property appropriately:
    </para>
                    </listitem>
                </itemizedlist>
                <blockquote>
                    <table width="60%" border="1">
                        <tr>
                            <td width="26%">
                                <emphasis>Database Type</emphasis>
                            </td>
                            <td width="74%">
                                <emphasis>Property Name</emphasis>
                            </td>
                        </tr>
                        <tr>
                            <td>Cloudscape 3.6</td>
                            <td>com.arjuna.ats.internal.jdbc.drivers.cloudscape_3_6</td>
                        </tr>
                        <tr>
                            <td>Sequelink 5.1</td>
                            <td>com.arjuna.ats.internal.jdbc.drivers.sequelink_5_1</td>
                        </tr>
                        <tr>
                            <td>Oracle 8.1.6</td>
                            <td>com.arjuna.ats.internal.jdbc.drivers.oracle_8_1_6</td>
                        </tr>
                        <tr>
                            <td>SQL Server 2000</td>
                            <td>com.arjuna.ats.internal.jdbc.drivers.sqlserver_2_2</td>
                        </tr>
                    </table>
                </blockquote>
                <blockquote>
                    <para>The application code must specify which dynamic class the TransactionalDriver
    should instantiate when setting up the connection:</para>
                </blockquote>
                <itemizedlist>
                    <programlisting role="JAVA" language="Java">Properties dbProps = new Properties();
dbProps.setProperty(TransactionalDriver.userName, "user");
dbProps.setProperty(TransactionalDriver.password, "password");
dbProps.setProperty(TransactionalDriver.dynamicClass,
    "com.arjuna.ats.internal.jdbc.drivers.sequelink_5_0");
TransactionalDriver arjunaJDBC2Driver = new TransactionalDriver();
Connection connection = arjunaJDBC2Driver.connect("jdbc:arjuna:
    sequelink://host:port;databaseName=foo",dbProperties);
</programlisting>
                </itemizedlist>
                <para>Note on properties used by the com.arjuna.ats.jdbc.TransactionalDriver class</para>
                <itemizedlist>
                    <listitem><emphasis>userName</emphasis>: the user name to use when attempting to connect to the
    database.</listitem>
                    <listitem><emphasis>password</emphasis>: the password to use when attempting to connect to the
    database.</listitem>
                    <listitem><emphasis>createDb</emphasis>: if set to true, the driver will attempt to create the
    database when it connects. This may not be supported by all JDBC 2.0 implementations.</listitem>
                    <listitem><emphasis>dynamicClass</emphasis>: this specifies a class to instantiate to connect
    to the database, rather than using JNDI.</listitem>
                </itemizedlist>
            </section>
            <section>
                <title>Using the Connection</title>
                <para>Once the connection has been established (for example, using the java.sql.DriverManager.getConnection
  method), all operations on the connection will be monitored by &PARENT_PRODUCT;. Once
  created, the driver and any connection can be used in the same way as any other
  JDBC driver or connection.</para>
                <para> &PARENT_PRODUCT; connections can be used within multiple different transactions simultaneously,
  i.e., different threads, with different notions of the current transaction,
  may use the same JDBC connection. &PARENT_PRODUCT; does connection pooling for each
  transaction within the JDBC connection. So, although multiple threads may use
  the same instance of the JDBC connection, internally this may be using a different
  connection instance per transaction. With the exception of close, all operations
  performed on the connection at the application level will only be performed
  on this transaction-specific connection.</para>
                <para> &PARENT_PRODUCT; will automatically register the JDBC driver connection with the transaction
  via an appropriate resource . When the transaction terminates, this resource
  will be responsible for either committing or rolling back any changes made to
  the underlying database via appropriate calls on the JDBC driver.</para>
            </section>
            <section>
                <title>Further reading</title>
                <para>More details on the way to manage applications using the JDBC API can be found
  in the &PARENT_PRODUCT; Programming Guide.</para>
            </section>
            <section>
                <title>The banking application as a relational database accessed with JDBC</title>
                <para>In regards to the its structure in the previous trails, the banking application
  described here has been slightly simplified. In this version creating local
  JTA transactions, accounts managed by a bank object are in fact instances or
  tuples within a SQL relational table named "accounts". When the Bank
  object is requested for instance to create an account or to get information
  on an account, the Bank object performs SQL statement such SQL INSERT or SQL
  SELECT.</para>
            </section>
            <section><title>Deploy the application</title><para>Executing the demonstration consists to launch the folowing program</para><programlisting role="JAVA" language="Java">java com.arjuna.demo.jta.jdbcbank.BankClient  -host &lt;hostName&gt;
  -port portNumber  -username &lt;userName&gt;  -dbName &lt;DBName&gt;
  -password &lt;password&gt; -clean|-create</programlisting>
  Where:
		<itemizedlist><listitem>hostName - the name of the machine where is located the database</listitem><listitem>userName - the user name used to access the database</listitem><listitem>password - the password used to access to database</listitem><listitem>DBName   - the database name</listitem><listitem>clean    - the existing relational table will be deleted then created</listitem><listitem>create   - a new relational table will be created</listitem></itemizedlist>

<para><emphasis>Note</emphasis> Due to an issue with Oracle, it is possible that an XA exception is thrown when attempting to perform this test (see Release Notes).
If an xa error is returned you can use the following property property <emphasis>com.arjuna.ats.jdbc.isolationLevel </emphasis> set to <emphasis>TRANSACTION_READ_COMMITTED</emphasis>.</para>
<para>This property can be added in previous command as follow:
</para>
<programlisting role="JAVA" language="Java">java -Dcom.arjuna.ats.jdbc.isolationLevel=TRANSACTION_READ_COMMITTED
     com.arjuna.demo.jta.jdbcbank.BankClient  -host &lt;hostName&gt;
    -port portNumber  -userName &lt;userName&gt;
    -password &lt;password&gt; -clean|-create</programlisting>



</section>
            <section>
                <title>How JDBC is used</title>
                <para>The following Banking application illustrates some methods that use the JDBC API. In this application, the way
  to create a jdbc connection is made via an XADataSource obtained with JNDI operations, es explained in the previous
  trail jdbc introduction
  The BankClient class instantiates an XADataSource and bind it to a jndi naming in order to be retrieved to create
  transactional connections.
  This portion of code illustrates how this made against oracle (tested on version 9i). A similar code could tested
  against an other database by providng the appropriate XADataSource implementation. Details of the BankClient class
  can be found in the file src/com/arjuna/demo/jta/jdbcbank/BankClient.java</para>
                <programlisting role="JAVA" language="Java">
  package com.arjuna.demo.jta.jdbcbank;

  import javax.naming.*;
  import java.util.Hashtable;
  import oracle.jdbc.xa.client.OracleXADataSource;
  import com.arjuna.ats.jdbc.common.jdbcPropertyManager;

  public class BankClient
  {
   .....
   public static void main(String[] args)
    {
      //Provide the apporopriate information to access the database
      for (int i = 0; i &lt; args.length; i++)
      {
          if (args[i].compareTo("-host") == 0)
              host = args[i + 1]
		  if (args[i].compareTo("-port") == 0)
                port = args[i + 1];
		  if (args[i].compareTo("-username") == 0)
                user = args[i + 1];
          if (args[i].compareTo("-password") == 0)
                password = args[i + 1];
	      if (args[i].compareTo("-dbName") == 0)
                dbName = args[i + 1];
          ....
      }

     try
     {
       // create DataSource
       OracleXADataSource ds = new OracleXADataSource();
       ds.setURL("jdbc:oracle:thin:@"+host+":"+port+":"+dbName);

       // now stick it into JNDI
       Hashtable env = new Hashtable();
       env.put (Context.INITIAL_CONTEXT_FACTORY,
	   "com.sun.jndi.fscontext.RefFSContextFactory");
	    env.put (Context.PROVIDER_URL, "file:/tmp/JNDI");
	    InitialContext ctx = new InitialContext(env);
	    ctx.rebind("jdbc/DB", ds);
     }
	 catch (Exception ex)
	 { }
  	 //Set the jndi information to be user by the Arjuna JDBC Property Manager
	 jdbcPropertyManager.propertyManager.setProperty("Context.INITIAL_CONTEXT_FACTORY",
	   "com.sun.jndi.fscontext.RefFSContextFactory");
	 jdbcPropertyManager.propertyManager.setProperty("Context.PROVIDER_URL",
	   "file:/tmp/JNDI");

	 Bank bank = new Bank();
     BankClient client = new BankClient(bank);

   }
  </programlisting>
                <para>
  While the BankClient class is responsible to obtain information to access the database, tocreate the XADataSource
  and bind it to jndi, and also to get order from a user (create_account, debit, transfer, ..), the Bank class is resposnible
  to create jdbc connections to perform user's requests. The Bank class is illustarted below where.  All
   methods are not illusrated here but have a similar behavior; they could be found in
  details in the src/com/arjuna/demo/jta/jdbcbank/Bank.java"&gt;Bank.java
  program. Note that for simplicity, much error checking code has been removed.</para>
                <programlisting role="JAVA" language="Java">public Bank()
{
  try
  {
    DriverManager.registerDriver(new TransactionalDriver());
    dbProperties = new Properties();
    dbProperties.put(TransactionalDriver.userName, user);
    dbProperties.put(TransactionalDriver.password, password);
    arjunaJDBC2Driver = new TransactionalDriver(); //
	create_table();
  }
   catch (Exception e)
   {
   e.printStackTrace();
   System.exit(0);
   }

   _accounts = new java.util.Hashtable();
   reuseConnection = true;
   }

   public void create_account( String _name, float _value )
   {
    try
    {
	  Connection conne = arjunaJDBC2Driver.connect("jdbc:arjuna:jdbc/DB", dbProperties);
      Statement stmtx = conne.createStatement(); // tx statement
      stmtx.executeUpdate
        ("INSERT INTO accounts (name, value)
          VALUES ('"+_name+"',"+_value+")");
    }
    catch (SQLException e)
    {
      e.printStackTrace();
    }
   }

  public float get_balance(String _name)
     throws NotExistingAccount
  {
    float theBalance = 0;
    try
    {
	  Connection conne = arjunaJDBC2Driver.connect("jdbc:arjuna:jdbc/DB", dbProperties);
      Statement stmtx = conne.createStatement(); // tx statement
      ResultSet rs = stmtx.executeQuery
         ("SELECT value from accounts
           WHERE name    = '"+_name+"'");
      while (rs.next()) {
        theBalance = rs.getFloat("value");
      }
    }
    catch (SQLException e)
    {
      e.printStackTrace();
      throw new NotExistingAccount("The Account requested does not exist");
    }
    return theBalance;
  }

 ...
}
</programlisting>
            </section>
            <section>
                <title>Note</title>
                <para>Although, this version of the banking application creates JTA local transactions,
  the way to manipulate JDBC API and the associated &PARENT_PRODUCT; mechanisms in the
  case of distributed transactions is the same.</para>
            </section>
        </section>
    </section>
    <section>
        <title>Recovery From Failure Examples</title>
        <section>
            <title>Introduction</title>
            <para>Recovery is the mechanism which preserves the transaction atomicity in presence of failures.
				The basic technique for implementing transactions in presence of failures is based on the use
				of logs.  That is, a transaction system has to record enough information to ensure that it can
				be able to return to a previous state in case of failure or to ensure that changes committed by a
				transaction are properly stored.</para>
            <para>
				&PARENT_PRODUCT; ensures that results of a transaction are applied consistently to all resources involved in
				a transaction, even in the presence of failure. To recover from failure, &PARENT_PRODUCT; relies on its Recovery
				Manager.</para>
            <para>
				Basically, the Recovery Manager is a daemon process that invokes a set of well known Recovery Modules
				periodically in two steps; a first to determine transactions in doubt state and a second step to continue
				the completion of those transactions found in the first step. Since different type of resources may be
				involved in a transaction, different type of Recovery Modules may exist. &PARENT_PRODUCT; provides several type of
				modules that manage resources according to their position in the transaction tree (root, subordinate, leaf)
				or the nature of the data itself, transactional object for java or XAResource as seen in
				the previous trail. </para>
            <para>
				Whatever the nature of the involved resource, recovery is based on information or logs held in the Object Store,
				which contains specific subdirectory holding information according to the nature of the participant.
				</para>
        </section>
        <section>
            <title>Running the Recovery Manager</title>
            <para>
                <emphasis>This section provides only brief information on running the recovery manager from provided scripts.
				For complete information on the recovery manager (including how to configure it), see the &PARENT_PRODUCT; recovery information.</emphasis>
            </para>
            <section>
                <title>Windows</title>
                <para>
				To run the Recovery Manager as a Windows service, simply:</para>
                <itemizedlist>
                    <listitem>Open a command prompt</listitem>
                    <listitem>cd to the directory &lt;jbossts_install_root&gt;\services\bin\windows</listitem>
                    <listitem>Type InstallRecoveryManagerService-NT.bat</listitem>
                </itemizedlist>
                <para>
				Note: This directory also contains the uninstall script which is ran in the same manner.</para>
                <para>
				To launch the Recovery Manager as a Windows process, simply:</para>
                <itemizedlist>
                    <listitem>Open a command prompt</listitem>
                    <listitem>cd to the directory &lt;jbossts_install_root&gt;\services\bin\windows</listitem>
                    <listitem>Type recoverymanagerservice.bat</listitem>
                </itemizedlist>
            </section>
            <section>
                <title>UNIX</title>
                <para>
				To launch the Recovery Manager on a Linux/UNIX platform, simply:</para>
                <itemizedlist>
                    <listitem>Open a command prompt</listitem>
                    <listitem>cd to the directory &lt;jbossts_install_root&gt;\services\bin\[platform]</listitem>
                    <listitem>Type recoverymanagerservice.sh start</listitem>
                </itemizedlist>
                <para>
				Note: To uninstall the recovery manager, rerun the script specifying the stop flag.</para>
            </section>
        </section>
        <section>
            <title>The Recovery Process and XAResources</title>
            <para>
				The &PARENT_PRODUCT; recovery manager provides support for recovering XAResources whether or not they are Serializable. XAResources that <emphasis>do</emphasis>
				implement the Serializable interface are handled without requiring additional programmer defined classes. For those XAResources that need
				to recover but which cannot implement Serializable, it is possible to provide a small class which is used to help recover them.</para>
            <para>
				This example shows the &PARENT_PRODUCT; recovery manager recovering a Serializable XAResource and a non-Serializable XAResource.</para>
            <section><title>The demo's components</title>
				The application consists of four classes. Each class is well documented and it is recommended that the provided code is inspected to gain
				useful insight into some of the nuances of the recovery process.
				<itemizedlist><listitem>The code of the main class that controls the application
				(src/com/arjuna/demo/recovery/xaresource/TestXAResourceRecovery.java"&gt;TestRecoveryModule.java), allows
				the user to specify a number of options: [-waitForRecovery] [-useExternalRecoveryManager]</listitem><listitem>Programmer-defined support of the Serializable XAResource is only required in the XAResource implementation class
				src/com/arjuna/demo/recovery/xaresource/ExampleXAResource.java"&gt;ExampleXAResource.java</listitem><listitem>Programmer-defined support of the non-Serializable XAResource is required both in the XAResource implementation class
				src/com/arjuna/demo/recovery/xaresource/NonSerializableExampleXAResource.java"&gt;NonSerializableExampleXAResource,
				and in a class that implements a helper for the &PARENT_PRODUCT; recovery process
				src/com/arjuna/demo/recovery/xaresource/NonSerializableExampleXAResourceRecovery.java"&gt;NonSerializableExampleXAResourceRecovery.java</listitem></itemizedlist>
</section>
            <section>
                <title>XAResourceRecovery registration</title>
                <para>
         			When recovering from failures, &PARENT_PRODUCT; requires the ability to reconnect to the resource managers
 			        that were in use prior to the failures in order to resolve any outstanding transactions.
			        In order to recreate those connections for non-Serializable XAResources it is necessary to
				provide implementations of the following &PARENT_PRODUCT; interface com.arjuna.ats.jta.recovery.XAResourceRecovery.</para>
                <para>
			        To inform the recovery system about each of the XAResourceRecovery instances, it is
			        necessary to specify their class names through property variables in the jbossts-properties.xml file.
				Any property variable which starts with the name XAResourceRecovery will be assumed to represent
				one of these instances, and its value should be the class name.</para>
                <para>
			        When running XA transaction recovery it is necessary to tell &PARENT_PRODUCT; which types of
			        Xid it can recover. Each Xid that &PARENT_PRODUCT; creates has a unique node
			        identifier encoded within it and &PARENT_PRODUCT; will only recover transactions
			        and states that match a specified node identifier. The node identifier to
			        use should be provided to &PARENT_PRODUCT; via a property that starts with the
			        name com.arjuna.ats.jta.xaRecoveryNode (multiple values may
			        be provided). A value of * will force &PARENT_PRODUCT; to recover (and possibly
			        rollback) all transactions irrespective of their node identifier and should be
			        used with caution.</para>
                <para>
				The recovery module for the non-Serializable XAResource must be deployed in order to provide support to recover the non-Serializable XAResource.
				If this step was missed out the Serializable XAResource would recover OK but &PARENT_PRODUCT; would have no knowledge of the non-Serializable XAResource
				and so it could not recover it. To register the non-Serializable XAResource XAResourceRecovery module, add an entry to the jbossts-properties.xml.</para>
                <para>
				Under the element &lt;properties depends="jts" name="jta"&gt;, add:</para>
                <blockquote>
				&lt;property name="com.arjuna.ats.jta.recovery.XAResourceRecovery1" value=
				"com.arjuna.demo.recovery.xaresource.NonSerializableExampleXAResourceRecovery"/&gt;
				&lt;property name="com.arjuna.ats.jta.xaRecoveryNode" value="*"/&gt;
				</blockquote>
                <section>
                    <title>Configure the recovery manager scan period</title>
                    <para>
				By default, the recovery manager is configured to perform a pass over resources to be recovered every two minutes. It will then wait for ten seconds
				before re-checking the resources. Although the test will run OK with this configuration, it is possible to configure the recovery
				manager scan times to reduce the time waiting. To configure the intervals, edit the jbossts-properties.xml as follows:</para>
                    <itemizedlist>
                        <listitem>Edit the property "com.arjuna.ats.arjuna.recovery.periodicRecoveryPeriod"
					to change the value from 120 to 5.</listitem>
                        <listitem>Edit the property "com.arjuna.ats.arjuna.recovery.recoveryBackoffPeriod"
					to change the value from 10 to 5.</listitem>
                    </itemizedlist>
                </section>
                <section>
                    <title>Specify the transaction manager type to use</title>
                    <para>
				The recovery manager will work in the same manner for either the JTA or JTS implementation. By default &PARENT_PRODUCT;
				is configured to use a JTS transaction manager, in order to configure it to use a JTA transaction manager a change must again be made
				to the jbossts-properties.xml. <emphasis>See "Testing JTA" for more information on how to configure
				the &PARENT_PRODUCT; transaction manager to use JTA rather than JTS.</emphasis></para>
                    <para>
                        <emphasis>If you do change the transaction manager type remember to reconfigure the recovery manager as follows:</emphasis>
                    </para>
                    <para>
				If you are using the ArjunaCore (raw JTA) transaction manager implementation comment out the element in jbossts-properties.xml containing the following text:</para>
                    <blockquote>
                        internal.jta.recovery.jts.XARecoveryModule
                    </blockquote>
                    <para>
				If you are using the JTS transaction manager implementation comment out the element in jbossts-properties.xml containing the following text:</para>
                    <blockquote>
                        internal.jta.recovery.arjunacore.XARecoveryModule
                    </blockquote>
                </section>
                <section>
                    <title>Launching the demo</title>
                    <para>To launch the Test Recovery Module, execute the following java program</para>
                    <itemizedlist>
                        <listitem>Open a command prompt</listitem>
                        <listitem>cd to the directory &lt;jbossts_install_root&gt;\trail_map</listitem>
                        <listitem>Type java com.arjuna.demo.recovery.xaresource.TestXAResourceRecovery</listitem>
                        <listitem>View the output noting the crash during commit.</listitem>
                        <listitem>Inspect the current working directory to note that the applications have created several log files which you may like to review.</listitem>
                        <listitem>Type java com.arjuna.demo.recovery.xaresource.TestXAResourceRecovery -waitForRecovery</listitem>
                        <listitem>Wait for the two resources to be recovered and committed.</listitem>
                        <listitem>Re-review the log files from the working directory, if wanted.</listitem>
                    </itemizedlist>
                    <para>
				Note: As you can see, the Serializable XAResource does not need it's recover() method called as the transaction manager is aware of all the
				information about this resource.</para>
                </section>
                <section><title>The Recovery Process and AbstractRecords</title><para><emphasis>WARNING: Implementing a RecoveryModule and AbstractRecord is a very advanced feature of the transaction service. It should only
				be performed by users familiar with the all the concepts used in the &PARENT_PRODUCT; product. Please see the ArjunaCore guide for more
				information about RecoveryModules and AbstractRecords.</emphasis></para><para>
				The following sample gives an overview how the Recovery Manager invokes a module to recover from failure.
				This basic sample does not aim to present a complete process to recover from failure, but mainly to illustrate
				the way to implement a recovery module. More details can be found in "Failure Recovery Guide". </para>
				The application used here consists to create an atomic transaction, to register a participant within
				the created transaction and finally to terminate it either by commit or abort. A set of arguments
				are provided:
				<itemizedlist><listitem>to decide committing or aborting the transaction,</listitem><listitem>to decide generating a crash during the commitment process. </listitem></itemizedlist>
<section><title>The demo's components</title>
				The application consists of three programs
				<itemizedlist><listitem>The code of the main class that control the application
				(src/com/arjuna/demo/recoverymodule/TestRecoveryModule.java"&gt;TestRecoveryModule.java),
				which consists to give the choice to either commit or abort the transaction and also to generate a crash.
				</listitem><listitem>The registered participant (src/com/arjuna/demo/recoverymodule/SimpleRecord.java"&gt;SimpleRecord.java) has the following behaviour: <programlisting role="JAVA" language="Java">
					- During the prepare phase, it writes a simple message - "I'm prepared" - on the disk such
					The message is written in a well known file 
					- During the commit phase, it writes another message - "I'm committed" - in the same file
					used during prepare 
					- If it receives an abort message, it removes from the disk the file used for prepare if any. 
					- if a crash has been decided for the test, then it crashes during the commit phase - the file remains
					with the message "I'm prepared".</programlisting>
				</listitem><listitem>A Recovery Module (src/com/arjuna/demo/recoverymodule/SimpleRecoveryModule.java"&gt;SimpleRecoveryModule.java) that consists to read the content of the file used to store the status of the participant,
				to determine that status and print a message indicating if a recovery action is needed or not.
				</listitem></itemizedlist>
				Using the provided &PARENT_PRODUCT; Recovery Modules ensures that resources are correctly recovered. This sample illustrates
				how to define and register its own module. It's the responsibility of the module to re-create the appropriate
				objects using information retrieved from a log.

</section><section><title>Recovery Module registration</title>
				The recovery module should now be deployed in order to be called by the Recovery Manager. To do so,
				we just need to add an entry in the jbossts-properties.xml by adding a new property as follow:
				<blockquote>
					&lt;property name="com.arjuna.ats.arjuna.recovery.recoveryExtension&lt;i&gt;"
				        value="com.arjuna.demo.recoverymodule.SimpleRecoveryModule"/&gt;
				</blockquote>
Where &lt;i&gt; represent the new occurrence number that follows the last that already exists in the file. Once started, the Recovery Manager will automatically load the added Recovery module.

</section><section><title>Starting the Recovery Manager</title>
			In a separate window launch the Recovery Manager,
  as follows:
					<programlisting role="JAVA" language="Java">java com.arjuna.ats.arjuna.recovery.RecoveryManager -test</programlisting>

</section><section><title>Launching the demo</title><para>To launch the Test Recovery Module, execute the following java program</para><programlisting role="JAVA" language="Java">java com.arjuna.demo.recoverymodule.TestRecoveryModule
		[-commit|-abort] [-crash]</programlisting></section></section>
            </section>
        </section>
    </section>
</chapter>
